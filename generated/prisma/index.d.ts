
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model RoadmapMatcher
 * 
 */
export type RoadmapMatcher = $Result.DefaultSelection<Prisma.$RoadmapMatcherPayload>
/**
 * Model assessment
 * 
 */
export type assessment = $Result.DefaultSelection<Prisma.$assessmentPayload>
/**
 * Model BookmarkCourse
 * 
 */
export type BookmarkCourse = $Result.DefaultSelection<Prisma.$BookmarkCoursePayload>
/**
 * Model category
 * 
 */
export type category = $Result.DefaultSelection<Prisma.$categoryPayload>
/**
 * Model certificate
 * 
 */
export type certificate = $Result.DefaultSelection<Prisma.$certificatePayload>
/**
 * Model chatmessage
 * 
 */
export type chatmessage = $Result.DefaultSelection<Prisma.$chatmessagePayload>
/**
 * Model counselingsession
 * 
 */
export type counselingsession = $Result.DefaultSelection<Prisma.$counselingsessionPayload>
/**
 * Model counselor
 * 
 */
export type counselor = $Result.DefaultSelection<Prisma.$counselorPayload>
/**
 * Model course
 * 
 */
export type course = $Result.DefaultSelection<Prisma.$coursePayload>
/**
 * Model courseprogress
 * 
 */
export type courseprogress = $Result.DefaultSelection<Prisma.$courseprogressPayload>
/**
 * Model coursevideo
 * 
 */
export type coursevideo = $Result.DefaultSelection<Prisma.$coursevideoPayload>
/**
 * Model cvreview
 * 
 */
export type cvreview = $Result.DefaultSelection<Prisma.$cvreviewPayload>
/**
 * Model enrollment
 * 
 */
export type enrollment = $Result.DefaultSelection<Prisma.$enrollmentPayload>
/**
 * Model jobmatch
 * 
 */
export type jobmatch = $Result.DefaultSelection<Prisma.$jobmatchPayload>
/**
 * Model lesson
 * 
 */
export type lesson = $Result.DefaultSelection<Prisma.$lessonPayload>
/**
 * Model lessonprogress
 * 
 */
export type lessonprogress = $Result.DefaultSelection<Prisma.$lessonprogressPayload>
/**
 * Model notification
 * 
 */
export type notification = $Result.DefaultSelection<Prisma.$notificationPayload>
/**
 * Model payment
 * 
 */
export type payment = $Result.DefaultSelection<Prisma.$paymentPayload>
/**
 * Model quiz
 * 
 */
export type quiz = $Result.DefaultSelection<Prisma.$quizPayload>
/**
 * Model quizsubmission
 * 
 */
export type quizsubmission = $Result.DefaultSelection<Prisma.$quizsubmissionPayload>
/**
 * Model roadmap
 * 
 */
export type roadmap = $Result.DefaultSelection<Prisma.$roadmapPayload>
/**
 * Model roadmapcourse
 * 
 */
export type roadmapcourse = $Result.DefaultSelection<Prisma.$roadmapcoursePayload>
/**
 * Model userroadmap
 * 
 */
export type userroadmap = $Result.DefaultSelection<Prisma.$userroadmapPayload>
/**
 * Model Voucher
 * 
 */
export type Voucher = $Result.DefaultSelection<Prisma.$VoucherPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  USER: 'USER',
  CONSULTANT: 'CONSULTANT'
};

export type Role = (typeof Role)[keyof typeof Role]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roadmapMatcher`: Exposes CRUD operations for the **RoadmapMatcher** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoadmapMatchers
    * const roadmapMatchers = await prisma.roadmapMatcher.findMany()
    * ```
    */
  get roadmapMatcher(): Prisma.RoadmapMatcherDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.assessment`: Exposes CRUD operations for the **assessment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Assessments
    * const assessments = await prisma.assessment.findMany()
    * ```
    */
  get assessment(): Prisma.assessmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bookmarkCourse`: Exposes CRUD operations for the **BookmarkCourse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BookmarkCourses
    * const bookmarkCourses = await prisma.bookmarkCourse.findMany()
    * ```
    */
  get bookmarkCourse(): Prisma.BookmarkCourseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.categoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.certificate`: Exposes CRUD operations for the **certificate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Certificates
    * const certificates = await prisma.certificate.findMany()
    * ```
    */
  get certificate(): Prisma.certificateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatmessage`: Exposes CRUD operations for the **chatmessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chatmessages
    * const chatmessages = await prisma.chatmessage.findMany()
    * ```
    */
  get chatmessage(): Prisma.chatmessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.counselingsession`: Exposes CRUD operations for the **counselingsession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Counselingsessions
    * const counselingsessions = await prisma.counselingsession.findMany()
    * ```
    */
  get counselingsession(): Prisma.counselingsessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.counselor`: Exposes CRUD operations for the **counselor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Counselors
    * const counselors = await prisma.counselor.findMany()
    * ```
    */
  get counselor(): Prisma.counselorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.course`: Exposes CRUD operations for the **course** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Courses
    * const courses = await prisma.course.findMany()
    * ```
    */
  get course(): Prisma.courseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.courseprogress`: Exposes CRUD operations for the **courseprogress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Courseprogresses
    * const courseprogresses = await prisma.courseprogress.findMany()
    * ```
    */
  get courseprogress(): Prisma.courseprogressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.coursevideo`: Exposes CRUD operations for the **coursevideo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Coursevideos
    * const coursevideos = await prisma.coursevideo.findMany()
    * ```
    */
  get coursevideo(): Prisma.coursevideoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cvreview`: Exposes CRUD operations for the **cvreview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cvreviews
    * const cvreviews = await prisma.cvreview.findMany()
    * ```
    */
  get cvreview(): Prisma.cvreviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.enrollment`: Exposes CRUD operations for the **enrollment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Enrollments
    * const enrollments = await prisma.enrollment.findMany()
    * ```
    */
  get enrollment(): Prisma.enrollmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jobmatch`: Exposes CRUD operations for the **jobmatch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Jobmatches
    * const jobmatches = await prisma.jobmatch.findMany()
    * ```
    */
  get jobmatch(): Prisma.jobmatchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lesson`: Exposes CRUD operations for the **lesson** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lessons
    * const lessons = await prisma.lesson.findMany()
    * ```
    */
  get lesson(): Prisma.lessonDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lessonprogress`: Exposes CRUD operations for the **lessonprogress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lessonprogresses
    * const lessonprogresses = await prisma.lessonprogress.findMany()
    * ```
    */
  get lessonprogress(): Prisma.lessonprogressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.notificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.paymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quiz`: Exposes CRUD operations for the **quiz** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quizzes
    * const quizzes = await prisma.quiz.findMany()
    * ```
    */
  get quiz(): Prisma.quizDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quizsubmission`: Exposes CRUD operations for the **quizsubmission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quizsubmissions
    * const quizsubmissions = await prisma.quizsubmission.findMany()
    * ```
    */
  get quizsubmission(): Prisma.quizsubmissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roadmap`: Exposes CRUD operations for the **roadmap** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roadmaps
    * const roadmaps = await prisma.roadmap.findMany()
    * ```
    */
  get roadmap(): Prisma.roadmapDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roadmapcourse`: Exposes CRUD operations for the **roadmapcourse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roadmapcourses
    * const roadmapcourses = await prisma.roadmapcourse.findMany()
    * ```
    */
  get roadmapcourse(): Prisma.roadmapcourseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userroadmap`: Exposes CRUD operations for the **userroadmap** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Userroadmaps
    * const userroadmaps = await prisma.userroadmap.findMany()
    * ```
    */
  get userroadmap(): Prisma.userroadmapDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.voucher`: Exposes CRUD operations for the **Voucher** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vouchers
    * const vouchers = await prisma.voucher.findMany()
    * ```
    */
  get voucher(): Prisma.VoucherDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    RoadmapMatcher: 'RoadmapMatcher',
    assessment: 'assessment',
    BookmarkCourse: 'BookmarkCourse',
    category: 'category',
    certificate: 'certificate',
    chatmessage: 'chatmessage',
    counselingsession: 'counselingsession',
    counselor: 'counselor',
    course: 'course',
    courseprogress: 'courseprogress',
    coursevideo: 'coursevideo',
    cvreview: 'cvreview',
    enrollment: 'enrollment',
    jobmatch: 'jobmatch',
    lesson: 'lesson',
    lessonprogress: 'lessonprogress',
    notification: 'notification',
    payment: 'payment',
    quiz: 'quiz',
    quizsubmission: 'quizsubmission',
    roadmap: 'roadmap',
    roadmapcourse: 'roadmapcourse',
    userroadmap: 'userroadmap',
    Voucher: 'Voucher'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "roadmapMatcher" | "assessment" | "bookmarkCourse" | "category" | "certificate" | "chatmessage" | "counselingsession" | "counselor" | "course" | "courseprogress" | "coursevideo" | "cvreview" | "enrollment" | "jobmatch" | "lesson" | "lessonprogress" | "notification" | "payment" | "quiz" | "quizsubmission" | "roadmap" | "roadmapcourse" | "userroadmap" | "voucher"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      RoadmapMatcher: {
        payload: Prisma.$RoadmapMatcherPayload<ExtArgs>
        fields: Prisma.RoadmapMatcherFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoadmapMatcherFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapMatcherPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoadmapMatcherFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapMatcherPayload>
          }
          findFirst: {
            args: Prisma.RoadmapMatcherFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapMatcherPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoadmapMatcherFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapMatcherPayload>
          }
          findMany: {
            args: Prisma.RoadmapMatcherFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapMatcherPayload>[]
          }
          create: {
            args: Prisma.RoadmapMatcherCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapMatcherPayload>
          }
          createMany: {
            args: Prisma.RoadmapMatcherCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RoadmapMatcherDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapMatcherPayload>
          }
          update: {
            args: Prisma.RoadmapMatcherUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapMatcherPayload>
          }
          deleteMany: {
            args: Prisma.RoadmapMatcherDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoadmapMatcherUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoadmapMatcherUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapMatcherPayload>
          }
          aggregate: {
            args: Prisma.RoadmapMatcherAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoadmapMatcher>
          }
          groupBy: {
            args: Prisma.RoadmapMatcherGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoadmapMatcherGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoadmapMatcherCountArgs<ExtArgs>
            result: $Utils.Optional<RoadmapMatcherCountAggregateOutputType> | number
          }
        }
      }
      assessment: {
        payload: Prisma.$assessmentPayload<ExtArgs>
        fields: Prisma.assessmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.assessmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assessmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.assessmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assessmentPayload>
          }
          findFirst: {
            args: Prisma.assessmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assessmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.assessmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assessmentPayload>
          }
          findMany: {
            args: Prisma.assessmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assessmentPayload>[]
          }
          create: {
            args: Prisma.assessmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assessmentPayload>
          }
          createMany: {
            args: Prisma.assessmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.assessmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assessmentPayload>
          }
          update: {
            args: Prisma.assessmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assessmentPayload>
          }
          deleteMany: {
            args: Prisma.assessmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.assessmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.assessmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assessmentPayload>
          }
          aggregate: {
            args: Prisma.AssessmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssessment>
          }
          groupBy: {
            args: Prisma.assessmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssessmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.assessmentCountArgs<ExtArgs>
            result: $Utils.Optional<AssessmentCountAggregateOutputType> | number
          }
        }
      }
      BookmarkCourse: {
        payload: Prisma.$BookmarkCoursePayload<ExtArgs>
        fields: Prisma.BookmarkCourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookmarkCourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkCoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookmarkCourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkCoursePayload>
          }
          findFirst: {
            args: Prisma.BookmarkCourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkCoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookmarkCourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkCoursePayload>
          }
          findMany: {
            args: Prisma.BookmarkCourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkCoursePayload>[]
          }
          create: {
            args: Prisma.BookmarkCourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkCoursePayload>
          }
          createMany: {
            args: Prisma.BookmarkCourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BookmarkCourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkCoursePayload>
          }
          update: {
            args: Prisma.BookmarkCourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkCoursePayload>
          }
          deleteMany: {
            args: Prisma.BookmarkCourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookmarkCourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BookmarkCourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkCoursePayload>
          }
          aggregate: {
            args: Prisma.BookmarkCourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookmarkCourse>
          }
          groupBy: {
            args: Prisma.BookmarkCourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookmarkCourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookmarkCourseCountArgs<ExtArgs>
            result: $Utils.Optional<BookmarkCourseCountAggregateOutputType> | number
          }
        }
      }
      category: {
        payload: Prisma.$categoryPayload<ExtArgs>
        fields: Prisma.categoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.categoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.categoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>
          }
          findFirst: {
            args: Prisma.categoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.categoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>
          }
          findMany: {
            args: Prisma.categoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>[]
          }
          create: {
            args: Prisma.categoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>
          }
          createMany: {
            args: Prisma.categoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.categoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>
          }
          update: {
            args: Prisma.categoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>
          }
          deleteMany: {
            args: Prisma.categoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.categoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.categoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.categoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.categoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      certificate: {
        payload: Prisma.$certificatePayload<ExtArgs>
        fields: Prisma.certificateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.certificateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.certificateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificatePayload>
          }
          findFirst: {
            args: Prisma.certificateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.certificateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificatePayload>
          }
          findMany: {
            args: Prisma.certificateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificatePayload>[]
          }
          create: {
            args: Prisma.certificateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificatePayload>
          }
          createMany: {
            args: Prisma.certificateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.certificateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificatePayload>
          }
          update: {
            args: Prisma.certificateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificatePayload>
          }
          deleteMany: {
            args: Prisma.certificateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.certificateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.certificateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificatePayload>
          }
          aggregate: {
            args: Prisma.CertificateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCertificate>
          }
          groupBy: {
            args: Prisma.certificateGroupByArgs<ExtArgs>
            result: $Utils.Optional<CertificateGroupByOutputType>[]
          }
          count: {
            args: Prisma.certificateCountArgs<ExtArgs>
            result: $Utils.Optional<CertificateCountAggregateOutputType> | number
          }
        }
      }
      chatmessage: {
        payload: Prisma.$chatmessagePayload<ExtArgs>
        fields: Prisma.chatmessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.chatmessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatmessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.chatmessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatmessagePayload>
          }
          findFirst: {
            args: Prisma.chatmessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatmessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.chatmessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatmessagePayload>
          }
          findMany: {
            args: Prisma.chatmessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatmessagePayload>[]
          }
          create: {
            args: Prisma.chatmessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatmessagePayload>
          }
          createMany: {
            args: Prisma.chatmessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.chatmessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatmessagePayload>
          }
          update: {
            args: Prisma.chatmessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatmessagePayload>
          }
          deleteMany: {
            args: Prisma.chatmessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.chatmessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.chatmessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatmessagePayload>
          }
          aggregate: {
            args: Prisma.ChatmessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatmessage>
          }
          groupBy: {
            args: Prisma.chatmessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatmessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.chatmessageCountArgs<ExtArgs>
            result: $Utils.Optional<ChatmessageCountAggregateOutputType> | number
          }
        }
      }
      counselingsession: {
        payload: Prisma.$counselingsessionPayload<ExtArgs>
        fields: Prisma.counselingsessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.counselingsessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counselingsessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.counselingsessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counselingsessionPayload>
          }
          findFirst: {
            args: Prisma.counselingsessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counselingsessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.counselingsessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counselingsessionPayload>
          }
          findMany: {
            args: Prisma.counselingsessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counselingsessionPayload>[]
          }
          create: {
            args: Prisma.counselingsessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counselingsessionPayload>
          }
          createMany: {
            args: Prisma.counselingsessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.counselingsessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counselingsessionPayload>
          }
          update: {
            args: Prisma.counselingsessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counselingsessionPayload>
          }
          deleteMany: {
            args: Prisma.counselingsessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.counselingsessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.counselingsessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counselingsessionPayload>
          }
          aggregate: {
            args: Prisma.CounselingsessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCounselingsession>
          }
          groupBy: {
            args: Prisma.counselingsessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CounselingsessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.counselingsessionCountArgs<ExtArgs>
            result: $Utils.Optional<CounselingsessionCountAggregateOutputType> | number
          }
        }
      }
      counselor: {
        payload: Prisma.$counselorPayload<ExtArgs>
        fields: Prisma.counselorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.counselorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counselorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.counselorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counselorPayload>
          }
          findFirst: {
            args: Prisma.counselorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counselorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.counselorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counselorPayload>
          }
          findMany: {
            args: Prisma.counselorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counselorPayload>[]
          }
          create: {
            args: Prisma.counselorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counselorPayload>
          }
          createMany: {
            args: Prisma.counselorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.counselorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counselorPayload>
          }
          update: {
            args: Prisma.counselorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counselorPayload>
          }
          deleteMany: {
            args: Prisma.counselorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.counselorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.counselorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$counselorPayload>
          }
          aggregate: {
            args: Prisma.CounselorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCounselor>
          }
          groupBy: {
            args: Prisma.counselorGroupByArgs<ExtArgs>
            result: $Utils.Optional<CounselorGroupByOutputType>[]
          }
          count: {
            args: Prisma.counselorCountArgs<ExtArgs>
            result: $Utils.Optional<CounselorCountAggregateOutputType> | number
          }
        }
      }
      course: {
        payload: Prisma.$coursePayload<ExtArgs>
        fields: Prisma.courseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.courseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.courseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coursePayload>
          }
          findFirst: {
            args: Prisma.courseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.courseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coursePayload>
          }
          findMany: {
            args: Prisma.courseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coursePayload>[]
          }
          create: {
            args: Prisma.courseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coursePayload>
          }
          createMany: {
            args: Prisma.courseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.courseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coursePayload>
          }
          update: {
            args: Prisma.courseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coursePayload>
          }
          deleteMany: {
            args: Prisma.courseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.courseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.courseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coursePayload>
          }
          aggregate: {
            args: Prisma.CourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourse>
          }
          groupBy: {
            args: Prisma.courseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.courseCountArgs<ExtArgs>
            result: $Utils.Optional<CourseCountAggregateOutputType> | number
          }
        }
      }
      courseprogress: {
        payload: Prisma.$courseprogressPayload<ExtArgs>
        fields: Prisma.courseprogressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.courseprogressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$courseprogressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.courseprogressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$courseprogressPayload>
          }
          findFirst: {
            args: Prisma.courseprogressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$courseprogressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.courseprogressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$courseprogressPayload>
          }
          findMany: {
            args: Prisma.courseprogressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$courseprogressPayload>[]
          }
          create: {
            args: Prisma.courseprogressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$courseprogressPayload>
          }
          createMany: {
            args: Prisma.courseprogressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.courseprogressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$courseprogressPayload>
          }
          update: {
            args: Prisma.courseprogressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$courseprogressPayload>
          }
          deleteMany: {
            args: Prisma.courseprogressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.courseprogressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.courseprogressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$courseprogressPayload>
          }
          aggregate: {
            args: Prisma.CourseprogressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseprogress>
          }
          groupBy: {
            args: Prisma.courseprogressGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseprogressGroupByOutputType>[]
          }
          count: {
            args: Prisma.courseprogressCountArgs<ExtArgs>
            result: $Utils.Optional<CourseprogressCountAggregateOutputType> | number
          }
        }
      }
      coursevideo: {
        payload: Prisma.$coursevideoPayload<ExtArgs>
        fields: Prisma.coursevideoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.coursevideoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coursevideoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.coursevideoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coursevideoPayload>
          }
          findFirst: {
            args: Prisma.coursevideoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coursevideoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.coursevideoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coursevideoPayload>
          }
          findMany: {
            args: Prisma.coursevideoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coursevideoPayload>[]
          }
          create: {
            args: Prisma.coursevideoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coursevideoPayload>
          }
          createMany: {
            args: Prisma.coursevideoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.coursevideoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coursevideoPayload>
          }
          update: {
            args: Prisma.coursevideoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coursevideoPayload>
          }
          deleteMany: {
            args: Prisma.coursevideoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.coursevideoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.coursevideoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coursevideoPayload>
          }
          aggregate: {
            args: Prisma.CoursevideoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCoursevideo>
          }
          groupBy: {
            args: Prisma.coursevideoGroupByArgs<ExtArgs>
            result: $Utils.Optional<CoursevideoGroupByOutputType>[]
          }
          count: {
            args: Prisma.coursevideoCountArgs<ExtArgs>
            result: $Utils.Optional<CoursevideoCountAggregateOutputType> | number
          }
        }
      }
      cvreview: {
        payload: Prisma.$cvreviewPayload<ExtArgs>
        fields: Prisma.cvreviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.cvreviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cvreviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cvreviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cvreviewPayload>
          }
          findFirst: {
            args: Prisma.cvreviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cvreviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cvreviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cvreviewPayload>
          }
          findMany: {
            args: Prisma.cvreviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cvreviewPayload>[]
          }
          create: {
            args: Prisma.cvreviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cvreviewPayload>
          }
          createMany: {
            args: Prisma.cvreviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.cvreviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cvreviewPayload>
          }
          update: {
            args: Prisma.cvreviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cvreviewPayload>
          }
          deleteMany: {
            args: Prisma.cvreviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.cvreviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.cvreviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cvreviewPayload>
          }
          aggregate: {
            args: Prisma.CvreviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCvreview>
          }
          groupBy: {
            args: Prisma.cvreviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<CvreviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.cvreviewCountArgs<ExtArgs>
            result: $Utils.Optional<CvreviewCountAggregateOutputType> | number
          }
        }
      }
      enrollment: {
        payload: Prisma.$enrollmentPayload<ExtArgs>
        fields: Prisma.enrollmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.enrollmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enrollmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.enrollmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enrollmentPayload>
          }
          findFirst: {
            args: Prisma.enrollmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enrollmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.enrollmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enrollmentPayload>
          }
          findMany: {
            args: Prisma.enrollmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enrollmentPayload>[]
          }
          create: {
            args: Prisma.enrollmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enrollmentPayload>
          }
          createMany: {
            args: Prisma.enrollmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.enrollmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enrollmentPayload>
          }
          update: {
            args: Prisma.enrollmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enrollmentPayload>
          }
          deleteMany: {
            args: Prisma.enrollmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.enrollmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.enrollmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enrollmentPayload>
          }
          aggregate: {
            args: Prisma.EnrollmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEnrollment>
          }
          groupBy: {
            args: Prisma.enrollmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<EnrollmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.enrollmentCountArgs<ExtArgs>
            result: $Utils.Optional<EnrollmentCountAggregateOutputType> | number
          }
        }
      }
      jobmatch: {
        payload: Prisma.$jobmatchPayload<ExtArgs>
        fields: Prisma.jobmatchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.jobmatchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobmatchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.jobmatchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobmatchPayload>
          }
          findFirst: {
            args: Prisma.jobmatchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobmatchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.jobmatchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobmatchPayload>
          }
          findMany: {
            args: Prisma.jobmatchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobmatchPayload>[]
          }
          create: {
            args: Prisma.jobmatchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobmatchPayload>
          }
          createMany: {
            args: Prisma.jobmatchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.jobmatchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobmatchPayload>
          }
          update: {
            args: Prisma.jobmatchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobmatchPayload>
          }
          deleteMany: {
            args: Prisma.jobmatchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.jobmatchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.jobmatchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobmatchPayload>
          }
          aggregate: {
            args: Prisma.JobmatchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobmatch>
          }
          groupBy: {
            args: Prisma.jobmatchGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobmatchGroupByOutputType>[]
          }
          count: {
            args: Prisma.jobmatchCountArgs<ExtArgs>
            result: $Utils.Optional<JobmatchCountAggregateOutputType> | number
          }
        }
      }
      lesson: {
        payload: Prisma.$lessonPayload<ExtArgs>
        fields: Prisma.lessonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.lessonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lessonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.lessonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lessonPayload>
          }
          findFirst: {
            args: Prisma.lessonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lessonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.lessonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lessonPayload>
          }
          findMany: {
            args: Prisma.lessonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lessonPayload>[]
          }
          create: {
            args: Prisma.lessonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lessonPayload>
          }
          createMany: {
            args: Prisma.lessonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.lessonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lessonPayload>
          }
          update: {
            args: Prisma.lessonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lessonPayload>
          }
          deleteMany: {
            args: Prisma.lessonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.lessonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.lessonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lessonPayload>
          }
          aggregate: {
            args: Prisma.LessonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLesson>
          }
          groupBy: {
            args: Prisma.lessonGroupByArgs<ExtArgs>
            result: $Utils.Optional<LessonGroupByOutputType>[]
          }
          count: {
            args: Prisma.lessonCountArgs<ExtArgs>
            result: $Utils.Optional<LessonCountAggregateOutputType> | number
          }
        }
      }
      lessonprogress: {
        payload: Prisma.$lessonprogressPayload<ExtArgs>
        fields: Prisma.lessonprogressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.lessonprogressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lessonprogressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.lessonprogressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lessonprogressPayload>
          }
          findFirst: {
            args: Prisma.lessonprogressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lessonprogressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.lessonprogressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lessonprogressPayload>
          }
          findMany: {
            args: Prisma.lessonprogressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lessonprogressPayload>[]
          }
          create: {
            args: Prisma.lessonprogressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lessonprogressPayload>
          }
          createMany: {
            args: Prisma.lessonprogressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.lessonprogressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lessonprogressPayload>
          }
          update: {
            args: Prisma.lessonprogressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lessonprogressPayload>
          }
          deleteMany: {
            args: Prisma.lessonprogressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.lessonprogressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.lessonprogressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lessonprogressPayload>
          }
          aggregate: {
            args: Prisma.LessonprogressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLessonprogress>
          }
          groupBy: {
            args: Prisma.lessonprogressGroupByArgs<ExtArgs>
            result: $Utils.Optional<LessonprogressGroupByOutputType>[]
          }
          count: {
            args: Prisma.lessonprogressCountArgs<ExtArgs>
            result: $Utils.Optional<LessonprogressCountAggregateOutputType> | number
          }
        }
      }
      notification: {
        payload: Prisma.$notificationPayload<ExtArgs>
        fields: Prisma.notificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.notificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.notificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          findFirst: {
            args: Prisma.notificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.notificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          findMany: {
            args: Prisma.notificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>[]
          }
          create: {
            args: Prisma.notificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          createMany: {
            args: Prisma.notificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.notificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          update: {
            args: Prisma.notificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          deleteMany: {
            args: Prisma.notificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.notificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.notificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.notificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.notificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      payment: {
        payload: Prisma.$paymentPayload<ExtArgs>
        fields: Prisma.paymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.paymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.paymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>
          }
          findFirst: {
            args: Prisma.paymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.paymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>
          }
          findMany: {
            args: Prisma.paymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>[]
          }
          create: {
            args: Prisma.paymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>
          }
          createMany: {
            args: Prisma.paymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.paymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>
          }
          update: {
            args: Prisma.paymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>
          }
          deleteMany: {
            args: Prisma.paymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.paymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.paymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.paymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.paymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      quiz: {
        payload: Prisma.$quizPayload<ExtArgs>
        fields: Prisma.quizFieldRefs
        operations: {
          findUnique: {
            args: Prisma.quizFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quizPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.quizFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quizPayload>
          }
          findFirst: {
            args: Prisma.quizFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quizPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.quizFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quizPayload>
          }
          findMany: {
            args: Prisma.quizFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quizPayload>[]
          }
          create: {
            args: Prisma.quizCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quizPayload>
          }
          createMany: {
            args: Prisma.quizCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.quizDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quizPayload>
          }
          update: {
            args: Prisma.quizUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quizPayload>
          }
          deleteMany: {
            args: Prisma.quizDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.quizUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.quizUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quizPayload>
          }
          aggregate: {
            args: Prisma.QuizAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuiz>
          }
          groupBy: {
            args: Prisma.quizGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizGroupByOutputType>[]
          }
          count: {
            args: Prisma.quizCountArgs<ExtArgs>
            result: $Utils.Optional<QuizCountAggregateOutputType> | number
          }
        }
      }
      quizsubmission: {
        payload: Prisma.$quizsubmissionPayload<ExtArgs>
        fields: Prisma.quizsubmissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.quizsubmissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quizsubmissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.quizsubmissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quizsubmissionPayload>
          }
          findFirst: {
            args: Prisma.quizsubmissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quizsubmissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.quizsubmissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quizsubmissionPayload>
          }
          findMany: {
            args: Prisma.quizsubmissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quizsubmissionPayload>[]
          }
          create: {
            args: Prisma.quizsubmissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quizsubmissionPayload>
          }
          createMany: {
            args: Prisma.quizsubmissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.quizsubmissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quizsubmissionPayload>
          }
          update: {
            args: Prisma.quizsubmissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quizsubmissionPayload>
          }
          deleteMany: {
            args: Prisma.quizsubmissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.quizsubmissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.quizsubmissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quizsubmissionPayload>
          }
          aggregate: {
            args: Prisma.QuizsubmissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuizsubmission>
          }
          groupBy: {
            args: Prisma.quizsubmissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizsubmissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.quizsubmissionCountArgs<ExtArgs>
            result: $Utils.Optional<QuizsubmissionCountAggregateOutputType> | number
          }
        }
      }
      roadmap: {
        payload: Prisma.$roadmapPayload<ExtArgs>
        fields: Prisma.roadmapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.roadmapFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roadmapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.roadmapFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roadmapPayload>
          }
          findFirst: {
            args: Prisma.roadmapFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roadmapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.roadmapFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roadmapPayload>
          }
          findMany: {
            args: Prisma.roadmapFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roadmapPayload>[]
          }
          create: {
            args: Prisma.roadmapCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roadmapPayload>
          }
          createMany: {
            args: Prisma.roadmapCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.roadmapDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roadmapPayload>
          }
          update: {
            args: Prisma.roadmapUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roadmapPayload>
          }
          deleteMany: {
            args: Prisma.roadmapDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.roadmapUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.roadmapUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roadmapPayload>
          }
          aggregate: {
            args: Prisma.RoadmapAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoadmap>
          }
          groupBy: {
            args: Prisma.roadmapGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoadmapGroupByOutputType>[]
          }
          count: {
            args: Prisma.roadmapCountArgs<ExtArgs>
            result: $Utils.Optional<RoadmapCountAggregateOutputType> | number
          }
        }
      }
      roadmapcourse: {
        payload: Prisma.$roadmapcoursePayload<ExtArgs>
        fields: Prisma.roadmapcourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.roadmapcourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roadmapcoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.roadmapcourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roadmapcoursePayload>
          }
          findFirst: {
            args: Prisma.roadmapcourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roadmapcoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.roadmapcourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roadmapcoursePayload>
          }
          findMany: {
            args: Prisma.roadmapcourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roadmapcoursePayload>[]
          }
          create: {
            args: Prisma.roadmapcourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roadmapcoursePayload>
          }
          createMany: {
            args: Prisma.roadmapcourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.roadmapcourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roadmapcoursePayload>
          }
          update: {
            args: Prisma.roadmapcourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roadmapcoursePayload>
          }
          deleteMany: {
            args: Prisma.roadmapcourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.roadmapcourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.roadmapcourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roadmapcoursePayload>
          }
          aggregate: {
            args: Prisma.RoadmapcourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoadmapcourse>
          }
          groupBy: {
            args: Prisma.roadmapcourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoadmapcourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.roadmapcourseCountArgs<ExtArgs>
            result: $Utils.Optional<RoadmapcourseCountAggregateOutputType> | number
          }
        }
      }
      userroadmap: {
        payload: Prisma.$userroadmapPayload<ExtArgs>
        fields: Prisma.userroadmapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userroadmapFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userroadmapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userroadmapFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userroadmapPayload>
          }
          findFirst: {
            args: Prisma.userroadmapFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userroadmapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userroadmapFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userroadmapPayload>
          }
          findMany: {
            args: Prisma.userroadmapFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userroadmapPayload>[]
          }
          create: {
            args: Prisma.userroadmapCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userroadmapPayload>
          }
          createMany: {
            args: Prisma.userroadmapCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.userroadmapDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userroadmapPayload>
          }
          update: {
            args: Prisma.userroadmapUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userroadmapPayload>
          }
          deleteMany: {
            args: Prisma.userroadmapDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userroadmapUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.userroadmapUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userroadmapPayload>
          }
          aggregate: {
            args: Prisma.UserroadmapAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserroadmap>
          }
          groupBy: {
            args: Prisma.userroadmapGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserroadmapGroupByOutputType>[]
          }
          count: {
            args: Prisma.userroadmapCountArgs<ExtArgs>
            result: $Utils.Optional<UserroadmapCountAggregateOutputType> | number
          }
        }
      }
      Voucher: {
        payload: Prisma.$VoucherPayload<ExtArgs>
        fields: Prisma.VoucherFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VoucherFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VoucherFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          findFirst: {
            args: Prisma.VoucherFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VoucherFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          findMany: {
            args: Prisma.VoucherFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>[]
          }
          create: {
            args: Prisma.VoucherCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          createMany: {
            args: Prisma.VoucherCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VoucherDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          update: {
            args: Prisma.VoucherUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          deleteMany: {
            args: Prisma.VoucherDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VoucherUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VoucherUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          aggregate: {
            args: Prisma.VoucherAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVoucher>
          }
          groupBy: {
            args: Prisma.VoucherGroupByArgs<ExtArgs>
            result: $Utils.Optional<VoucherGroupByOutputType>[]
          }
          count: {
            args: Prisma.VoucherCountArgs<ExtArgs>
            result: $Utils.Optional<VoucherCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    roadmapMatcher?: RoadmapMatcherOmit
    assessment?: assessmentOmit
    bookmarkCourse?: BookmarkCourseOmit
    category?: categoryOmit
    certificate?: certificateOmit
    chatmessage?: chatmessageOmit
    counselingsession?: counselingsessionOmit
    counselor?: counselorOmit
    course?: courseOmit
    courseprogress?: courseprogressOmit
    coursevideo?: coursevideoOmit
    cvreview?: cvreviewOmit
    enrollment?: enrollmentOmit
    jobmatch?: jobmatchOmit
    lesson?: lessonOmit
    lessonprogress?: lessonprogressOmit
    notification?: notificationOmit
    payment?: paymentOmit
    quiz?: quizOmit
    quizsubmission?: quizsubmissionOmit
    roadmap?: roadmapOmit
    roadmapcourse?: roadmapcourseOmit
    userroadmap?: userroadmapOmit
    voucher?: VoucherOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    assessment: number
    certificate: number
    chatmessage: number
    counselingsession: number
    course: number
    courseprogress: number
    cvreview: number
    enrollment: number
    jobmatch: number
    lessonprogress: number
    notification: number
    payment: number
    quizsubmission: number
    userroadmap: number
    voucher: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assessment?: boolean | UserCountOutputTypeCountAssessmentArgs
    certificate?: boolean | UserCountOutputTypeCountCertificateArgs
    chatmessage?: boolean | UserCountOutputTypeCountChatmessageArgs
    counselingsession?: boolean | UserCountOutputTypeCountCounselingsessionArgs
    course?: boolean | UserCountOutputTypeCountCourseArgs
    courseprogress?: boolean | UserCountOutputTypeCountCourseprogressArgs
    cvreview?: boolean | UserCountOutputTypeCountCvreviewArgs
    enrollment?: boolean | UserCountOutputTypeCountEnrollmentArgs
    jobmatch?: boolean | UserCountOutputTypeCountJobmatchArgs
    lessonprogress?: boolean | UserCountOutputTypeCountLessonprogressArgs
    notification?: boolean | UserCountOutputTypeCountNotificationArgs
    payment?: boolean | UserCountOutputTypeCountPaymentArgs
    quizsubmission?: boolean | UserCountOutputTypeCountQuizsubmissionArgs
    userroadmap?: boolean | UserCountOutputTypeCountUserroadmapArgs
    voucher?: boolean | UserCountOutputTypeCountVoucherArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssessmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: assessmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCertificateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: certificateWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChatmessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chatmessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCounselingsessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: counselingsessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: courseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCourseprogressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: courseprogressWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCvreviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cvreviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEnrollmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: enrollmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountJobmatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: jobmatchWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLessonprogressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: lessonprogressWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountQuizsubmissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: quizsubmissionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserroadmapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userroadmapWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVoucherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoucherWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    course: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CategoryCountOutputTypeCountCourseArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountCourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: courseWhereInput
  }


  /**
   * Count Type CounselingsessionCountOutputType
   */

  export type CounselingsessionCountOutputType = {
    chatmessage: number
  }

  export type CounselingsessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chatmessage?: boolean | CounselingsessionCountOutputTypeCountChatmessageArgs
  }

  // Custom InputTypes
  /**
   * CounselingsessionCountOutputType without action
   */
  export type CounselingsessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CounselingsessionCountOutputType
     */
    select?: CounselingsessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CounselingsessionCountOutputType without action
   */
  export type CounselingsessionCountOutputTypeCountChatmessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chatmessageWhereInput
  }


  /**
   * Count Type CounselorCountOutputType
   */

  export type CounselorCountOutputType = {
    counselingsession: number
  }

  export type CounselorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    counselingsession?: boolean | CounselorCountOutputTypeCountCounselingsessionArgs
  }

  // Custom InputTypes
  /**
   * CounselorCountOutputType without action
   */
  export type CounselorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CounselorCountOutputType
     */
    select?: CounselorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CounselorCountOutputType without action
   */
  export type CounselorCountOutputTypeCountCounselingsessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: counselingsessionWhereInput
  }


  /**
   * Count Type CourseCountOutputType
   */

  export type CourseCountOutputType = {
    certificate: number
    courseprogress: number
    coursevideo: number
    enrollment: number
    lesson: number
    payment: number
    quiz: number
    quizsubmission: number
    roadmapcourse: number
  }

  export type CourseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    certificate?: boolean | CourseCountOutputTypeCountCertificateArgs
    courseprogress?: boolean | CourseCountOutputTypeCountCourseprogressArgs
    coursevideo?: boolean | CourseCountOutputTypeCountCoursevideoArgs
    enrollment?: boolean | CourseCountOutputTypeCountEnrollmentArgs
    lesson?: boolean | CourseCountOutputTypeCountLessonArgs
    payment?: boolean | CourseCountOutputTypeCountPaymentArgs
    quiz?: boolean | CourseCountOutputTypeCountQuizArgs
    quizsubmission?: boolean | CourseCountOutputTypeCountQuizsubmissionArgs
    roadmapcourse?: boolean | CourseCountOutputTypeCountRoadmapcourseArgs
  }

  // Custom InputTypes
  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCountOutputType
     */
    select?: CourseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountCertificateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: certificateWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountCourseprogressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: courseprogressWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountCoursevideoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: coursevideoWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountEnrollmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: enrollmentWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountLessonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: lessonWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountQuizArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: quizWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountQuizsubmissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: quizsubmissionWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountRoadmapcourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: roadmapcourseWhereInput
  }


  /**
   * Count Type LessonCountOutputType
   */

  export type LessonCountOutputType = {
    lessonprogress: number
  }

  export type LessonCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lessonprogress?: boolean | LessonCountOutputTypeCountLessonprogressArgs
  }

  // Custom InputTypes
  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonCountOutputType
     */
    select?: LessonCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeCountLessonprogressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: lessonprogressWhereInput
  }


  /**
   * Count Type PaymentCountOutputType
   */

  export type PaymentCountOutputType = {
    enrollment: number
  }

  export type PaymentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enrollment?: boolean | PaymentCountOutputTypeCountEnrollmentArgs
  }

  // Custom InputTypes
  /**
   * PaymentCountOutputType without action
   */
  export type PaymentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentCountOutputType
     */
    select?: PaymentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaymentCountOutputType without action
   */
  export type PaymentCountOutputTypeCountEnrollmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: enrollmentWhereInput
  }


  /**
   * Count Type QuizCountOutputType
   */

  export type QuizCountOutputType = {
    quizsubmission: number
  }

  export type QuizCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quizsubmission?: boolean | QuizCountOutputTypeCountQuizsubmissionArgs
  }

  // Custom InputTypes
  /**
   * QuizCountOutputType without action
   */
  export type QuizCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizCountOutputType
     */
    select?: QuizCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuizCountOutputType without action
   */
  export type QuizCountOutputTypeCountQuizsubmissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: quizsubmissionWhereInput
  }


  /**
   * Count Type RoadmapCountOutputType
   */

  export type RoadmapCountOutputType = {
    payment: number
    roadmapcourse: number
    userroadmap: number
  }

  export type RoadmapCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | RoadmapCountOutputTypeCountPaymentArgs
    roadmapcourse?: boolean | RoadmapCountOutputTypeCountRoadmapcourseArgs
    userroadmap?: boolean | RoadmapCountOutputTypeCountUserroadmapArgs
  }

  // Custom InputTypes
  /**
   * RoadmapCountOutputType without action
   */
  export type RoadmapCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapCountOutputType
     */
    select?: RoadmapCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoadmapCountOutputType without action
   */
  export type RoadmapCountOutputTypeCountPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentWhereInput
  }

  /**
   * RoadmapCountOutputType without action
   */
  export type RoadmapCountOutputTypeCountRoadmapcourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: roadmapcourseWhereInput
  }

  /**
   * RoadmapCountOutputType without action
   */
  export type RoadmapCountOutputTypeCountUserroadmapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userroadmapWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    firstName: string | null
    lastName: string | null
    email: string | null
    password: string | null
    address: string | null
    gender: string | null
    birthDate: Date | null
    role: $Enums.Role | null
    profilePicture: string | null
    createdAt: Date | null
    resetToken: string | null
    resetTokenExpiry: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    firstName: string | null
    lastName: string | null
    email: string | null
    password: string | null
    address: string | null
    gender: string | null
    birthDate: Date | null
    role: $Enums.Role | null
    profilePicture: string | null
    createdAt: Date | null
    resetToken: string | null
    resetTokenExpiry: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    email: number
    password: number
    address: number
    gender: number
    birthDate: number
    role: number
    profilePicture: number
    createdAt: number
    resetToken: number
    resetTokenExpiry: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    password?: true
    address?: true
    gender?: true
    birthDate?: true
    role?: true
    profilePicture?: true
    createdAt?: true
    resetToken?: true
    resetTokenExpiry?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    password?: true
    address?: true
    gender?: true
    birthDate?: true
    role?: true
    profilePicture?: true
    createdAt?: true
    resetToken?: true
    resetTokenExpiry?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    password?: true
    address?: true
    gender?: true
    birthDate?: true
    role?: true
    profilePicture?: true
    createdAt?: true
    resetToken?: true
    resetTokenExpiry?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    firstName: string | null
    lastName: string | null
    email: string
    password: string
    address: string | null
    gender: string | null
    birthDate: Date | null
    role: $Enums.Role
    profilePicture: string | null
    createdAt: Date
    resetToken: string | null
    resetTokenExpiry: Date | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    password?: boolean
    address?: boolean
    gender?: boolean
    birthDate?: boolean
    role?: boolean
    profilePicture?: boolean
    createdAt?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    assessment?: boolean | User$assessmentArgs<ExtArgs>
    certificate?: boolean | User$certificateArgs<ExtArgs>
    chatmessage?: boolean | User$chatmessageArgs<ExtArgs>
    counselingsession?: boolean | User$counselingsessionArgs<ExtArgs>
    counselor?: boolean | User$counselorArgs<ExtArgs>
    course?: boolean | User$courseArgs<ExtArgs>
    courseprogress?: boolean | User$courseprogressArgs<ExtArgs>
    cvreview?: boolean | User$cvreviewArgs<ExtArgs>
    enrollment?: boolean | User$enrollmentArgs<ExtArgs>
    jobmatch?: boolean | User$jobmatchArgs<ExtArgs>
    lessonprogress?: boolean | User$lessonprogressArgs<ExtArgs>
    notification?: boolean | User$notificationArgs<ExtArgs>
    payment?: boolean | User$paymentArgs<ExtArgs>
    quizsubmission?: boolean | User$quizsubmissionArgs<ExtArgs>
    userroadmap?: boolean | User$userroadmapArgs<ExtArgs>
    voucher?: boolean | User$voucherArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    password?: boolean
    address?: boolean
    gender?: boolean
    birthDate?: boolean
    role?: boolean
    profilePicture?: boolean
    createdAt?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "firstName" | "lastName" | "email" | "password" | "address" | "gender" | "birthDate" | "role" | "profilePicture" | "createdAt" | "resetToken" | "resetTokenExpiry", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assessment?: boolean | User$assessmentArgs<ExtArgs>
    certificate?: boolean | User$certificateArgs<ExtArgs>
    chatmessage?: boolean | User$chatmessageArgs<ExtArgs>
    counselingsession?: boolean | User$counselingsessionArgs<ExtArgs>
    counselor?: boolean | User$counselorArgs<ExtArgs>
    course?: boolean | User$courseArgs<ExtArgs>
    courseprogress?: boolean | User$courseprogressArgs<ExtArgs>
    cvreview?: boolean | User$cvreviewArgs<ExtArgs>
    enrollment?: boolean | User$enrollmentArgs<ExtArgs>
    jobmatch?: boolean | User$jobmatchArgs<ExtArgs>
    lessonprogress?: boolean | User$lessonprogressArgs<ExtArgs>
    notification?: boolean | User$notificationArgs<ExtArgs>
    payment?: boolean | User$paymentArgs<ExtArgs>
    quizsubmission?: boolean | User$quizsubmissionArgs<ExtArgs>
    userroadmap?: boolean | User$userroadmapArgs<ExtArgs>
    voucher?: boolean | User$voucherArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      assessment: Prisma.$assessmentPayload<ExtArgs>[]
      certificate: Prisma.$certificatePayload<ExtArgs>[]
      chatmessage: Prisma.$chatmessagePayload<ExtArgs>[]
      counselingsession: Prisma.$counselingsessionPayload<ExtArgs>[]
      counselor: Prisma.$counselorPayload<ExtArgs> | null
      course: Prisma.$coursePayload<ExtArgs>[]
      courseprogress: Prisma.$courseprogressPayload<ExtArgs>[]
      cvreview: Prisma.$cvreviewPayload<ExtArgs>[]
      enrollment: Prisma.$enrollmentPayload<ExtArgs>[]
      jobmatch: Prisma.$jobmatchPayload<ExtArgs>[]
      lessonprogress: Prisma.$lessonprogressPayload<ExtArgs>[]
      notification: Prisma.$notificationPayload<ExtArgs>[]
      payment: Prisma.$paymentPayload<ExtArgs>[]
      quizsubmission: Prisma.$quizsubmissionPayload<ExtArgs>[]
      userroadmap: Prisma.$userroadmapPayload<ExtArgs>[]
      voucher: Prisma.$VoucherPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      firstName: string | null
      lastName: string | null
      email: string
      password: string
      address: string | null
      gender: string | null
      birthDate: Date | null
      role: $Enums.Role
      profilePicture: string | null
      createdAt: Date
      resetToken: string | null
      resetTokenExpiry: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assessment<T extends User$assessmentArgs<ExtArgs> = {}>(args?: Subset<T, User$assessmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$assessmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    certificate<T extends User$certificateArgs<ExtArgs> = {}>(args?: Subset<T, User$certificateArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$certificatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chatmessage<T extends User$chatmessageArgs<ExtArgs> = {}>(args?: Subset<T, User$chatmessageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatmessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    counselingsession<T extends User$counselingsessionArgs<ExtArgs> = {}>(args?: Subset<T, User$counselingsessionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$counselingsessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    counselor<T extends User$counselorArgs<ExtArgs> = {}>(args?: Subset<T, User$counselorArgs<ExtArgs>>): Prisma__counselorClient<$Result.GetResult<Prisma.$counselorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    course<T extends User$courseArgs<ExtArgs> = {}>(args?: Subset<T, User$courseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$coursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    courseprogress<T extends User$courseprogressArgs<ExtArgs> = {}>(args?: Subset<T, User$courseprogressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$courseprogressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cvreview<T extends User$cvreviewArgs<ExtArgs> = {}>(args?: Subset<T, User$cvreviewArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cvreviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    enrollment<T extends User$enrollmentArgs<ExtArgs> = {}>(args?: Subset<T, User$enrollmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$enrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    jobmatch<T extends User$jobmatchArgs<ExtArgs> = {}>(args?: Subset<T, User$jobmatchArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$jobmatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lessonprogress<T extends User$lessonprogressArgs<ExtArgs> = {}>(args?: Subset<T, User$lessonprogressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lessonprogressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notification<T extends User$notificationArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payment<T extends User$paymentArgs<ExtArgs> = {}>(args?: Subset<T, User$paymentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quizsubmission<T extends User$quizsubmissionArgs<ExtArgs> = {}>(args?: Subset<T, User$quizsubmissionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$quizsubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userroadmap<T extends User$userroadmapArgs<ExtArgs> = {}>(args?: Subset<T, User$userroadmapArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userroadmapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    voucher<T extends User$voucherArgs<ExtArgs> = {}>(args?: Subset<T, User$voucherArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly address: FieldRef<"User", 'String'>
    readonly gender: FieldRef<"User", 'String'>
    readonly birthDate: FieldRef<"User", 'DateTime'>
    readonly role: FieldRef<"User", 'Role'>
    readonly profilePicture: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly resetToken: FieldRef<"User", 'String'>
    readonly resetTokenExpiry: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.assessment
   */
  export type User$assessmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assessment
     */
    select?: assessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assessment
     */
    omit?: assessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assessmentInclude<ExtArgs> | null
    where?: assessmentWhereInput
    orderBy?: assessmentOrderByWithRelationInput | assessmentOrderByWithRelationInput[]
    cursor?: assessmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssessmentScalarFieldEnum | AssessmentScalarFieldEnum[]
  }

  /**
   * User.certificate
   */
  export type User$certificateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificate
     */
    select?: certificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificate
     */
    omit?: certificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificateInclude<ExtArgs> | null
    where?: certificateWhereInput
    orderBy?: certificateOrderByWithRelationInput | certificateOrderByWithRelationInput[]
    cursor?: certificateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * User.chatmessage
   */
  export type User$chatmessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatmessage
     */
    select?: chatmessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatmessage
     */
    omit?: chatmessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatmessageInclude<ExtArgs> | null
    where?: chatmessageWhereInput
    orderBy?: chatmessageOrderByWithRelationInput | chatmessageOrderByWithRelationInput[]
    cursor?: chatmessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatmessageScalarFieldEnum | ChatmessageScalarFieldEnum[]
  }

  /**
   * User.counselingsession
   */
  export type User$counselingsessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counselingsession
     */
    select?: counselingsessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the counselingsession
     */
    omit?: counselingsessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: counselingsessionInclude<ExtArgs> | null
    where?: counselingsessionWhereInput
    orderBy?: counselingsessionOrderByWithRelationInput | counselingsessionOrderByWithRelationInput[]
    cursor?: counselingsessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CounselingsessionScalarFieldEnum | CounselingsessionScalarFieldEnum[]
  }

  /**
   * User.counselor
   */
  export type User$counselorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counselor
     */
    select?: counselorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the counselor
     */
    omit?: counselorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: counselorInclude<ExtArgs> | null
    where?: counselorWhereInput
  }

  /**
   * User.course
   */
  export type User$courseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course
     */
    select?: courseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course
     */
    omit?: courseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: courseInclude<ExtArgs> | null
    where?: courseWhereInput
    orderBy?: courseOrderByWithRelationInput | courseOrderByWithRelationInput[]
    cursor?: courseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * User.courseprogress
   */
  export type User$courseprogressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courseprogress
     */
    select?: courseprogressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the courseprogress
     */
    omit?: courseprogressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: courseprogressInclude<ExtArgs> | null
    where?: courseprogressWhereInput
    orderBy?: courseprogressOrderByWithRelationInput | courseprogressOrderByWithRelationInput[]
    cursor?: courseprogressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseprogressScalarFieldEnum | CourseprogressScalarFieldEnum[]
  }

  /**
   * User.cvreview
   */
  export type User$cvreviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cvreview
     */
    select?: cvreviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cvreview
     */
    omit?: cvreviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cvreviewInclude<ExtArgs> | null
    where?: cvreviewWhereInput
    orderBy?: cvreviewOrderByWithRelationInput | cvreviewOrderByWithRelationInput[]
    cursor?: cvreviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CvreviewScalarFieldEnum | CvreviewScalarFieldEnum[]
  }

  /**
   * User.enrollment
   */
  export type User$enrollmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollment
     */
    select?: enrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrollment
     */
    omit?: enrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentInclude<ExtArgs> | null
    where?: enrollmentWhereInput
    orderBy?: enrollmentOrderByWithRelationInput | enrollmentOrderByWithRelationInput[]
    cursor?: enrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * User.jobmatch
   */
  export type User$jobmatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobmatch
     */
    select?: jobmatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobmatch
     */
    omit?: jobmatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobmatchInclude<ExtArgs> | null
    where?: jobmatchWhereInput
    orderBy?: jobmatchOrderByWithRelationInput | jobmatchOrderByWithRelationInput[]
    cursor?: jobmatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobmatchScalarFieldEnum | JobmatchScalarFieldEnum[]
  }

  /**
   * User.lessonprogress
   */
  export type User$lessonprogressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lessonprogress
     */
    select?: lessonprogressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lessonprogress
     */
    omit?: lessonprogressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lessonprogressInclude<ExtArgs> | null
    where?: lessonprogressWhereInput
    orderBy?: lessonprogressOrderByWithRelationInput | lessonprogressOrderByWithRelationInput[]
    cursor?: lessonprogressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonprogressScalarFieldEnum | LessonprogressScalarFieldEnum[]
  }

  /**
   * User.notification
   */
  export type User$notificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    where?: notificationWhereInput
    orderBy?: notificationOrderByWithRelationInput | notificationOrderByWithRelationInput[]
    cursor?: notificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.payment
   */
  export type User$paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    where?: paymentWhereInput
    orderBy?: paymentOrderByWithRelationInput | paymentOrderByWithRelationInput[]
    cursor?: paymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * User.quizsubmission
   */
  export type User$quizsubmissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quizsubmission
     */
    select?: quizsubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quizsubmission
     */
    omit?: quizsubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quizsubmissionInclude<ExtArgs> | null
    where?: quizsubmissionWhereInput
    orderBy?: quizsubmissionOrderByWithRelationInput | quizsubmissionOrderByWithRelationInput[]
    cursor?: quizsubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizsubmissionScalarFieldEnum | QuizsubmissionScalarFieldEnum[]
  }

  /**
   * User.userroadmap
   */
  export type User$userroadmapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userroadmap
     */
    select?: userroadmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userroadmap
     */
    omit?: userroadmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroadmapInclude<ExtArgs> | null
    where?: userroadmapWhereInput
    orderBy?: userroadmapOrderByWithRelationInput | userroadmapOrderByWithRelationInput[]
    cursor?: userroadmapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserroadmapScalarFieldEnum | UserroadmapScalarFieldEnum[]
  }

  /**
   * User.voucher
   */
  export type User$voucherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    where?: VoucherWhereInput
    orderBy?: VoucherOrderByWithRelationInput | VoucherOrderByWithRelationInput[]
    cursor?: VoucherWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VoucherScalarFieldEnum | VoucherScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model RoadmapMatcher
   */

  export type AggregateRoadmapMatcher = {
    _count: RoadmapMatcherCountAggregateOutputType | null
    _avg: RoadmapMatcherAvgAggregateOutputType | null
    _sum: RoadmapMatcherSumAggregateOutputType | null
    _min: RoadmapMatcherMinAggregateOutputType | null
    _max: RoadmapMatcherMaxAggregateOutputType | null
  }

  export type RoadmapMatcherAvgAggregateOutputType = {
    id: number | null
    roadmapId: number | null
  }

  export type RoadmapMatcherSumAggregateOutputType = {
    id: number | null
    roadmapId: number | null
  }

  export type RoadmapMatcherMinAggregateOutputType = {
    id: number | null
    keyword: string | null
    roadmapId: number | null
    matchField: string | null
  }

  export type RoadmapMatcherMaxAggregateOutputType = {
    id: number | null
    keyword: string | null
    roadmapId: number | null
    matchField: string | null
  }

  export type RoadmapMatcherCountAggregateOutputType = {
    id: number
    keyword: number
    roadmapId: number
    matchField: number
    _all: number
  }


  export type RoadmapMatcherAvgAggregateInputType = {
    id?: true
    roadmapId?: true
  }

  export type RoadmapMatcherSumAggregateInputType = {
    id?: true
    roadmapId?: true
  }

  export type RoadmapMatcherMinAggregateInputType = {
    id?: true
    keyword?: true
    roadmapId?: true
    matchField?: true
  }

  export type RoadmapMatcherMaxAggregateInputType = {
    id?: true
    keyword?: true
    roadmapId?: true
    matchField?: true
  }

  export type RoadmapMatcherCountAggregateInputType = {
    id?: true
    keyword?: true
    roadmapId?: true
    matchField?: true
    _all?: true
  }

  export type RoadmapMatcherAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoadmapMatcher to aggregate.
     */
    where?: RoadmapMatcherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoadmapMatchers to fetch.
     */
    orderBy?: RoadmapMatcherOrderByWithRelationInput | RoadmapMatcherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoadmapMatcherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoadmapMatchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoadmapMatchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoadmapMatchers
    **/
    _count?: true | RoadmapMatcherCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoadmapMatcherAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoadmapMatcherSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoadmapMatcherMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoadmapMatcherMaxAggregateInputType
  }

  export type GetRoadmapMatcherAggregateType<T extends RoadmapMatcherAggregateArgs> = {
        [P in keyof T & keyof AggregateRoadmapMatcher]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoadmapMatcher[P]>
      : GetScalarType<T[P], AggregateRoadmapMatcher[P]>
  }




  export type RoadmapMatcherGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoadmapMatcherWhereInput
    orderBy?: RoadmapMatcherOrderByWithAggregationInput | RoadmapMatcherOrderByWithAggregationInput[]
    by: RoadmapMatcherScalarFieldEnum[] | RoadmapMatcherScalarFieldEnum
    having?: RoadmapMatcherScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoadmapMatcherCountAggregateInputType | true
    _avg?: RoadmapMatcherAvgAggregateInputType
    _sum?: RoadmapMatcherSumAggregateInputType
    _min?: RoadmapMatcherMinAggregateInputType
    _max?: RoadmapMatcherMaxAggregateInputType
  }

  export type RoadmapMatcherGroupByOutputType = {
    id: number
    keyword: string
    roadmapId: number
    matchField: string
    _count: RoadmapMatcherCountAggregateOutputType | null
    _avg: RoadmapMatcherAvgAggregateOutputType | null
    _sum: RoadmapMatcherSumAggregateOutputType | null
    _min: RoadmapMatcherMinAggregateOutputType | null
    _max: RoadmapMatcherMaxAggregateOutputType | null
  }

  type GetRoadmapMatcherGroupByPayload<T extends RoadmapMatcherGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoadmapMatcherGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoadmapMatcherGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoadmapMatcherGroupByOutputType[P]>
            : GetScalarType<T[P], RoadmapMatcherGroupByOutputType[P]>
        }
      >
    >


  export type RoadmapMatcherSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    keyword?: boolean
    roadmapId?: boolean
    matchField?: boolean
  }, ExtArgs["result"]["roadmapMatcher"]>



  export type RoadmapMatcherSelectScalar = {
    id?: boolean
    keyword?: boolean
    roadmapId?: boolean
    matchField?: boolean
  }

  export type RoadmapMatcherOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "keyword" | "roadmapId" | "matchField", ExtArgs["result"]["roadmapMatcher"]>

  export type $RoadmapMatcherPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoadmapMatcher"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      keyword: string
      roadmapId: number
      matchField: string
    }, ExtArgs["result"]["roadmapMatcher"]>
    composites: {}
  }

  type RoadmapMatcherGetPayload<S extends boolean | null | undefined | RoadmapMatcherDefaultArgs> = $Result.GetResult<Prisma.$RoadmapMatcherPayload, S>

  type RoadmapMatcherCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoadmapMatcherFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoadmapMatcherCountAggregateInputType | true
    }

  export interface RoadmapMatcherDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoadmapMatcher'], meta: { name: 'RoadmapMatcher' } }
    /**
     * Find zero or one RoadmapMatcher that matches the filter.
     * @param {RoadmapMatcherFindUniqueArgs} args - Arguments to find a RoadmapMatcher
     * @example
     * // Get one RoadmapMatcher
     * const roadmapMatcher = await prisma.roadmapMatcher.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoadmapMatcherFindUniqueArgs>(args: SelectSubset<T, RoadmapMatcherFindUniqueArgs<ExtArgs>>): Prisma__RoadmapMatcherClient<$Result.GetResult<Prisma.$RoadmapMatcherPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RoadmapMatcher that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoadmapMatcherFindUniqueOrThrowArgs} args - Arguments to find a RoadmapMatcher
     * @example
     * // Get one RoadmapMatcher
     * const roadmapMatcher = await prisma.roadmapMatcher.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoadmapMatcherFindUniqueOrThrowArgs>(args: SelectSubset<T, RoadmapMatcherFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoadmapMatcherClient<$Result.GetResult<Prisma.$RoadmapMatcherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoadmapMatcher that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapMatcherFindFirstArgs} args - Arguments to find a RoadmapMatcher
     * @example
     * // Get one RoadmapMatcher
     * const roadmapMatcher = await prisma.roadmapMatcher.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoadmapMatcherFindFirstArgs>(args?: SelectSubset<T, RoadmapMatcherFindFirstArgs<ExtArgs>>): Prisma__RoadmapMatcherClient<$Result.GetResult<Prisma.$RoadmapMatcherPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoadmapMatcher that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapMatcherFindFirstOrThrowArgs} args - Arguments to find a RoadmapMatcher
     * @example
     * // Get one RoadmapMatcher
     * const roadmapMatcher = await prisma.roadmapMatcher.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoadmapMatcherFindFirstOrThrowArgs>(args?: SelectSubset<T, RoadmapMatcherFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoadmapMatcherClient<$Result.GetResult<Prisma.$RoadmapMatcherPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RoadmapMatchers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapMatcherFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoadmapMatchers
     * const roadmapMatchers = await prisma.roadmapMatcher.findMany()
     * 
     * // Get first 10 RoadmapMatchers
     * const roadmapMatchers = await prisma.roadmapMatcher.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roadmapMatcherWithIdOnly = await prisma.roadmapMatcher.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoadmapMatcherFindManyArgs>(args?: SelectSubset<T, RoadmapMatcherFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadmapMatcherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RoadmapMatcher.
     * @param {RoadmapMatcherCreateArgs} args - Arguments to create a RoadmapMatcher.
     * @example
     * // Create one RoadmapMatcher
     * const RoadmapMatcher = await prisma.roadmapMatcher.create({
     *   data: {
     *     // ... data to create a RoadmapMatcher
     *   }
     * })
     * 
     */
    create<T extends RoadmapMatcherCreateArgs>(args: SelectSubset<T, RoadmapMatcherCreateArgs<ExtArgs>>): Prisma__RoadmapMatcherClient<$Result.GetResult<Prisma.$RoadmapMatcherPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RoadmapMatchers.
     * @param {RoadmapMatcherCreateManyArgs} args - Arguments to create many RoadmapMatchers.
     * @example
     * // Create many RoadmapMatchers
     * const roadmapMatcher = await prisma.roadmapMatcher.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoadmapMatcherCreateManyArgs>(args?: SelectSubset<T, RoadmapMatcherCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RoadmapMatcher.
     * @param {RoadmapMatcherDeleteArgs} args - Arguments to delete one RoadmapMatcher.
     * @example
     * // Delete one RoadmapMatcher
     * const RoadmapMatcher = await prisma.roadmapMatcher.delete({
     *   where: {
     *     // ... filter to delete one RoadmapMatcher
     *   }
     * })
     * 
     */
    delete<T extends RoadmapMatcherDeleteArgs>(args: SelectSubset<T, RoadmapMatcherDeleteArgs<ExtArgs>>): Prisma__RoadmapMatcherClient<$Result.GetResult<Prisma.$RoadmapMatcherPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RoadmapMatcher.
     * @param {RoadmapMatcherUpdateArgs} args - Arguments to update one RoadmapMatcher.
     * @example
     * // Update one RoadmapMatcher
     * const roadmapMatcher = await prisma.roadmapMatcher.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoadmapMatcherUpdateArgs>(args: SelectSubset<T, RoadmapMatcherUpdateArgs<ExtArgs>>): Prisma__RoadmapMatcherClient<$Result.GetResult<Prisma.$RoadmapMatcherPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RoadmapMatchers.
     * @param {RoadmapMatcherDeleteManyArgs} args - Arguments to filter RoadmapMatchers to delete.
     * @example
     * // Delete a few RoadmapMatchers
     * const { count } = await prisma.roadmapMatcher.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoadmapMatcherDeleteManyArgs>(args?: SelectSubset<T, RoadmapMatcherDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoadmapMatchers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapMatcherUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoadmapMatchers
     * const roadmapMatcher = await prisma.roadmapMatcher.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoadmapMatcherUpdateManyArgs>(args: SelectSubset<T, RoadmapMatcherUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RoadmapMatcher.
     * @param {RoadmapMatcherUpsertArgs} args - Arguments to update or create a RoadmapMatcher.
     * @example
     * // Update or create a RoadmapMatcher
     * const roadmapMatcher = await prisma.roadmapMatcher.upsert({
     *   create: {
     *     // ... data to create a RoadmapMatcher
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoadmapMatcher we want to update
     *   }
     * })
     */
    upsert<T extends RoadmapMatcherUpsertArgs>(args: SelectSubset<T, RoadmapMatcherUpsertArgs<ExtArgs>>): Prisma__RoadmapMatcherClient<$Result.GetResult<Prisma.$RoadmapMatcherPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RoadmapMatchers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapMatcherCountArgs} args - Arguments to filter RoadmapMatchers to count.
     * @example
     * // Count the number of RoadmapMatchers
     * const count = await prisma.roadmapMatcher.count({
     *   where: {
     *     // ... the filter for the RoadmapMatchers we want to count
     *   }
     * })
    **/
    count<T extends RoadmapMatcherCountArgs>(
      args?: Subset<T, RoadmapMatcherCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoadmapMatcherCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoadmapMatcher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapMatcherAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoadmapMatcherAggregateArgs>(args: Subset<T, RoadmapMatcherAggregateArgs>): Prisma.PrismaPromise<GetRoadmapMatcherAggregateType<T>>

    /**
     * Group by RoadmapMatcher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapMatcherGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoadmapMatcherGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoadmapMatcherGroupByArgs['orderBy'] }
        : { orderBy?: RoadmapMatcherGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoadmapMatcherGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoadmapMatcherGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoadmapMatcher model
   */
  readonly fields: RoadmapMatcherFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoadmapMatcher.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoadmapMatcherClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoadmapMatcher model
   */
  interface RoadmapMatcherFieldRefs {
    readonly id: FieldRef<"RoadmapMatcher", 'Int'>
    readonly keyword: FieldRef<"RoadmapMatcher", 'String'>
    readonly roadmapId: FieldRef<"RoadmapMatcher", 'Int'>
    readonly matchField: FieldRef<"RoadmapMatcher", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RoadmapMatcher findUnique
   */
  export type RoadmapMatcherFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapMatcher
     */
    select?: RoadmapMatcherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapMatcher
     */
    omit?: RoadmapMatcherOmit<ExtArgs> | null
    /**
     * Filter, which RoadmapMatcher to fetch.
     */
    where: RoadmapMatcherWhereUniqueInput
  }

  /**
   * RoadmapMatcher findUniqueOrThrow
   */
  export type RoadmapMatcherFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapMatcher
     */
    select?: RoadmapMatcherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapMatcher
     */
    omit?: RoadmapMatcherOmit<ExtArgs> | null
    /**
     * Filter, which RoadmapMatcher to fetch.
     */
    where: RoadmapMatcherWhereUniqueInput
  }

  /**
   * RoadmapMatcher findFirst
   */
  export type RoadmapMatcherFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapMatcher
     */
    select?: RoadmapMatcherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapMatcher
     */
    omit?: RoadmapMatcherOmit<ExtArgs> | null
    /**
     * Filter, which RoadmapMatcher to fetch.
     */
    where?: RoadmapMatcherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoadmapMatchers to fetch.
     */
    orderBy?: RoadmapMatcherOrderByWithRelationInput | RoadmapMatcherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoadmapMatchers.
     */
    cursor?: RoadmapMatcherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoadmapMatchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoadmapMatchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoadmapMatchers.
     */
    distinct?: RoadmapMatcherScalarFieldEnum | RoadmapMatcherScalarFieldEnum[]
  }

  /**
   * RoadmapMatcher findFirstOrThrow
   */
  export type RoadmapMatcherFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapMatcher
     */
    select?: RoadmapMatcherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapMatcher
     */
    omit?: RoadmapMatcherOmit<ExtArgs> | null
    /**
     * Filter, which RoadmapMatcher to fetch.
     */
    where?: RoadmapMatcherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoadmapMatchers to fetch.
     */
    orderBy?: RoadmapMatcherOrderByWithRelationInput | RoadmapMatcherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoadmapMatchers.
     */
    cursor?: RoadmapMatcherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoadmapMatchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoadmapMatchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoadmapMatchers.
     */
    distinct?: RoadmapMatcherScalarFieldEnum | RoadmapMatcherScalarFieldEnum[]
  }

  /**
   * RoadmapMatcher findMany
   */
  export type RoadmapMatcherFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapMatcher
     */
    select?: RoadmapMatcherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapMatcher
     */
    omit?: RoadmapMatcherOmit<ExtArgs> | null
    /**
     * Filter, which RoadmapMatchers to fetch.
     */
    where?: RoadmapMatcherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoadmapMatchers to fetch.
     */
    orderBy?: RoadmapMatcherOrderByWithRelationInput | RoadmapMatcherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoadmapMatchers.
     */
    cursor?: RoadmapMatcherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoadmapMatchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoadmapMatchers.
     */
    skip?: number
    distinct?: RoadmapMatcherScalarFieldEnum | RoadmapMatcherScalarFieldEnum[]
  }

  /**
   * RoadmapMatcher create
   */
  export type RoadmapMatcherCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapMatcher
     */
    select?: RoadmapMatcherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapMatcher
     */
    omit?: RoadmapMatcherOmit<ExtArgs> | null
    /**
     * The data needed to create a RoadmapMatcher.
     */
    data: XOR<RoadmapMatcherCreateInput, RoadmapMatcherUncheckedCreateInput>
  }

  /**
   * RoadmapMatcher createMany
   */
  export type RoadmapMatcherCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoadmapMatchers.
     */
    data: RoadmapMatcherCreateManyInput | RoadmapMatcherCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoadmapMatcher update
   */
  export type RoadmapMatcherUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapMatcher
     */
    select?: RoadmapMatcherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapMatcher
     */
    omit?: RoadmapMatcherOmit<ExtArgs> | null
    /**
     * The data needed to update a RoadmapMatcher.
     */
    data: XOR<RoadmapMatcherUpdateInput, RoadmapMatcherUncheckedUpdateInput>
    /**
     * Choose, which RoadmapMatcher to update.
     */
    where: RoadmapMatcherWhereUniqueInput
  }

  /**
   * RoadmapMatcher updateMany
   */
  export type RoadmapMatcherUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoadmapMatchers.
     */
    data: XOR<RoadmapMatcherUpdateManyMutationInput, RoadmapMatcherUncheckedUpdateManyInput>
    /**
     * Filter which RoadmapMatchers to update
     */
    where?: RoadmapMatcherWhereInput
    /**
     * Limit how many RoadmapMatchers to update.
     */
    limit?: number
  }

  /**
   * RoadmapMatcher upsert
   */
  export type RoadmapMatcherUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapMatcher
     */
    select?: RoadmapMatcherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapMatcher
     */
    omit?: RoadmapMatcherOmit<ExtArgs> | null
    /**
     * The filter to search for the RoadmapMatcher to update in case it exists.
     */
    where: RoadmapMatcherWhereUniqueInput
    /**
     * In case the RoadmapMatcher found by the `where` argument doesn't exist, create a new RoadmapMatcher with this data.
     */
    create: XOR<RoadmapMatcherCreateInput, RoadmapMatcherUncheckedCreateInput>
    /**
     * In case the RoadmapMatcher was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoadmapMatcherUpdateInput, RoadmapMatcherUncheckedUpdateInput>
  }

  /**
   * RoadmapMatcher delete
   */
  export type RoadmapMatcherDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapMatcher
     */
    select?: RoadmapMatcherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapMatcher
     */
    omit?: RoadmapMatcherOmit<ExtArgs> | null
    /**
     * Filter which RoadmapMatcher to delete.
     */
    where: RoadmapMatcherWhereUniqueInput
  }

  /**
   * RoadmapMatcher deleteMany
   */
  export type RoadmapMatcherDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoadmapMatchers to delete
     */
    where?: RoadmapMatcherWhereInput
    /**
     * Limit how many RoadmapMatchers to delete.
     */
    limit?: number
  }

  /**
   * RoadmapMatcher without action
   */
  export type RoadmapMatcherDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapMatcher
     */
    select?: RoadmapMatcherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapMatcher
     */
    omit?: RoadmapMatcherOmit<ExtArgs> | null
  }


  /**
   * Model assessment
   */

  export type AggregateAssessment = {
    _count: AssessmentCountAggregateOutputType | null
    _avg: AssessmentAvgAggregateOutputType | null
    _sum: AssessmentSumAggregateOutputType | null
    _min: AssessmentMinAggregateOutputType | null
    _max: AssessmentMaxAggregateOutputType | null
  }

  export type AssessmentAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type AssessmentSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type AssessmentMinAggregateOutputType = {
    id: number | null
    userId: number | null
    studentStatus: string | null
    majorStudy: string | null
    currentSemester: string | null
    createdAt: Date | null
    currentField: string | null
    dreamJob: string | null
    interestedField: string | null
    mainGoal: string | null
  }

  export type AssessmentMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    studentStatus: string | null
    majorStudy: string | null
    currentSemester: string | null
    createdAt: Date | null
    currentField: string | null
    dreamJob: string | null
    interestedField: string | null
    mainGoal: string | null
  }

  export type AssessmentCountAggregateOutputType = {
    id: number
    userId: number
    studentStatus: number
    majorStudy: number
    currentSemester: number
    createdAt: number
    currentField: number
    dreamJob: number
    interestedField: number
    mainGoal: number
    _all: number
  }


  export type AssessmentAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type AssessmentSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type AssessmentMinAggregateInputType = {
    id?: true
    userId?: true
    studentStatus?: true
    majorStudy?: true
    currentSemester?: true
    createdAt?: true
    currentField?: true
    dreamJob?: true
    interestedField?: true
    mainGoal?: true
  }

  export type AssessmentMaxAggregateInputType = {
    id?: true
    userId?: true
    studentStatus?: true
    majorStudy?: true
    currentSemester?: true
    createdAt?: true
    currentField?: true
    dreamJob?: true
    interestedField?: true
    mainGoal?: true
  }

  export type AssessmentCountAggregateInputType = {
    id?: true
    userId?: true
    studentStatus?: true
    majorStudy?: true
    currentSemester?: true
    createdAt?: true
    currentField?: true
    dreamJob?: true
    interestedField?: true
    mainGoal?: true
    _all?: true
  }

  export type AssessmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which assessment to aggregate.
     */
    where?: assessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of assessments to fetch.
     */
    orderBy?: assessmentOrderByWithRelationInput | assessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: assessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` assessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` assessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned assessments
    **/
    _count?: true | AssessmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssessmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssessmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssessmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssessmentMaxAggregateInputType
  }

  export type GetAssessmentAggregateType<T extends AssessmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAssessment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssessment[P]>
      : GetScalarType<T[P], AggregateAssessment[P]>
  }




  export type assessmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: assessmentWhereInput
    orderBy?: assessmentOrderByWithAggregationInput | assessmentOrderByWithAggregationInput[]
    by: AssessmentScalarFieldEnum[] | AssessmentScalarFieldEnum
    having?: assessmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssessmentCountAggregateInputType | true
    _avg?: AssessmentAvgAggregateInputType
    _sum?: AssessmentSumAggregateInputType
    _min?: AssessmentMinAggregateInputType
    _max?: AssessmentMaxAggregateInputType
  }

  export type AssessmentGroupByOutputType = {
    id: number
    userId: number
    studentStatus: string
    majorStudy: string
    currentSemester: string
    createdAt: Date
    currentField: string
    dreamJob: string
    interestedField: string
    mainGoal: string
    _count: AssessmentCountAggregateOutputType | null
    _avg: AssessmentAvgAggregateOutputType | null
    _sum: AssessmentSumAggregateOutputType | null
    _min: AssessmentMinAggregateOutputType | null
    _max: AssessmentMaxAggregateOutputType | null
  }

  type GetAssessmentGroupByPayload<T extends assessmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssessmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssessmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssessmentGroupByOutputType[P]>
            : GetScalarType<T[P], AssessmentGroupByOutputType[P]>
        }
      >
    >


  export type assessmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    studentStatus?: boolean
    majorStudy?: boolean
    currentSemester?: boolean
    createdAt?: boolean
    currentField?: boolean
    dreamJob?: boolean
    interestedField?: boolean
    mainGoal?: boolean
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assessment"]>



  export type assessmentSelectScalar = {
    id?: boolean
    userId?: boolean
    studentStatus?: boolean
    majorStudy?: boolean
    currentSemester?: boolean
    createdAt?: boolean
    currentField?: boolean
    dreamJob?: boolean
    interestedField?: boolean
    mainGoal?: boolean
  }

  export type assessmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "studentStatus" | "majorStudy" | "currentSemester" | "createdAt" | "currentField" | "dreamJob" | "interestedField" | "mainGoal", ExtArgs["result"]["assessment"]>
  export type assessmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $assessmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "assessment"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      studentStatus: string
      majorStudy: string
      currentSemester: string
      createdAt: Date
      currentField: string
      dreamJob: string
      interestedField: string
      mainGoal: string
    }, ExtArgs["result"]["assessment"]>
    composites: {}
  }

  type assessmentGetPayload<S extends boolean | null | undefined | assessmentDefaultArgs> = $Result.GetResult<Prisma.$assessmentPayload, S>

  type assessmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<assessmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AssessmentCountAggregateInputType | true
    }

  export interface assessmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['assessment'], meta: { name: 'assessment' } }
    /**
     * Find zero or one Assessment that matches the filter.
     * @param {assessmentFindUniqueArgs} args - Arguments to find a Assessment
     * @example
     * // Get one Assessment
     * const assessment = await prisma.assessment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends assessmentFindUniqueArgs>(args: SelectSubset<T, assessmentFindUniqueArgs<ExtArgs>>): Prisma__assessmentClient<$Result.GetResult<Prisma.$assessmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Assessment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {assessmentFindUniqueOrThrowArgs} args - Arguments to find a Assessment
     * @example
     * // Get one Assessment
     * const assessment = await prisma.assessment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends assessmentFindUniqueOrThrowArgs>(args: SelectSubset<T, assessmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__assessmentClient<$Result.GetResult<Prisma.$assessmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Assessment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assessmentFindFirstArgs} args - Arguments to find a Assessment
     * @example
     * // Get one Assessment
     * const assessment = await prisma.assessment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends assessmentFindFirstArgs>(args?: SelectSubset<T, assessmentFindFirstArgs<ExtArgs>>): Prisma__assessmentClient<$Result.GetResult<Prisma.$assessmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Assessment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assessmentFindFirstOrThrowArgs} args - Arguments to find a Assessment
     * @example
     * // Get one Assessment
     * const assessment = await prisma.assessment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends assessmentFindFirstOrThrowArgs>(args?: SelectSubset<T, assessmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__assessmentClient<$Result.GetResult<Prisma.$assessmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Assessments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assessmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assessments
     * const assessments = await prisma.assessment.findMany()
     * 
     * // Get first 10 Assessments
     * const assessments = await prisma.assessment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assessmentWithIdOnly = await prisma.assessment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends assessmentFindManyArgs>(args?: SelectSubset<T, assessmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$assessmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Assessment.
     * @param {assessmentCreateArgs} args - Arguments to create a Assessment.
     * @example
     * // Create one Assessment
     * const Assessment = await prisma.assessment.create({
     *   data: {
     *     // ... data to create a Assessment
     *   }
     * })
     * 
     */
    create<T extends assessmentCreateArgs>(args: SelectSubset<T, assessmentCreateArgs<ExtArgs>>): Prisma__assessmentClient<$Result.GetResult<Prisma.$assessmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Assessments.
     * @param {assessmentCreateManyArgs} args - Arguments to create many Assessments.
     * @example
     * // Create many Assessments
     * const assessment = await prisma.assessment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends assessmentCreateManyArgs>(args?: SelectSubset<T, assessmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Assessment.
     * @param {assessmentDeleteArgs} args - Arguments to delete one Assessment.
     * @example
     * // Delete one Assessment
     * const Assessment = await prisma.assessment.delete({
     *   where: {
     *     // ... filter to delete one Assessment
     *   }
     * })
     * 
     */
    delete<T extends assessmentDeleteArgs>(args: SelectSubset<T, assessmentDeleteArgs<ExtArgs>>): Prisma__assessmentClient<$Result.GetResult<Prisma.$assessmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Assessment.
     * @param {assessmentUpdateArgs} args - Arguments to update one Assessment.
     * @example
     * // Update one Assessment
     * const assessment = await prisma.assessment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends assessmentUpdateArgs>(args: SelectSubset<T, assessmentUpdateArgs<ExtArgs>>): Prisma__assessmentClient<$Result.GetResult<Prisma.$assessmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Assessments.
     * @param {assessmentDeleteManyArgs} args - Arguments to filter Assessments to delete.
     * @example
     * // Delete a few Assessments
     * const { count } = await prisma.assessment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends assessmentDeleteManyArgs>(args?: SelectSubset<T, assessmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assessments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assessmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assessments
     * const assessment = await prisma.assessment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends assessmentUpdateManyArgs>(args: SelectSubset<T, assessmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Assessment.
     * @param {assessmentUpsertArgs} args - Arguments to update or create a Assessment.
     * @example
     * // Update or create a Assessment
     * const assessment = await prisma.assessment.upsert({
     *   create: {
     *     // ... data to create a Assessment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Assessment we want to update
     *   }
     * })
     */
    upsert<T extends assessmentUpsertArgs>(args: SelectSubset<T, assessmentUpsertArgs<ExtArgs>>): Prisma__assessmentClient<$Result.GetResult<Prisma.$assessmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Assessments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assessmentCountArgs} args - Arguments to filter Assessments to count.
     * @example
     * // Count the number of Assessments
     * const count = await prisma.assessment.count({
     *   where: {
     *     // ... the filter for the Assessments we want to count
     *   }
     * })
    **/
    count<T extends assessmentCountArgs>(
      args?: Subset<T, assessmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssessmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Assessment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssessmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssessmentAggregateArgs>(args: Subset<T, AssessmentAggregateArgs>): Prisma.PrismaPromise<GetAssessmentAggregateType<T>>

    /**
     * Group by Assessment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assessmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends assessmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: assessmentGroupByArgs['orderBy'] }
        : { orderBy?: assessmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, assessmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssessmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the assessment model
   */
  readonly fields: assessmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for assessment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__assessmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the assessment model
   */
  interface assessmentFieldRefs {
    readonly id: FieldRef<"assessment", 'Int'>
    readonly userId: FieldRef<"assessment", 'Int'>
    readonly studentStatus: FieldRef<"assessment", 'String'>
    readonly majorStudy: FieldRef<"assessment", 'String'>
    readonly currentSemester: FieldRef<"assessment", 'String'>
    readonly createdAt: FieldRef<"assessment", 'DateTime'>
    readonly currentField: FieldRef<"assessment", 'String'>
    readonly dreamJob: FieldRef<"assessment", 'String'>
    readonly interestedField: FieldRef<"assessment", 'String'>
    readonly mainGoal: FieldRef<"assessment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * assessment findUnique
   */
  export type assessmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assessment
     */
    select?: assessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assessment
     */
    omit?: assessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assessmentInclude<ExtArgs> | null
    /**
     * Filter, which assessment to fetch.
     */
    where: assessmentWhereUniqueInput
  }

  /**
   * assessment findUniqueOrThrow
   */
  export type assessmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assessment
     */
    select?: assessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assessment
     */
    omit?: assessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assessmentInclude<ExtArgs> | null
    /**
     * Filter, which assessment to fetch.
     */
    where: assessmentWhereUniqueInput
  }

  /**
   * assessment findFirst
   */
  export type assessmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assessment
     */
    select?: assessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assessment
     */
    omit?: assessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assessmentInclude<ExtArgs> | null
    /**
     * Filter, which assessment to fetch.
     */
    where?: assessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of assessments to fetch.
     */
    orderBy?: assessmentOrderByWithRelationInput | assessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for assessments.
     */
    cursor?: assessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` assessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` assessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of assessments.
     */
    distinct?: AssessmentScalarFieldEnum | AssessmentScalarFieldEnum[]
  }

  /**
   * assessment findFirstOrThrow
   */
  export type assessmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assessment
     */
    select?: assessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assessment
     */
    omit?: assessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assessmentInclude<ExtArgs> | null
    /**
     * Filter, which assessment to fetch.
     */
    where?: assessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of assessments to fetch.
     */
    orderBy?: assessmentOrderByWithRelationInput | assessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for assessments.
     */
    cursor?: assessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` assessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` assessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of assessments.
     */
    distinct?: AssessmentScalarFieldEnum | AssessmentScalarFieldEnum[]
  }

  /**
   * assessment findMany
   */
  export type assessmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assessment
     */
    select?: assessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assessment
     */
    omit?: assessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assessmentInclude<ExtArgs> | null
    /**
     * Filter, which assessments to fetch.
     */
    where?: assessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of assessments to fetch.
     */
    orderBy?: assessmentOrderByWithRelationInput | assessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing assessments.
     */
    cursor?: assessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` assessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` assessments.
     */
    skip?: number
    distinct?: AssessmentScalarFieldEnum | AssessmentScalarFieldEnum[]
  }

  /**
   * assessment create
   */
  export type assessmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assessment
     */
    select?: assessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assessment
     */
    omit?: assessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assessmentInclude<ExtArgs> | null
    /**
     * The data needed to create a assessment.
     */
    data: XOR<assessmentCreateInput, assessmentUncheckedCreateInput>
  }

  /**
   * assessment createMany
   */
  export type assessmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many assessments.
     */
    data: assessmentCreateManyInput | assessmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * assessment update
   */
  export type assessmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assessment
     */
    select?: assessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assessment
     */
    omit?: assessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assessmentInclude<ExtArgs> | null
    /**
     * The data needed to update a assessment.
     */
    data: XOR<assessmentUpdateInput, assessmentUncheckedUpdateInput>
    /**
     * Choose, which assessment to update.
     */
    where: assessmentWhereUniqueInput
  }

  /**
   * assessment updateMany
   */
  export type assessmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update assessments.
     */
    data: XOR<assessmentUpdateManyMutationInput, assessmentUncheckedUpdateManyInput>
    /**
     * Filter which assessments to update
     */
    where?: assessmentWhereInput
    /**
     * Limit how many assessments to update.
     */
    limit?: number
  }

  /**
   * assessment upsert
   */
  export type assessmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assessment
     */
    select?: assessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assessment
     */
    omit?: assessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assessmentInclude<ExtArgs> | null
    /**
     * The filter to search for the assessment to update in case it exists.
     */
    where: assessmentWhereUniqueInput
    /**
     * In case the assessment found by the `where` argument doesn't exist, create a new assessment with this data.
     */
    create: XOR<assessmentCreateInput, assessmentUncheckedCreateInput>
    /**
     * In case the assessment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<assessmentUpdateInput, assessmentUncheckedUpdateInput>
  }

  /**
   * assessment delete
   */
  export type assessmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assessment
     */
    select?: assessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assessment
     */
    omit?: assessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assessmentInclude<ExtArgs> | null
    /**
     * Filter which assessment to delete.
     */
    where: assessmentWhereUniqueInput
  }

  /**
   * assessment deleteMany
   */
  export type assessmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which assessments to delete
     */
    where?: assessmentWhereInput
    /**
     * Limit how many assessments to delete.
     */
    limit?: number
  }

  /**
   * assessment without action
   */
  export type assessmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assessment
     */
    select?: assessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assessment
     */
    omit?: assessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assessmentInclude<ExtArgs> | null
  }


  /**
   * Model BookmarkCourse
   */

  export type AggregateBookmarkCourse = {
    _count: BookmarkCourseCountAggregateOutputType | null
    _avg: BookmarkCourseAvgAggregateOutputType | null
    _sum: BookmarkCourseSumAggregateOutputType | null
    _min: BookmarkCourseMinAggregateOutputType | null
    _max: BookmarkCourseMaxAggregateOutputType | null
  }

  export type BookmarkCourseAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
  }

  export type BookmarkCourseSumAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
  }

  export type BookmarkCourseMinAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
    createdAt: Date | null
  }

  export type BookmarkCourseMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
    createdAt: Date | null
  }

  export type BookmarkCourseCountAggregateOutputType = {
    id: number
    userId: number
    courseId: number
    createdAt: number
    _all: number
  }


  export type BookmarkCourseAvgAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
  }

  export type BookmarkCourseSumAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
  }

  export type BookmarkCourseMinAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    createdAt?: true
  }

  export type BookmarkCourseMaxAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    createdAt?: true
  }

  export type BookmarkCourseCountAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    createdAt?: true
    _all?: true
  }

  export type BookmarkCourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookmarkCourse to aggregate.
     */
    where?: BookmarkCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookmarkCourses to fetch.
     */
    orderBy?: BookmarkCourseOrderByWithRelationInput | BookmarkCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookmarkCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookmarkCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookmarkCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BookmarkCourses
    **/
    _count?: true | BookmarkCourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookmarkCourseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookmarkCourseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookmarkCourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookmarkCourseMaxAggregateInputType
  }

  export type GetBookmarkCourseAggregateType<T extends BookmarkCourseAggregateArgs> = {
        [P in keyof T & keyof AggregateBookmarkCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookmarkCourse[P]>
      : GetScalarType<T[P], AggregateBookmarkCourse[P]>
  }




  export type BookmarkCourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookmarkCourseWhereInput
    orderBy?: BookmarkCourseOrderByWithAggregationInput | BookmarkCourseOrderByWithAggregationInput[]
    by: BookmarkCourseScalarFieldEnum[] | BookmarkCourseScalarFieldEnum
    having?: BookmarkCourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookmarkCourseCountAggregateInputType | true
    _avg?: BookmarkCourseAvgAggregateInputType
    _sum?: BookmarkCourseSumAggregateInputType
    _min?: BookmarkCourseMinAggregateInputType
    _max?: BookmarkCourseMaxAggregateInputType
  }

  export type BookmarkCourseGroupByOutputType = {
    id: number
    userId: number
    courseId: number
    createdAt: Date
    _count: BookmarkCourseCountAggregateOutputType | null
    _avg: BookmarkCourseAvgAggregateOutputType | null
    _sum: BookmarkCourseSumAggregateOutputType | null
    _min: BookmarkCourseMinAggregateOutputType | null
    _max: BookmarkCourseMaxAggregateOutputType | null
  }

  type GetBookmarkCourseGroupByPayload<T extends BookmarkCourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookmarkCourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookmarkCourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookmarkCourseGroupByOutputType[P]>
            : GetScalarType<T[P], BookmarkCourseGroupByOutputType[P]>
        }
      >
    >


  export type BookmarkCourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["bookmarkCourse"]>



  export type BookmarkCourseSelectScalar = {
    id?: boolean
    userId?: boolean
    courseId?: boolean
    createdAt?: boolean
  }

  export type BookmarkCourseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "courseId" | "createdAt", ExtArgs["result"]["bookmarkCourse"]>

  export type $BookmarkCoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BookmarkCourse"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      courseId: number
      createdAt: Date
    }, ExtArgs["result"]["bookmarkCourse"]>
    composites: {}
  }

  type BookmarkCourseGetPayload<S extends boolean | null | undefined | BookmarkCourseDefaultArgs> = $Result.GetResult<Prisma.$BookmarkCoursePayload, S>

  type BookmarkCourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookmarkCourseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookmarkCourseCountAggregateInputType | true
    }

  export interface BookmarkCourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BookmarkCourse'], meta: { name: 'BookmarkCourse' } }
    /**
     * Find zero or one BookmarkCourse that matches the filter.
     * @param {BookmarkCourseFindUniqueArgs} args - Arguments to find a BookmarkCourse
     * @example
     * // Get one BookmarkCourse
     * const bookmarkCourse = await prisma.bookmarkCourse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookmarkCourseFindUniqueArgs>(args: SelectSubset<T, BookmarkCourseFindUniqueArgs<ExtArgs>>): Prisma__BookmarkCourseClient<$Result.GetResult<Prisma.$BookmarkCoursePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BookmarkCourse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookmarkCourseFindUniqueOrThrowArgs} args - Arguments to find a BookmarkCourse
     * @example
     * // Get one BookmarkCourse
     * const bookmarkCourse = await prisma.bookmarkCourse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookmarkCourseFindUniqueOrThrowArgs>(args: SelectSubset<T, BookmarkCourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookmarkCourseClient<$Result.GetResult<Prisma.$BookmarkCoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookmarkCourse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkCourseFindFirstArgs} args - Arguments to find a BookmarkCourse
     * @example
     * // Get one BookmarkCourse
     * const bookmarkCourse = await prisma.bookmarkCourse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookmarkCourseFindFirstArgs>(args?: SelectSubset<T, BookmarkCourseFindFirstArgs<ExtArgs>>): Prisma__BookmarkCourseClient<$Result.GetResult<Prisma.$BookmarkCoursePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookmarkCourse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkCourseFindFirstOrThrowArgs} args - Arguments to find a BookmarkCourse
     * @example
     * // Get one BookmarkCourse
     * const bookmarkCourse = await prisma.bookmarkCourse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookmarkCourseFindFirstOrThrowArgs>(args?: SelectSubset<T, BookmarkCourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookmarkCourseClient<$Result.GetResult<Prisma.$BookmarkCoursePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BookmarkCourses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkCourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BookmarkCourses
     * const bookmarkCourses = await prisma.bookmarkCourse.findMany()
     * 
     * // Get first 10 BookmarkCourses
     * const bookmarkCourses = await prisma.bookmarkCourse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookmarkCourseWithIdOnly = await prisma.bookmarkCourse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookmarkCourseFindManyArgs>(args?: SelectSubset<T, BookmarkCourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookmarkCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BookmarkCourse.
     * @param {BookmarkCourseCreateArgs} args - Arguments to create a BookmarkCourse.
     * @example
     * // Create one BookmarkCourse
     * const BookmarkCourse = await prisma.bookmarkCourse.create({
     *   data: {
     *     // ... data to create a BookmarkCourse
     *   }
     * })
     * 
     */
    create<T extends BookmarkCourseCreateArgs>(args: SelectSubset<T, BookmarkCourseCreateArgs<ExtArgs>>): Prisma__BookmarkCourseClient<$Result.GetResult<Prisma.$BookmarkCoursePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BookmarkCourses.
     * @param {BookmarkCourseCreateManyArgs} args - Arguments to create many BookmarkCourses.
     * @example
     * // Create many BookmarkCourses
     * const bookmarkCourse = await prisma.bookmarkCourse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookmarkCourseCreateManyArgs>(args?: SelectSubset<T, BookmarkCourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BookmarkCourse.
     * @param {BookmarkCourseDeleteArgs} args - Arguments to delete one BookmarkCourse.
     * @example
     * // Delete one BookmarkCourse
     * const BookmarkCourse = await prisma.bookmarkCourse.delete({
     *   where: {
     *     // ... filter to delete one BookmarkCourse
     *   }
     * })
     * 
     */
    delete<T extends BookmarkCourseDeleteArgs>(args: SelectSubset<T, BookmarkCourseDeleteArgs<ExtArgs>>): Prisma__BookmarkCourseClient<$Result.GetResult<Prisma.$BookmarkCoursePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BookmarkCourse.
     * @param {BookmarkCourseUpdateArgs} args - Arguments to update one BookmarkCourse.
     * @example
     * // Update one BookmarkCourse
     * const bookmarkCourse = await prisma.bookmarkCourse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookmarkCourseUpdateArgs>(args: SelectSubset<T, BookmarkCourseUpdateArgs<ExtArgs>>): Prisma__BookmarkCourseClient<$Result.GetResult<Prisma.$BookmarkCoursePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BookmarkCourses.
     * @param {BookmarkCourseDeleteManyArgs} args - Arguments to filter BookmarkCourses to delete.
     * @example
     * // Delete a few BookmarkCourses
     * const { count } = await prisma.bookmarkCourse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookmarkCourseDeleteManyArgs>(args?: SelectSubset<T, BookmarkCourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookmarkCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkCourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BookmarkCourses
     * const bookmarkCourse = await prisma.bookmarkCourse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookmarkCourseUpdateManyArgs>(args: SelectSubset<T, BookmarkCourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BookmarkCourse.
     * @param {BookmarkCourseUpsertArgs} args - Arguments to update or create a BookmarkCourse.
     * @example
     * // Update or create a BookmarkCourse
     * const bookmarkCourse = await prisma.bookmarkCourse.upsert({
     *   create: {
     *     // ... data to create a BookmarkCourse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BookmarkCourse we want to update
     *   }
     * })
     */
    upsert<T extends BookmarkCourseUpsertArgs>(args: SelectSubset<T, BookmarkCourseUpsertArgs<ExtArgs>>): Prisma__BookmarkCourseClient<$Result.GetResult<Prisma.$BookmarkCoursePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BookmarkCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkCourseCountArgs} args - Arguments to filter BookmarkCourses to count.
     * @example
     * // Count the number of BookmarkCourses
     * const count = await prisma.bookmarkCourse.count({
     *   where: {
     *     // ... the filter for the BookmarkCourses we want to count
     *   }
     * })
    **/
    count<T extends BookmarkCourseCountArgs>(
      args?: Subset<T, BookmarkCourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookmarkCourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BookmarkCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkCourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookmarkCourseAggregateArgs>(args: Subset<T, BookmarkCourseAggregateArgs>): Prisma.PrismaPromise<GetBookmarkCourseAggregateType<T>>

    /**
     * Group by BookmarkCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkCourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookmarkCourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookmarkCourseGroupByArgs['orderBy'] }
        : { orderBy?: BookmarkCourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookmarkCourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookmarkCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BookmarkCourse model
   */
  readonly fields: BookmarkCourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BookmarkCourse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookmarkCourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BookmarkCourse model
   */
  interface BookmarkCourseFieldRefs {
    readonly id: FieldRef<"BookmarkCourse", 'Int'>
    readonly userId: FieldRef<"BookmarkCourse", 'Int'>
    readonly courseId: FieldRef<"BookmarkCourse", 'Int'>
    readonly createdAt: FieldRef<"BookmarkCourse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BookmarkCourse findUnique
   */
  export type BookmarkCourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookmarkCourse
     */
    select?: BookmarkCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookmarkCourse
     */
    omit?: BookmarkCourseOmit<ExtArgs> | null
    /**
     * Filter, which BookmarkCourse to fetch.
     */
    where: BookmarkCourseWhereUniqueInput
  }

  /**
   * BookmarkCourse findUniqueOrThrow
   */
  export type BookmarkCourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookmarkCourse
     */
    select?: BookmarkCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookmarkCourse
     */
    omit?: BookmarkCourseOmit<ExtArgs> | null
    /**
     * Filter, which BookmarkCourse to fetch.
     */
    where: BookmarkCourseWhereUniqueInput
  }

  /**
   * BookmarkCourse findFirst
   */
  export type BookmarkCourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookmarkCourse
     */
    select?: BookmarkCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookmarkCourse
     */
    omit?: BookmarkCourseOmit<ExtArgs> | null
    /**
     * Filter, which BookmarkCourse to fetch.
     */
    where?: BookmarkCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookmarkCourses to fetch.
     */
    orderBy?: BookmarkCourseOrderByWithRelationInput | BookmarkCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookmarkCourses.
     */
    cursor?: BookmarkCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookmarkCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookmarkCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookmarkCourses.
     */
    distinct?: BookmarkCourseScalarFieldEnum | BookmarkCourseScalarFieldEnum[]
  }

  /**
   * BookmarkCourse findFirstOrThrow
   */
  export type BookmarkCourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookmarkCourse
     */
    select?: BookmarkCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookmarkCourse
     */
    omit?: BookmarkCourseOmit<ExtArgs> | null
    /**
     * Filter, which BookmarkCourse to fetch.
     */
    where?: BookmarkCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookmarkCourses to fetch.
     */
    orderBy?: BookmarkCourseOrderByWithRelationInput | BookmarkCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookmarkCourses.
     */
    cursor?: BookmarkCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookmarkCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookmarkCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookmarkCourses.
     */
    distinct?: BookmarkCourseScalarFieldEnum | BookmarkCourseScalarFieldEnum[]
  }

  /**
   * BookmarkCourse findMany
   */
  export type BookmarkCourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookmarkCourse
     */
    select?: BookmarkCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookmarkCourse
     */
    omit?: BookmarkCourseOmit<ExtArgs> | null
    /**
     * Filter, which BookmarkCourses to fetch.
     */
    where?: BookmarkCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookmarkCourses to fetch.
     */
    orderBy?: BookmarkCourseOrderByWithRelationInput | BookmarkCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BookmarkCourses.
     */
    cursor?: BookmarkCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookmarkCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookmarkCourses.
     */
    skip?: number
    distinct?: BookmarkCourseScalarFieldEnum | BookmarkCourseScalarFieldEnum[]
  }

  /**
   * BookmarkCourse create
   */
  export type BookmarkCourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookmarkCourse
     */
    select?: BookmarkCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookmarkCourse
     */
    omit?: BookmarkCourseOmit<ExtArgs> | null
    /**
     * The data needed to create a BookmarkCourse.
     */
    data: XOR<BookmarkCourseCreateInput, BookmarkCourseUncheckedCreateInput>
  }

  /**
   * BookmarkCourse createMany
   */
  export type BookmarkCourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BookmarkCourses.
     */
    data: BookmarkCourseCreateManyInput | BookmarkCourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BookmarkCourse update
   */
  export type BookmarkCourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookmarkCourse
     */
    select?: BookmarkCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookmarkCourse
     */
    omit?: BookmarkCourseOmit<ExtArgs> | null
    /**
     * The data needed to update a BookmarkCourse.
     */
    data: XOR<BookmarkCourseUpdateInput, BookmarkCourseUncheckedUpdateInput>
    /**
     * Choose, which BookmarkCourse to update.
     */
    where: BookmarkCourseWhereUniqueInput
  }

  /**
   * BookmarkCourse updateMany
   */
  export type BookmarkCourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BookmarkCourses.
     */
    data: XOR<BookmarkCourseUpdateManyMutationInput, BookmarkCourseUncheckedUpdateManyInput>
    /**
     * Filter which BookmarkCourses to update
     */
    where?: BookmarkCourseWhereInput
    /**
     * Limit how many BookmarkCourses to update.
     */
    limit?: number
  }

  /**
   * BookmarkCourse upsert
   */
  export type BookmarkCourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookmarkCourse
     */
    select?: BookmarkCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookmarkCourse
     */
    omit?: BookmarkCourseOmit<ExtArgs> | null
    /**
     * The filter to search for the BookmarkCourse to update in case it exists.
     */
    where: BookmarkCourseWhereUniqueInput
    /**
     * In case the BookmarkCourse found by the `where` argument doesn't exist, create a new BookmarkCourse with this data.
     */
    create: XOR<BookmarkCourseCreateInput, BookmarkCourseUncheckedCreateInput>
    /**
     * In case the BookmarkCourse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookmarkCourseUpdateInput, BookmarkCourseUncheckedUpdateInput>
  }

  /**
   * BookmarkCourse delete
   */
  export type BookmarkCourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookmarkCourse
     */
    select?: BookmarkCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookmarkCourse
     */
    omit?: BookmarkCourseOmit<ExtArgs> | null
    /**
     * Filter which BookmarkCourse to delete.
     */
    where: BookmarkCourseWhereUniqueInput
  }

  /**
   * BookmarkCourse deleteMany
   */
  export type BookmarkCourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookmarkCourses to delete
     */
    where?: BookmarkCourseWhereInput
    /**
     * Limit how many BookmarkCourses to delete.
     */
    limit?: number
  }

  /**
   * BookmarkCourse without action
   */
  export type BookmarkCourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookmarkCourse
     */
    select?: BookmarkCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookmarkCourse
     */
    omit?: BookmarkCourseOmit<ExtArgs> | null
  }


  /**
   * Model category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type CategorySumAggregateOutputType = {
    id: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    id?: true
  }

  export type CategorySumAggregateInputType = {
    id?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which category to aggregate.
     */
    where?: categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoryOrderByWithRelationInput | categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type categoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: categoryWhereInput
    orderBy?: categoryOrderByWithAggregationInput | categoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: categoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: number
    name: string
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends categoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type categorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    course?: boolean | category$courseArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>



  export type categorySelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type categoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["category"]>
  export type categoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | category$courseArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $categoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "category"
    objects: {
      course: Prisma.$coursePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type categoryGetPayload<S extends boolean | null | undefined | categoryDefaultArgs> = $Result.GetResult<Prisma.$categoryPayload, S>

  type categoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<categoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface categoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['category'], meta: { name: 'category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {categoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends categoryFindUniqueArgs>(args: SelectSubset<T, categoryFindUniqueArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {categoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends categoryFindUniqueOrThrowArgs>(args: SelectSubset<T, categoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends categoryFindFirstArgs>(args?: SelectSubset<T, categoryFindFirstArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends categoryFindFirstOrThrowArgs>(args?: SelectSubset<T, categoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends categoryFindManyArgs>(args?: SelectSubset<T, categoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {categoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends categoryCreateArgs>(args: SelectSubset<T, categoryCreateArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {categoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends categoryCreateManyArgs>(args?: SelectSubset<T, categoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Category.
     * @param {categoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends categoryDeleteArgs>(args: SelectSubset<T, categoryDeleteArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {categoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends categoryUpdateArgs>(args: SelectSubset<T, categoryUpdateArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {categoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends categoryDeleteManyArgs>(args?: SelectSubset<T, categoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends categoryUpdateManyArgs>(args: SelectSubset<T, categoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {categoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends categoryUpsertArgs>(args: SelectSubset<T, categoryUpsertArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends categoryCountArgs>(
      args?: Subset<T, categoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends categoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: categoryGroupByArgs['orderBy'] }
        : { orderBy?: categoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, categoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the category model
   */
  readonly fields: categoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__categoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends category$courseArgs<ExtArgs> = {}>(args?: Subset<T, category$courseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$coursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the category model
   */
  interface categoryFieldRefs {
    readonly id: FieldRef<"category", 'Int'>
    readonly name: FieldRef<"category", 'String'>
  }
    

  // Custom InputTypes
  /**
   * category findUnique
   */
  export type categoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter, which category to fetch.
     */
    where: categoryWhereUniqueInput
  }

  /**
   * category findUniqueOrThrow
   */
  export type categoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter, which category to fetch.
     */
    where: categoryWhereUniqueInput
  }

  /**
   * category findFirst
   */
  export type categoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter, which category to fetch.
     */
    where?: categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoryOrderByWithRelationInput | categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categories.
     */
    cursor?: categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * category findFirstOrThrow
   */
  export type categoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter, which category to fetch.
     */
    where?: categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoryOrderByWithRelationInput | categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categories.
     */
    cursor?: categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * category findMany
   */
  export type categoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where?: categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoryOrderByWithRelationInput | categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing categories.
     */
    cursor?: categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * category create
   */
  export type categoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * The data needed to create a category.
     */
    data: XOR<categoryCreateInput, categoryUncheckedCreateInput>
  }

  /**
   * category createMany
   */
  export type categoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many categories.
     */
    data: categoryCreateManyInput | categoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * category update
   */
  export type categoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * The data needed to update a category.
     */
    data: XOR<categoryUpdateInput, categoryUncheckedUpdateInput>
    /**
     * Choose, which category to update.
     */
    where: categoryWhereUniqueInput
  }

  /**
   * category updateMany
   */
  export type categoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update categories.
     */
    data: XOR<categoryUpdateManyMutationInput, categoryUncheckedUpdateManyInput>
    /**
     * Filter which categories to update
     */
    where?: categoryWhereInput
    /**
     * Limit how many categories to update.
     */
    limit?: number
  }

  /**
   * category upsert
   */
  export type categoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * The filter to search for the category to update in case it exists.
     */
    where: categoryWhereUniqueInput
    /**
     * In case the category found by the `where` argument doesn't exist, create a new category with this data.
     */
    create: XOR<categoryCreateInput, categoryUncheckedCreateInput>
    /**
     * In case the category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<categoryUpdateInput, categoryUncheckedUpdateInput>
  }

  /**
   * category delete
   */
  export type categoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter which category to delete.
     */
    where: categoryWhereUniqueInput
  }

  /**
   * category deleteMany
   */
  export type categoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which categories to delete
     */
    where?: categoryWhereInput
    /**
     * Limit how many categories to delete.
     */
    limit?: number
  }

  /**
   * category.course
   */
  export type category$courseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course
     */
    select?: courseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course
     */
    omit?: courseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: courseInclude<ExtArgs> | null
    where?: courseWhereInput
    orderBy?: courseOrderByWithRelationInput | courseOrderByWithRelationInput[]
    cursor?: courseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * category without action
   */
  export type categoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the category
     */
    omit?: categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoryInclude<ExtArgs> | null
  }


  /**
   * Model certificate
   */

  export type AggregateCertificate = {
    _count: CertificateCountAggregateOutputType | null
    _avg: CertificateAvgAggregateOutputType | null
    _sum: CertificateSumAggregateOutputType | null
    _min: CertificateMinAggregateOutputType | null
    _max: CertificateMaxAggregateOutputType | null
  }

  export type CertificateAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
  }

  export type CertificateSumAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
  }

  export type CertificateMinAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
    filePath: string | null
    issuedAt: Date | null
  }

  export type CertificateMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
    filePath: string | null
    issuedAt: Date | null
  }

  export type CertificateCountAggregateOutputType = {
    id: number
    userId: number
    courseId: number
    filePath: number
    issuedAt: number
    _all: number
  }


  export type CertificateAvgAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
  }

  export type CertificateSumAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
  }

  export type CertificateMinAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    filePath?: true
    issuedAt?: true
  }

  export type CertificateMaxAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    filePath?: true
    issuedAt?: true
  }

  export type CertificateCountAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    filePath?: true
    issuedAt?: true
    _all?: true
  }

  export type CertificateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which certificate to aggregate.
     */
    where?: certificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of certificates to fetch.
     */
    orderBy?: certificateOrderByWithRelationInput | certificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: certificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned certificates
    **/
    _count?: true | CertificateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CertificateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CertificateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CertificateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CertificateMaxAggregateInputType
  }

  export type GetCertificateAggregateType<T extends CertificateAggregateArgs> = {
        [P in keyof T & keyof AggregateCertificate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCertificate[P]>
      : GetScalarType<T[P], AggregateCertificate[P]>
  }




  export type certificateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: certificateWhereInput
    orderBy?: certificateOrderByWithAggregationInput | certificateOrderByWithAggregationInput[]
    by: CertificateScalarFieldEnum[] | CertificateScalarFieldEnum
    having?: certificateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CertificateCountAggregateInputType | true
    _avg?: CertificateAvgAggregateInputType
    _sum?: CertificateSumAggregateInputType
    _min?: CertificateMinAggregateInputType
    _max?: CertificateMaxAggregateInputType
  }

  export type CertificateGroupByOutputType = {
    id: number
    userId: number
    courseId: number
    filePath: string
    issuedAt: Date
    _count: CertificateCountAggregateOutputType | null
    _avg: CertificateAvgAggregateOutputType | null
    _sum: CertificateSumAggregateOutputType | null
    _min: CertificateMinAggregateOutputType | null
    _max: CertificateMaxAggregateOutputType | null
  }

  type GetCertificateGroupByPayload<T extends certificateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CertificateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CertificateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CertificateGroupByOutputType[P]>
            : GetScalarType<T[P], CertificateGroupByOutputType[P]>
        }
      >
    >


  export type certificateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    filePath?: boolean
    issuedAt?: boolean
    course?: boolean | courseDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certificate"]>



  export type certificateSelectScalar = {
    id?: boolean
    userId?: boolean
    courseId?: boolean
    filePath?: boolean
    issuedAt?: boolean
  }

  export type certificateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "courseId" | "filePath" | "issuedAt", ExtArgs["result"]["certificate"]>
  export type certificateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | courseDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $certificatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "certificate"
    objects: {
      course: Prisma.$coursePayload<ExtArgs>
      users: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      courseId: number
      filePath: string
      issuedAt: Date
    }, ExtArgs["result"]["certificate"]>
    composites: {}
  }

  type certificateGetPayload<S extends boolean | null | undefined | certificateDefaultArgs> = $Result.GetResult<Prisma.$certificatePayload, S>

  type certificateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<certificateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CertificateCountAggregateInputType | true
    }

  export interface certificateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['certificate'], meta: { name: 'certificate' } }
    /**
     * Find zero or one Certificate that matches the filter.
     * @param {certificateFindUniqueArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends certificateFindUniqueArgs>(args: SelectSubset<T, certificateFindUniqueArgs<ExtArgs>>): Prisma__certificateClient<$Result.GetResult<Prisma.$certificatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Certificate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {certificateFindUniqueOrThrowArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends certificateFindUniqueOrThrowArgs>(args: SelectSubset<T, certificateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__certificateClient<$Result.GetResult<Prisma.$certificatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Certificate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certificateFindFirstArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends certificateFindFirstArgs>(args?: SelectSubset<T, certificateFindFirstArgs<ExtArgs>>): Prisma__certificateClient<$Result.GetResult<Prisma.$certificatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Certificate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certificateFindFirstOrThrowArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends certificateFindFirstOrThrowArgs>(args?: SelectSubset<T, certificateFindFirstOrThrowArgs<ExtArgs>>): Prisma__certificateClient<$Result.GetResult<Prisma.$certificatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Certificates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certificateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Certificates
     * const certificates = await prisma.certificate.findMany()
     * 
     * // Get first 10 Certificates
     * const certificates = await prisma.certificate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const certificateWithIdOnly = await prisma.certificate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends certificateFindManyArgs>(args?: SelectSubset<T, certificateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$certificatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Certificate.
     * @param {certificateCreateArgs} args - Arguments to create a Certificate.
     * @example
     * // Create one Certificate
     * const Certificate = await prisma.certificate.create({
     *   data: {
     *     // ... data to create a Certificate
     *   }
     * })
     * 
     */
    create<T extends certificateCreateArgs>(args: SelectSubset<T, certificateCreateArgs<ExtArgs>>): Prisma__certificateClient<$Result.GetResult<Prisma.$certificatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Certificates.
     * @param {certificateCreateManyArgs} args - Arguments to create many Certificates.
     * @example
     * // Create many Certificates
     * const certificate = await prisma.certificate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends certificateCreateManyArgs>(args?: SelectSubset<T, certificateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Certificate.
     * @param {certificateDeleteArgs} args - Arguments to delete one Certificate.
     * @example
     * // Delete one Certificate
     * const Certificate = await prisma.certificate.delete({
     *   where: {
     *     // ... filter to delete one Certificate
     *   }
     * })
     * 
     */
    delete<T extends certificateDeleteArgs>(args: SelectSubset<T, certificateDeleteArgs<ExtArgs>>): Prisma__certificateClient<$Result.GetResult<Prisma.$certificatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Certificate.
     * @param {certificateUpdateArgs} args - Arguments to update one Certificate.
     * @example
     * // Update one Certificate
     * const certificate = await prisma.certificate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends certificateUpdateArgs>(args: SelectSubset<T, certificateUpdateArgs<ExtArgs>>): Prisma__certificateClient<$Result.GetResult<Prisma.$certificatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Certificates.
     * @param {certificateDeleteManyArgs} args - Arguments to filter Certificates to delete.
     * @example
     * // Delete a few Certificates
     * const { count } = await prisma.certificate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends certificateDeleteManyArgs>(args?: SelectSubset<T, certificateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Certificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certificateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Certificates
     * const certificate = await prisma.certificate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends certificateUpdateManyArgs>(args: SelectSubset<T, certificateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Certificate.
     * @param {certificateUpsertArgs} args - Arguments to update or create a Certificate.
     * @example
     * // Update or create a Certificate
     * const certificate = await prisma.certificate.upsert({
     *   create: {
     *     // ... data to create a Certificate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Certificate we want to update
     *   }
     * })
     */
    upsert<T extends certificateUpsertArgs>(args: SelectSubset<T, certificateUpsertArgs<ExtArgs>>): Prisma__certificateClient<$Result.GetResult<Prisma.$certificatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Certificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certificateCountArgs} args - Arguments to filter Certificates to count.
     * @example
     * // Count the number of Certificates
     * const count = await prisma.certificate.count({
     *   where: {
     *     // ... the filter for the Certificates we want to count
     *   }
     * })
    **/
    count<T extends certificateCountArgs>(
      args?: Subset<T, certificateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CertificateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Certificate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CertificateAggregateArgs>(args: Subset<T, CertificateAggregateArgs>): Prisma.PrismaPromise<GetCertificateAggregateType<T>>

    /**
     * Group by Certificate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certificateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends certificateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: certificateGroupByArgs['orderBy'] }
        : { orderBy?: certificateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, certificateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCertificateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the certificate model
   */
  readonly fields: certificateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for certificate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__certificateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends courseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, courseDefaultArgs<ExtArgs>>): Prisma__courseClient<$Result.GetResult<Prisma.$coursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the certificate model
   */
  interface certificateFieldRefs {
    readonly id: FieldRef<"certificate", 'Int'>
    readonly userId: FieldRef<"certificate", 'Int'>
    readonly courseId: FieldRef<"certificate", 'Int'>
    readonly filePath: FieldRef<"certificate", 'String'>
    readonly issuedAt: FieldRef<"certificate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * certificate findUnique
   */
  export type certificateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificate
     */
    select?: certificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificate
     */
    omit?: certificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificateInclude<ExtArgs> | null
    /**
     * Filter, which certificate to fetch.
     */
    where: certificateWhereUniqueInput
  }

  /**
   * certificate findUniqueOrThrow
   */
  export type certificateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificate
     */
    select?: certificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificate
     */
    omit?: certificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificateInclude<ExtArgs> | null
    /**
     * Filter, which certificate to fetch.
     */
    where: certificateWhereUniqueInput
  }

  /**
   * certificate findFirst
   */
  export type certificateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificate
     */
    select?: certificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificate
     */
    omit?: certificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificateInclude<ExtArgs> | null
    /**
     * Filter, which certificate to fetch.
     */
    where?: certificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of certificates to fetch.
     */
    orderBy?: certificateOrderByWithRelationInput | certificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for certificates.
     */
    cursor?: certificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of certificates.
     */
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * certificate findFirstOrThrow
   */
  export type certificateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificate
     */
    select?: certificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificate
     */
    omit?: certificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificateInclude<ExtArgs> | null
    /**
     * Filter, which certificate to fetch.
     */
    where?: certificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of certificates to fetch.
     */
    orderBy?: certificateOrderByWithRelationInput | certificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for certificates.
     */
    cursor?: certificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of certificates.
     */
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * certificate findMany
   */
  export type certificateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificate
     */
    select?: certificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificate
     */
    omit?: certificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificateInclude<ExtArgs> | null
    /**
     * Filter, which certificates to fetch.
     */
    where?: certificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of certificates to fetch.
     */
    orderBy?: certificateOrderByWithRelationInput | certificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing certificates.
     */
    cursor?: certificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` certificates.
     */
    skip?: number
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * certificate create
   */
  export type certificateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificate
     */
    select?: certificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificate
     */
    omit?: certificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificateInclude<ExtArgs> | null
    /**
     * The data needed to create a certificate.
     */
    data: XOR<certificateCreateInput, certificateUncheckedCreateInput>
  }

  /**
   * certificate createMany
   */
  export type certificateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many certificates.
     */
    data: certificateCreateManyInput | certificateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * certificate update
   */
  export type certificateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificate
     */
    select?: certificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificate
     */
    omit?: certificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificateInclude<ExtArgs> | null
    /**
     * The data needed to update a certificate.
     */
    data: XOR<certificateUpdateInput, certificateUncheckedUpdateInput>
    /**
     * Choose, which certificate to update.
     */
    where: certificateWhereUniqueInput
  }

  /**
   * certificate updateMany
   */
  export type certificateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update certificates.
     */
    data: XOR<certificateUpdateManyMutationInput, certificateUncheckedUpdateManyInput>
    /**
     * Filter which certificates to update
     */
    where?: certificateWhereInput
    /**
     * Limit how many certificates to update.
     */
    limit?: number
  }

  /**
   * certificate upsert
   */
  export type certificateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificate
     */
    select?: certificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificate
     */
    omit?: certificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificateInclude<ExtArgs> | null
    /**
     * The filter to search for the certificate to update in case it exists.
     */
    where: certificateWhereUniqueInput
    /**
     * In case the certificate found by the `where` argument doesn't exist, create a new certificate with this data.
     */
    create: XOR<certificateCreateInput, certificateUncheckedCreateInput>
    /**
     * In case the certificate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<certificateUpdateInput, certificateUncheckedUpdateInput>
  }

  /**
   * certificate delete
   */
  export type certificateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificate
     */
    select?: certificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificate
     */
    omit?: certificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificateInclude<ExtArgs> | null
    /**
     * Filter which certificate to delete.
     */
    where: certificateWhereUniqueInput
  }

  /**
   * certificate deleteMany
   */
  export type certificateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which certificates to delete
     */
    where?: certificateWhereInput
    /**
     * Limit how many certificates to delete.
     */
    limit?: number
  }

  /**
   * certificate without action
   */
  export type certificateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificate
     */
    select?: certificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificate
     */
    omit?: certificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificateInclude<ExtArgs> | null
  }


  /**
   * Model chatmessage
   */

  export type AggregateChatmessage = {
    _count: ChatmessageCountAggregateOutputType | null
    _avg: ChatmessageAvgAggregateOutputType | null
    _sum: ChatmessageSumAggregateOutputType | null
    _min: ChatmessageMinAggregateOutputType | null
    _max: ChatmessageMaxAggregateOutputType | null
  }

  export type ChatmessageAvgAggregateOutputType = {
    id: number | null
    sessionId: number | null
    senderId: number | null
  }

  export type ChatmessageSumAggregateOutputType = {
    id: number | null
    sessionId: number | null
    senderId: number | null
  }

  export type ChatmessageMinAggregateOutputType = {
    id: number | null
    sessionId: number | null
    senderId: number | null
    message: string | null
    sentAt: Date | null
  }

  export type ChatmessageMaxAggregateOutputType = {
    id: number | null
    sessionId: number | null
    senderId: number | null
    message: string | null
    sentAt: Date | null
  }

  export type ChatmessageCountAggregateOutputType = {
    id: number
    sessionId: number
    senderId: number
    message: number
    sentAt: number
    _all: number
  }


  export type ChatmessageAvgAggregateInputType = {
    id?: true
    sessionId?: true
    senderId?: true
  }

  export type ChatmessageSumAggregateInputType = {
    id?: true
    sessionId?: true
    senderId?: true
  }

  export type ChatmessageMinAggregateInputType = {
    id?: true
    sessionId?: true
    senderId?: true
    message?: true
    sentAt?: true
  }

  export type ChatmessageMaxAggregateInputType = {
    id?: true
    sessionId?: true
    senderId?: true
    message?: true
    sentAt?: true
  }

  export type ChatmessageCountAggregateInputType = {
    id?: true
    sessionId?: true
    senderId?: true
    message?: true
    sentAt?: true
    _all?: true
  }

  export type ChatmessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chatmessage to aggregate.
     */
    where?: chatmessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chatmessages to fetch.
     */
    orderBy?: chatmessageOrderByWithRelationInput | chatmessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: chatmessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chatmessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chatmessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned chatmessages
    **/
    _count?: true | ChatmessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChatmessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChatmessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatmessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatmessageMaxAggregateInputType
  }

  export type GetChatmessageAggregateType<T extends ChatmessageAggregateArgs> = {
        [P in keyof T & keyof AggregateChatmessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatmessage[P]>
      : GetScalarType<T[P], AggregateChatmessage[P]>
  }




  export type chatmessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chatmessageWhereInput
    orderBy?: chatmessageOrderByWithAggregationInput | chatmessageOrderByWithAggregationInput[]
    by: ChatmessageScalarFieldEnum[] | ChatmessageScalarFieldEnum
    having?: chatmessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatmessageCountAggregateInputType | true
    _avg?: ChatmessageAvgAggregateInputType
    _sum?: ChatmessageSumAggregateInputType
    _min?: ChatmessageMinAggregateInputType
    _max?: ChatmessageMaxAggregateInputType
  }

  export type ChatmessageGroupByOutputType = {
    id: number
    sessionId: number
    senderId: number
    message: string
    sentAt: Date
    _count: ChatmessageCountAggregateOutputType | null
    _avg: ChatmessageAvgAggregateOutputType | null
    _sum: ChatmessageSumAggregateOutputType | null
    _min: ChatmessageMinAggregateOutputType | null
    _max: ChatmessageMaxAggregateOutputType | null
  }

  type GetChatmessageGroupByPayload<T extends chatmessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatmessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatmessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatmessageGroupByOutputType[P]>
            : GetScalarType<T[P], ChatmessageGroupByOutputType[P]>
        }
      >
    >


  export type chatmessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    senderId?: boolean
    message?: boolean
    sentAt?: boolean
    users?: boolean | UserDefaultArgs<ExtArgs>
    counselingsession?: boolean | counselingsessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatmessage"]>



  export type chatmessageSelectScalar = {
    id?: boolean
    sessionId?: boolean
    senderId?: boolean
    message?: boolean
    sentAt?: boolean
  }

  export type chatmessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "senderId" | "message" | "sentAt", ExtArgs["result"]["chatmessage"]>
  export type chatmessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UserDefaultArgs<ExtArgs>
    counselingsession?: boolean | counselingsessionDefaultArgs<ExtArgs>
  }

  export type $chatmessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "chatmessage"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>
      counselingsession: Prisma.$counselingsessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sessionId: number
      senderId: number
      message: string
      sentAt: Date
    }, ExtArgs["result"]["chatmessage"]>
    composites: {}
  }

  type chatmessageGetPayload<S extends boolean | null | undefined | chatmessageDefaultArgs> = $Result.GetResult<Prisma.$chatmessagePayload, S>

  type chatmessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<chatmessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatmessageCountAggregateInputType | true
    }

  export interface chatmessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['chatmessage'], meta: { name: 'chatmessage' } }
    /**
     * Find zero or one Chatmessage that matches the filter.
     * @param {chatmessageFindUniqueArgs} args - Arguments to find a Chatmessage
     * @example
     * // Get one Chatmessage
     * const chatmessage = await prisma.chatmessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends chatmessageFindUniqueArgs>(args: SelectSubset<T, chatmessageFindUniqueArgs<ExtArgs>>): Prisma__chatmessageClient<$Result.GetResult<Prisma.$chatmessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Chatmessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {chatmessageFindUniqueOrThrowArgs} args - Arguments to find a Chatmessage
     * @example
     * // Get one Chatmessage
     * const chatmessage = await prisma.chatmessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends chatmessageFindUniqueOrThrowArgs>(args: SelectSubset<T, chatmessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__chatmessageClient<$Result.GetResult<Prisma.$chatmessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chatmessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatmessageFindFirstArgs} args - Arguments to find a Chatmessage
     * @example
     * // Get one Chatmessage
     * const chatmessage = await prisma.chatmessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends chatmessageFindFirstArgs>(args?: SelectSubset<T, chatmessageFindFirstArgs<ExtArgs>>): Prisma__chatmessageClient<$Result.GetResult<Prisma.$chatmessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chatmessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatmessageFindFirstOrThrowArgs} args - Arguments to find a Chatmessage
     * @example
     * // Get one Chatmessage
     * const chatmessage = await prisma.chatmessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends chatmessageFindFirstOrThrowArgs>(args?: SelectSubset<T, chatmessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__chatmessageClient<$Result.GetResult<Prisma.$chatmessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Chatmessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatmessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chatmessages
     * const chatmessages = await prisma.chatmessage.findMany()
     * 
     * // Get first 10 Chatmessages
     * const chatmessages = await prisma.chatmessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatmessageWithIdOnly = await prisma.chatmessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends chatmessageFindManyArgs>(args?: SelectSubset<T, chatmessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatmessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Chatmessage.
     * @param {chatmessageCreateArgs} args - Arguments to create a Chatmessage.
     * @example
     * // Create one Chatmessage
     * const Chatmessage = await prisma.chatmessage.create({
     *   data: {
     *     // ... data to create a Chatmessage
     *   }
     * })
     * 
     */
    create<T extends chatmessageCreateArgs>(args: SelectSubset<T, chatmessageCreateArgs<ExtArgs>>): Prisma__chatmessageClient<$Result.GetResult<Prisma.$chatmessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Chatmessages.
     * @param {chatmessageCreateManyArgs} args - Arguments to create many Chatmessages.
     * @example
     * // Create many Chatmessages
     * const chatmessage = await prisma.chatmessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends chatmessageCreateManyArgs>(args?: SelectSubset<T, chatmessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Chatmessage.
     * @param {chatmessageDeleteArgs} args - Arguments to delete one Chatmessage.
     * @example
     * // Delete one Chatmessage
     * const Chatmessage = await prisma.chatmessage.delete({
     *   where: {
     *     // ... filter to delete one Chatmessage
     *   }
     * })
     * 
     */
    delete<T extends chatmessageDeleteArgs>(args: SelectSubset<T, chatmessageDeleteArgs<ExtArgs>>): Prisma__chatmessageClient<$Result.GetResult<Prisma.$chatmessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Chatmessage.
     * @param {chatmessageUpdateArgs} args - Arguments to update one Chatmessage.
     * @example
     * // Update one Chatmessage
     * const chatmessage = await prisma.chatmessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends chatmessageUpdateArgs>(args: SelectSubset<T, chatmessageUpdateArgs<ExtArgs>>): Prisma__chatmessageClient<$Result.GetResult<Prisma.$chatmessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Chatmessages.
     * @param {chatmessageDeleteManyArgs} args - Arguments to filter Chatmessages to delete.
     * @example
     * // Delete a few Chatmessages
     * const { count } = await prisma.chatmessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends chatmessageDeleteManyArgs>(args?: SelectSubset<T, chatmessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chatmessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatmessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chatmessages
     * const chatmessage = await prisma.chatmessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends chatmessageUpdateManyArgs>(args: SelectSubset<T, chatmessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Chatmessage.
     * @param {chatmessageUpsertArgs} args - Arguments to update or create a Chatmessage.
     * @example
     * // Update or create a Chatmessage
     * const chatmessage = await prisma.chatmessage.upsert({
     *   create: {
     *     // ... data to create a Chatmessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chatmessage we want to update
     *   }
     * })
     */
    upsert<T extends chatmessageUpsertArgs>(args: SelectSubset<T, chatmessageUpsertArgs<ExtArgs>>): Prisma__chatmessageClient<$Result.GetResult<Prisma.$chatmessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Chatmessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatmessageCountArgs} args - Arguments to filter Chatmessages to count.
     * @example
     * // Count the number of Chatmessages
     * const count = await prisma.chatmessage.count({
     *   where: {
     *     // ... the filter for the Chatmessages we want to count
     *   }
     * })
    **/
    count<T extends chatmessageCountArgs>(
      args?: Subset<T, chatmessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatmessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chatmessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatmessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatmessageAggregateArgs>(args: Subset<T, ChatmessageAggregateArgs>): Prisma.PrismaPromise<GetChatmessageAggregateType<T>>

    /**
     * Group by Chatmessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatmessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends chatmessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: chatmessageGroupByArgs['orderBy'] }
        : { orderBy?: chatmessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, chatmessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatmessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the chatmessage model
   */
  readonly fields: chatmessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for chatmessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__chatmessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    counselingsession<T extends counselingsessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, counselingsessionDefaultArgs<ExtArgs>>): Prisma__counselingsessionClient<$Result.GetResult<Prisma.$counselingsessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the chatmessage model
   */
  interface chatmessageFieldRefs {
    readonly id: FieldRef<"chatmessage", 'Int'>
    readonly sessionId: FieldRef<"chatmessage", 'Int'>
    readonly senderId: FieldRef<"chatmessage", 'Int'>
    readonly message: FieldRef<"chatmessage", 'String'>
    readonly sentAt: FieldRef<"chatmessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * chatmessage findUnique
   */
  export type chatmessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatmessage
     */
    select?: chatmessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatmessage
     */
    omit?: chatmessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatmessageInclude<ExtArgs> | null
    /**
     * Filter, which chatmessage to fetch.
     */
    where: chatmessageWhereUniqueInput
  }

  /**
   * chatmessage findUniqueOrThrow
   */
  export type chatmessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatmessage
     */
    select?: chatmessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatmessage
     */
    omit?: chatmessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatmessageInclude<ExtArgs> | null
    /**
     * Filter, which chatmessage to fetch.
     */
    where: chatmessageWhereUniqueInput
  }

  /**
   * chatmessage findFirst
   */
  export type chatmessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatmessage
     */
    select?: chatmessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatmessage
     */
    omit?: chatmessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatmessageInclude<ExtArgs> | null
    /**
     * Filter, which chatmessage to fetch.
     */
    where?: chatmessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chatmessages to fetch.
     */
    orderBy?: chatmessageOrderByWithRelationInput | chatmessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chatmessages.
     */
    cursor?: chatmessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chatmessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chatmessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chatmessages.
     */
    distinct?: ChatmessageScalarFieldEnum | ChatmessageScalarFieldEnum[]
  }

  /**
   * chatmessage findFirstOrThrow
   */
  export type chatmessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatmessage
     */
    select?: chatmessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatmessage
     */
    omit?: chatmessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatmessageInclude<ExtArgs> | null
    /**
     * Filter, which chatmessage to fetch.
     */
    where?: chatmessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chatmessages to fetch.
     */
    orderBy?: chatmessageOrderByWithRelationInput | chatmessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chatmessages.
     */
    cursor?: chatmessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chatmessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chatmessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chatmessages.
     */
    distinct?: ChatmessageScalarFieldEnum | ChatmessageScalarFieldEnum[]
  }

  /**
   * chatmessage findMany
   */
  export type chatmessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatmessage
     */
    select?: chatmessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatmessage
     */
    omit?: chatmessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatmessageInclude<ExtArgs> | null
    /**
     * Filter, which chatmessages to fetch.
     */
    where?: chatmessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chatmessages to fetch.
     */
    orderBy?: chatmessageOrderByWithRelationInput | chatmessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing chatmessages.
     */
    cursor?: chatmessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chatmessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chatmessages.
     */
    skip?: number
    distinct?: ChatmessageScalarFieldEnum | ChatmessageScalarFieldEnum[]
  }

  /**
   * chatmessage create
   */
  export type chatmessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatmessage
     */
    select?: chatmessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatmessage
     */
    omit?: chatmessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatmessageInclude<ExtArgs> | null
    /**
     * The data needed to create a chatmessage.
     */
    data: XOR<chatmessageCreateInput, chatmessageUncheckedCreateInput>
  }

  /**
   * chatmessage createMany
   */
  export type chatmessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many chatmessages.
     */
    data: chatmessageCreateManyInput | chatmessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * chatmessage update
   */
  export type chatmessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatmessage
     */
    select?: chatmessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatmessage
     */
    omit?: chatmessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatmessageInclude<ExtArgs> | null
    /**
     * The data needed to update a chatmessage.
     */
    data: XOR<chatmessageUpdateInput, chatmessageUncheckedUpdateInput>
    /**
     * Choose, which chatmessage to update.
     */
    where: chatmessageWhereUniqueInput
  }

  /**
   * chatmessage updateMany
   */
  export type chatmessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update chatmessages.
     */
    data: XOR<chatmessageUpdateManyMutationInput, chatmessageUncheckedUpdateManyInput>
    /**
     * Filter which chatmessages to update
     */
    where?: chatmessageWhereInput
    /**
     * Limit how many chatmessages to update.
     */
    limit?: number
  }

  /**
   * chatmessage upsert
   */
  export type chatmessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatmessage
     */
    select?: chatmessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatmessage
     */
    omit?: chatmessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatmessageInclude<ExtArgs> | null
    /**
     * The filter to search for the chatmessage to update in case it exists.
     */
    where: chatmessageWhereUniqueInput
    /**
     * In case the chatmessage found by the `where` argument doesn't exist, create a new chatmessage with this data.
     */
    create: XOR<chatmessageCreateInput, chatmessageUncheckedCreateInput>
    /**
     * In case the chatmessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<chatmessageUpdateInput, chatmessageUncheckedUpdateInput>
  }

  /**
   * chatmessage delete
   */
  export type chatmessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatmessage
     */
    select?: chatmessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatmessage
     */
    omit?: chatmessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatmessageInclude<ExtArgs> | null
    /**
     * Filter which chatmessage to delete.
     */
    where: chatmessageWhereUniqueInput
  }

  /**
   * chatmessage deleteMany
   */
  export type chatmessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chatmessages to delete
     */
    where?: chatmessageWhereInput
    /**
     * Limit how many chatmessages to delete.
     */
    limit?: number
  }

  /**
   * chatmessage without action
   */
  export type chatmessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatmessage
     */
    select?: chatmessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatmessage
     */
    omit?: chatmessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatmessageInclude<ExtArgs> | null
  }


  /**
   * Model counselingsession
   */

  export type AggregateCounselingsession = {
    _count: CounselingsessionCountAggregateOutputType | null
    _avg: CounselingsessionAvgAggregateOutputType | null
    _sum: CounselingsessionSumAggregateOutputType | null
    _min: CounselingsessionMinAggregateOutputType | null
    _max: CounselingsessionMaxAggregateOutputType | null
  }

  export type CounselingsessionAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    counselorId: number | null
    rating: number | null
  }

  export type CounselingsessionSumAggregateOutputType = {
    id: number | null
    userId: number | null
    counselorId: number | null
    rating: number | null
  }

  export type CounselingsessionMinAggregateOutputType = {
    id: number | null
    userId: number | null
    counselorId: number | null
    topic: string | null
    question: string | null
    response: string | null
    status: string | null
    createdAt: Date | null
    rating: number | null
    feedback: string | null
  }

  export type CounselingsessionMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    counselorId: number | null
    topic: string | null
    question: string | null
    response: string | null
    status: string | null
    createdAt: Date | null
    rating: number | null
    feedback: string | null
  }

  export type CounselingsessionCountAggregateOutputType = {
    id: number
    userId: number
    counselorId: number
    topic: number
    question: number
    response: number
    status: number
    createdAt: number
    rating: number
    feedback: number
    _all: number
  }


  export type CounselingsessionAvgAggregateInputType = {
    id?: true
    userId?: true
    counselorId?: true
    rating?: true
  }

  export type CounselingsessionSumAggregateInputType = {
    id?: true
    userId?: true
    counselorId?: true
    rating?: true
  }

  export type CounselingsessionMinAggregateInputType = {
    id?: true
    userId?: true
    counselorId?: true
    topic?: true
    question?: true
    response?: true
    status?: true
    createdAt?: true
    rating?: true
    feedback?: true
  }

  export type CounselingsessionMaxAggregateInputType = {
    id?: true
    userId?: true
    counselorId?: true
    topic?: true
    question?: true
    response?: true
    status?: true
    createdAt?: true
    rating?: true
    feedback?: true
  }

  export type CounselingsessionCountAggregateInputType = {
    id?: true
    userId?: true
    counselorId?: true
    topic?: true
    question?: true
    response?: true
    status?: true
    createdAt?: true
    rating?: true
    feedback?: true
    _all?: true
  }

  export type CounselingsessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which counselingsession to aggregate.
     */
    where?: counselingsessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of counselingsessions to fetch.
     */
    orderBy?: counselingsessionOrderByWithRelationInput | counselingsessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: counselingsessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` counselingsessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` counselingsessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned counselingsessions
    **/
    _count?: true | CounselingsessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CounselingsessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CounselingsessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CounselingsessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CounselingsessionMaxAggregateInputType
  }

  export type GetCounselingsessionAggregateType<T extends CounselingsessionAggregateArgs> = {
        [P in keyof T & keyof AggregateCounselingsession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCounselingsession[P]>
      : GetScalarType<T[P], AggregateCounselingsession[P]>
  }




  export type counselingsessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: counselingsessionWhereInput
    orderBy?: counselingsessionOrderByWithAggregationInput | counselingsessionOrderByWithAggregationInput[]
    by: CounselingsessionScalarFieldEnum[] | CounselingsessionScalarFieldEnum
    having?: counselingsessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CounselingsessionCountAggregateInputType | true
    _avg?: CounselingsessionAvgAggregateInputType
    _sum?: CounselingsessionSumAggregateInputType
    _min?: CounselingsessionMinAggregateInputType
    _max?: CounselingsessionMaxAggregateInputType
  }

  export type CounselingsessionGroupByOutputType = {
    id: number
    userId: number
    counselorId: number
    topic: string
    question: string
    response: string | null
    status: string
    createdAt: Date
    rating: number | null
    feedback: string | null
    _count: CounselingsessionCountAggregateOutputType | null
    _avg: CounselingsessionAvgAggregateOutputType | null
    _sum: CounselingsessionSumAggregateOutputType | null
    _min: CounselingsessionMinAggregateOutputType | null
    _max: CounselingsessionMaxAggregateOutputType | null
  }

  type GetCounselingsessionGroupByPayload<T extends counselingsessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CounselingsessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CounselingsessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CounselingsessionGroupByOutputType[P]>
            : GetScalarType<T[P], CounselingsessionGroupByOutputType[P]>
        }
      >
    >


  export type counselingsessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    counselorId?: boolean
    topic?: boolean
    question?: boolean
    response?: boolean
    status?: boolean
    createdAt?: boolean
    rating?: boolean
    feedback?: boolean
    chatmessage?: boolean | counselingsession$chatmessageArgs<ExtArgs>
    counselor?: boolean | counselorDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | CounselingsessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["counselingsession"]>



  export type counselingsessionSelectScalar = {
    id?: boolean
    userId?: boolean
    counselorId?: boolean
    topic?: boolean
    question?: boolean
    response?: boolean
    status?: boolean
    createdAt?: boolean
    rating?: boolean
    feedback?: boolean
  }

  export type counselingsessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "counselorId" | "topic" | "question" | "response" | "status" | "createdAt" | "rating" | "feedback", ExtArgs["result"]["counselingsession"]>
  export type counselingsessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chatmessage?: boolean | counselingsession$chatmessageArgs<ExtArgs>
    counselor?: boolean | counselorDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | CounselingsessionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $counselingsessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "counselingsession"
    objects: {
      chatmessage: Prisma.$chatmessagePayload<ExtArgs>[]
      counselor: Prisma.$counselorPayload<ExtArgs>
      users: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      counselorId: number
      topic: string
      question: string
      response: string | null
      status: string
      createdAt: Date
      rating: number | null
      feedback: string | null
    }, ExtArgs["result"]["counselingsession"]>
    composites: {}
  }

  type counselingsessionGetPayload<S extends boolean | null | undefined | counselingsessionDefaultArgs> = $Result.GetResult<Prisma.$counselingsessionPayload, S>

  type counselingsessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<counselingsessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CounselingsessionCountAggregateInputType | true
    }

  export interface counselingsessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['counselingsession'], meta: { name: 'counselingsession' } }
    /**
     * Find zero or one Counselingsession that matches the filter.
     * @param {counselingsessionFindUniqueArgs} args - Arguments to find a Counselingsession
     * @example
     * // Get one Counselingsession
     * const counselingsession = await prisma.counselingsession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends counselingsessionFindUniqueArgs>(args: SelectSubset<T, counselingsessionFindUniqueArgs<ExtArgs>>): Prisma__counselingsessionClient<$Result.GetResult<Prisma.$counselingsessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Counselingsession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {counselingsessionFindUniqueOrThrowArgs} args - Arguments to find a Counselingsession
     * @example
     * // Get one Counselingsession
     * const counselingsession = await prisma.counselingsession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends counselingsessionFindUniqueOrThrowArgs>(args: SelectSubset<T, counselingsessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__counselingsessionClient<$Result.GetResult<Prisma.$counselingsessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Counselingsession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {counselingsessionFindFirstArgs} args - Arguments to find a Counselingsession
     * @example
     * // Get one Counselingsession
     * const counselingsession = await prisma.counselingsession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends counselingsessionFindFirstArgs>(args?: SelectSubset<T, counselingsessionFindFirstArgs<ExtArgs>>): Prisma__counselingsessionClient<$Result.GetResult<Prisma.$counselingsessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Counselingsession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {counselingsessionFindFirstOrThrowArgs} args - Arguments to find a Counselingsession
     * @example
     * // Get one Counselingsession
     * const counselingsession = await prisma.counselingsession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends counselingsessionFindFirstOrThrowArgs>(args?: SelectSubset<T, counselingsessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__counselingsessionClient<$Result.GetResult<Prisma.$counselingsessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Counselingsessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {counselingsessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Counselingsessions
     * const counselingsessions = await prisma.counselingsession.findMany()
     * 
     * // Get first 10 Counselingsessions
     * const counselingsessions = await prisma.counselingsession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const counselingsessionWithIdOnly = await prisma.counselingsession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends counselingsessionFindManyArgs>(args?: SelectSubset<T, counselingsessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$counselingsessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Counselingsession.
     * @param {counselingsessionCreateArgs} args - Arguments to create a Counselingsession.
     * @example
     * // Create one Counselingsession
     * const Counselingsession = await prisma.counselingsession.create({
     *   data: {
     *     // ... data to create a Counselingsession
     *   }
     * })
     * 
     */
    create<T extends counselingsessionCreateArgs>(args: SelectSubset<T, counselingsessionCreateArgs<ExtArgs>>): Prisma__counselingsessionClient<$Result.GetResult<Prisma.$counselingsessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Counselingsessions.
     * @param {counselingsessionCreateManyArgs} args - Arguments to create many Counselingsessions.
     * @example
     * // Create many Counselingsessions
     * const counselingsession = await prisma.counselingsession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends counselingsessionCreateManyArgs>(args?: SelectSubset<T, counselingsessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Counselingsession.
     * @param {counselingsessionDeleteArgs} args - Arguments to delete one Counselingsession.
     * @example
     * // Delete one Counselingsession
     * const Counselingsession = await prisma.counselingsession.delete({
     *   where: {
     *     // ... filter to delete one Counselingsession
     *   }
     * })
     * 
     */
    delete<T extends counselingsessionDeleteArgs>(args: SelectSubset<T, counselingsessionDeleteArgs<ExtArgs>>): Prisma__counselingsessionClient<$Result.GetResult<Prisma.$counselingsessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Counselingsession.
     * @param {counselingsessionUpdateArgs} args - Arguments to update one Counselingsession.
     * @example
     * // Update one Counselingsession
     * const counselingsession = await prisma.counselingsession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends counselingsessionUpdateArgs>(args: SelectSubset<T, counselingsessionUpdateArgs<ExtArgs>>): Prisma__counselingsessionClient<$Result.GetResult<Prisma.$counselingsessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Counselingsessions.
     * @param {counselingsessionDeleteManyArgs} args - Arguments to filter Counselingsessions to delete.
     * @example
     * // Delete a few Counselingsessions
     * const { count } = await prisma.counselingsession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends counselingsessionDeleteManyArgs>(args?: SelectSubset<T, counselingsessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Counselingsessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {counselingsessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Counselingsessions
     * const counselingsession = await prisma.counselingsession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends counselingsessionUpdateManyArgs>(args: SelectSubset<T, counselingsessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Counselingsession.
     * @param {counselingsessionUpsertArgs} args - Arguments to update or create a Counselingsession.
     * @example
     * // Update or create a Counselingsession
     * const counselingsession = await prisma.counselingsession.upsert({
     *   create: {
     *     // ... data to create a Counselingsession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Counselingsession we want to update
     *   }
     * })
     */
    upsert<T extends counselingsessionUpsertArgs>(args: SelectSubset<T, counselingsessionUpsertArgs<ExtArgs>>): Prisma__counselingsessionClient<$Result.GetResult<Prisma.$counselingsessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Counselingsessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {counselingsessionCountArgs} args - Arguments to filter Counselingsessions to count.
     * @example
     * // Count the number of Counselingsessions
     * const count = await prisma.counselingsession.count({
     *   where: {
     *     // ... the filter for the Counselingsessions we want to count
     *   }
     * })
    **/
    count<T extends counselingsessionCountArgs>(
      args?: Subset<T, counselingsessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CounselingsessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Counselingsession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CounselingsessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CounselingsessionAggregateArgs>(args: Subset<T, CounselingsessionAggregateArgs>): Prisma.PrismaPromise<GetCounselingsessionAggregateType<T>>

    /**
     * Group by Counselingsession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {counselingsessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends counselingsessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: counselingsessionGroupByArgs['orderBy'] }
        : { orderBy?: counselingsessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, counselingsessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCounselingsessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the counselingsession model
   */
  readonly fields: counselingsessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for counselingsession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__counselingsessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chatmessage<T extends counselingsession$chatmessageArgs<ExtArgs> = {}>(args?: Subset<T, counselingsession$chatmessageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatmessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    counselor<T extends counselorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, counselorDefaultArgs<ExtArgs>>): Prisma__counselorClient<$Result.GetResult<Prisma.$counselorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the counselingsession model
   */
  interface counselingsessionFieldRefs {
    readonly id: FieldRef<"counselingsession", 'Int'>
    readonly userId: FieldRef<"counselingsession", 'Int'>
    readonly counselorId: FieldRef<"counselingsession", 'Int'>
    readonly topic: FieldRef<"counselingsession", 'String'>
    readonly question: FieldRef<"counselingsession", 'String'>
    readonly response: FieldRef<"counselingsession", 'String'>
    readonly status: FieldRef<"counselingsession", 'String'>
    readonly createdAt: FieldRef<"counselingsession", 'DateTime'>
    readonly rating: FieldRef<"counselingsession", 'Int'>
    readonly feedback: FieldRef<"counselingsession", 'String'>
  }
    

  // Custom InputTypes
  /**
   * counselingsession findUnique
   */
  export type counselingsessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counselingsession
     */
    select?: counselingsessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the counselingsession
     */
    omit?: counselingsessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: counselingsessionInclude<ExtArgs> | null
    /**
     * Filter, which counselingsession to fetch.
     */
    where: counselingsessionWhereUniqueInput
  }

  /**
   * counselingsession findUniqueOrThrow
   */
  export type counselingsessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counselingsession
     */
    select?: counselingsessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the counselingsession
     */
    omit?: counselingsessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: counselingsessionInclude<ExtArgs> | null
    /**
     * Filter, which counselingsession to fetch.
     */
    where: counselingsessionWhereUniqueInput
  }

  /**
   * counselingsession findFirst
   */
  export type counselingsessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counselingsession
     */
    select?: counselingsessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the counselingsession
     */
    omit?: counselingsessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: counselingsessionInclude<ExtArgs> | null
    /**
     * Filter, which counselingsession to fetch.
     */
    where?: counselingsessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of counselingsessions to fetch.
     */
    orderBy?: counselingsessionOrderByWithRelationInput | counselingsessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for counselingsessions.
     */
    cursor?: counselingsessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` counselingsessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` counselingsessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of counselingsessions.
     */
    distinct?: CounselingsessionScalarFieldEnum | CounselingsessionScalarFieldEnum[]
  }

  /**
   * counselingsession findFirstOrThrow
   */
  export type counselingsessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counselingsession
     */
    select?: counselingsessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the counselingsession
     */
    omit?: counselingsessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: counselingsessionInclude<ExtArgs> | null
    /**
     * Filter, which counselingsession to fetch.
     */
    where?: counselingsessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of counselingsessions to fetch.
     */
    orderBy?: counselingsessionOrderByWithRelationInput | counselingsessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for counselingsessions.
     */
    cursor?: counselingsessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` counselingsessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` counselingsessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of counselingsessions.
     */
    distinct?: CounselingsessionScalarFieldEnum | CounselingsessionScalarFieldEnum[]
  }

  /**
   * counselingsession findMany
   */
  export type counselingsessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counselingsession
     */
    select?: counselingsessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the counselingsession
     */
    omit?: counselingsessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: counselingsessionInclude<ExtArgs> | null
    /**
     * Filter, which counselingsessions to fetch.
     */
    where?: counselingsessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of counselingsessions to fetch.
     */
    orderBy?: counselingsessionOrderByWithRelationInput | counselingsessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing counselingsessions.
     */
    cursor?: counselingsessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` counselingsessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` counselingsessions.
     */
    skip?: number
    distinct?: CounselingsessionScalarFieldEnum | CounselingsessionScalarFieldEnum[]
  }

  /**
   * counselingsession create
   */
  export type counselingsessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counselingsession
     */
    select?: counselingsessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the counselingsession
     */
    omit?: counselingsessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: counselingsessionInclude<ExtArgs> | null
    /**
     * The data needed to create a counselingsession.
     */
    data: XOR<counselingsessionCreateInput, counselingsessionUncheckedCreateInput>
  }

  /**
   * counselingsession createMany
   */
  export type counselingsessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many counselingsessions.
     */
    data: counselingsessionCreateManyInput | counselingsessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * counselingsession update
   */
  export type counselingsessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counselingsession
     */
    select?: counselingsessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the counselingsession
     */
    omit?: counselingsessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: counselingsessionInclude<ExtArgs> | null
    /**
     * The data needed to update a counselingsession.
     */
    data: XOR<counselingsessionUpdateInput, counselingsessionUncheckedUpdateInput>
    /**
     * Choose, which counselingsession to update.
     */
    where: counselingsessionWhereUniqueInput
  }

  /**
   * counselingsession updateMany
   */
  export type counselingsessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update counselingsessions.
     */
    data: XOR<counselingsessionUpdateManyMutationInput, counselingsessionUncheckedUpdateManyInput>
    /**
     * Filter which counselingsessions to update
     */
    where?: counselingsessionWhereInput
    /**
     * Limit how many counselingsessions to update.
     */
    limit?: number
  }

  /**
   * counselingsession upsert
   */
  export type counselingsessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counselingsession
     */
    select?: counselingsessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the counselingsession
     */
    omit?: counselingsessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: counselingsessionInclude<ExtArgs> | null
    /**
     * The filter to search for the counselingsession to update in case it exists.
     */
    where: counselingsessionWhereUniqueInput
    /**
     * In case the counselingsession found by the `where` argument doesn't exist, create a new counselingsession with this data.
     */
    create: XOR<counselingsessionCreateInput, counselingsessionUncheckedCreateInput>
    /**
     * In case the counselingsession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<counselingsessionUpdateInput, counselingsessionUncheckedUpdateInput>
  }

  /**
   * counselingsession delete
   */
  export type counselingsessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counselingsession
     */
    select?: counselingsessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the counselingsession
     */
    omit?: counselingsessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: counselingsessionInclude<ExtArgs> | null
    /**
     * Filter which counselingsession to delete.
     */
    where: counselingsessionWhereUniqueInput
  }

  /**
   * counselingsession deleteMany
   */
  export type counselingsessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which counselingsessions to delete
     */
    where?: counselingsessionWhereInput
    /**
     * Limit how many counselingsessions to delete.
     */
    limit?: number
  }

  /**
   * counselingsession.chatmessage
   */
  export type counselingsession$chatmessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatmessage
     */
    select?: chatmessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatmessage
     */
    omit?: chatmessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatmessageInclude<ExtArgs> | null
    where?: chatmessageWhereInput
    orderBy?: chatmessageOrderByWithRelationInput | chatmessageOrderByWithRelationInput[]
    cursor?: chatmessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatmessageScalarFieldEnum | ChatmessageScalarFieldEnum[]
  }

  /**
   * counselingsession without action
   */
  export type counselingsessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counselingsession
     */
    select?: counselingsessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the counselingsession
     */
    omit?: counselingsessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: counselingsessionInclude<ExtArgs> | null
  }


  /**
   * Model counselor
   */

  export type AggregateCounselor = {
    _count: CounselorCountAggregateOutputType | null
    _avg: CounselorAvgAggregateOutputType | null
    _sum: CounselorSumAggregateOutputType | null
    _min: CounselorMinAggregateOutputType | null
    _max: CounselorMaxAggregateOutputType | null
  }

  export type CounselorAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type CounselorSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type CounselorMinAggregateOutputType = {
    id: number | null
    userId: number | null
    specialization: string | null
    bio: string | null
    verified: boolean | null
  }

  export type CounselorMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    specialization: string | null
    bio: string | null
    verified: boolean | null
  }

  export type CounselorCountAggregateOutputType = {
    id: number
    userId: number
    specialization: number
    bio: number
    verified: number
    _all: number
  }


  export type CounselorAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type CounselorSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type CounselorMinAggregateInputType = {
    id?: true
    userId?: true
    specialization?: true
    bio?: true
    verified?: true
  }

  export type CounselorMaxAggregateInputType = {
    id?: true
    userId?: true
    specialization?: true
    bio?: true
    verified?: true
  }

  export type CounselorCountAggregateInputType = {
    id?: true
    userId?: true
    specialization?: true
    bio?: true
    verified?: true
    _all?: true
  }

  export type CounselorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which counselor to aggregate.
     */
    where?: counselorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of counselors to fetch.
     */
    orderBy?: counselorOrderByWithRelationInput | counselorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: counselorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` counselors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` counselors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned counselors
    **/
    _count?: true | CounselorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CounselorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CounselorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CounselorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CounselorMaxAggregateInputType
  }

  export type GetCounselorAggregateType<T extends CounselorAggregateArgs> = {
        [P in keyof T & keyof AggregateCounselor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCounselor[P]>
      : GetScalarType<T[P], AggregateCounselor[P]>
  }




  export type counselorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: counselorWhereInput
    orderBy?: counselorOrderByWithAggregationInput | counselorOrderByWithAggregationInput[]
    by: CounselorScalarFieldEnum[] | CounselorScalarFieldEnum
    having?: counselorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CounselorCountAggregateInputType | true
    _avg?: CounselorAvgAggregateInputType
    _sum?: CounselorSumAggregateInputType
    _min?: CounselorMinAggregateInputType
    _max?: CounselorMaxAggregateInputType
  }

  export type CounselorGroupByOutputType = {
    id: number
    userId: number
    specialization: string
    bio: string
    verified: boolean
    _count: CounselorCountAggregateOutputType | null
    _avg: CounselorAvgAggregateOutputType | null
    _sum: CounselorSumAggregateOutputType | null
    _min: CounselorMinAggregateOutputType | null
    _max: CounselorMaxAggregateOutputType | null
  }

  type GetCounselorGroupByPayload<T extends counselorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CounselorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CounselorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CounselorGroupByOutputType[P]>
            : GetScalarType<T[P], CounselorGroupByOutputType[P]>
        }
      >
    >


  export type counselorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    specialization?: boolean
    bio?: boolean
    verified?: boolean
    counselingsession?: boolean | counselor$counselingsessionArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | CounselorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["counselor"]>



  export type counselorSelectScalar = {
    id?: boolean
    userId?: boolean
    specialization?: boolean
    bio?: boolean
    verified?: boolean
  }

  export type counselorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "specialization" | "bio" | "verified", ExtArgs["result"]["counselor"]>
  export type counselorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    counselingsession?: boolean | counselor$counselingsessionArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | CounselorCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $counselorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "counselor"
    objects: {
      counselingsession: Prisma.$counselingsessionPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      specialization: string
      bio: string
      verified: boolean
    }, ExtArgs["result"]["counselor"]>
    composites: {}
  }

  type counselorGetPayload<S extends boolean | null | undefined | counselorDefaultArgs> = $Result.GetResult<Prisma.$counselorPayload, S>

  type counselorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<counselorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CounselorCountAggregateInputType | true
    }

  export interface counselorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['counselor'], meta: { name: 'counselor' } }
    /**
     * Find zero or one Counselor that matches the filter.
     * @param {counselorFindUniqueArgs} args - Arguments to find a Counselor
     * @example
     * // Get one Counselor
     * const counselor = await prisma.counselor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends counselorFindUniqueArgs>(args: SelectSubset<T, counselorFindUniqueArgs<ExtArgs>>): Prisma__counselorClient<$Result.GetResult<Prisma.$counselorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Counselor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {counselorFindUniqueOrThrowArgs} args - Arguments to find a Counselor
     * @example
     * // Get one Counselor
     * const counselor = await prisma.counselor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends counselorFindUniqueOrThrowArgs>(args: SelectSubset<T, counselorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__counselorClient<$Result.GetResult<Prisma.$counselorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Counselor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {counselorFindFirstArgs} args - Arguments to find a Counselor
     * @example
     * // Get one Counselor
     * const counselor = await prisma.counselor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends counselorFindFirstArgs>(args?: SelectSubset<T, counselorFindFirstArgs<ExtArgs>>): Prisma__counselorClient<$Result.GetResult<Prisma.$counselorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Counselor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {counselorFindFirstOrThrowArgs} args - Arguments to find a Counselor
     * @example
     * // Get one Counselor
     * const counselor = await prisma.counselor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends counselorFindFirstOrThrowArgs>(args?: SelectSubset<T, counselorFindFirstOrThrowArgs<ExtArgs>>): Prisma__counselorClient<$Result.GetResult<Prisma.$counselorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Counselors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {counselorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Counselors
     * const counselors = await prisma.counselor.findMany()
     * 
     * // Get first 10 Counselors
     * const counselors = await prisma.counselor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const counselorWithIdOnly = await prisma.counselor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends counselorFindManyArgs>(args?: SelectSubset<T, counselorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$counselorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Counselor.
     * @param {counselorCreateArgs} args - Arguments to create a Counselor.
     * @example
     * // Create one Counselor
     * const Counselor = await prisma.counselor.create({
     *   data: {
     *     // ... data to create a Counselor
     *   }
     * })
     * 
     */
    create<T extends counselorCreateArgs>(args: SelectSubset<T, counselorCreateArgs<ExtArgs>>): Prisma__counselorClient<$Result.GetResult<Prisma.$counselorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Counselors.
     * @param {counselorCreateManyArgs} args - Arguments to create many Counselors.
     * @example
     * // Create many Counselors
     * const counselor = await prisma.counselor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends counselorCreateManyArgs>(args?: SelectSubset<T, counselorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Counselor.
     * @param {counselorDeleteArgs} args - Arguments to delete one Counselor.
     * @example
     * // Delete one Counselor
     * const Counselor = await prisma.counselor.delete({
     *   where: {
     *     // ... filter to delete one Counselor
     *   }
     * })
     * 
     */
    delete<T extends counselorDeleteArgs>(args: SelectSubset<T, counselorDeleteArgs<ExtArgs>>): Prisma__counselorClient<$Result.GetResult<Prisma.$counselorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Counselor.
     * @param {counselorUpdateArgs} args - Arguments to update one Counselor.
     * @example
     * // Update one Counselor
     * const counselor = await prisma.counselor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends counselorUpdateArgs>(args: SelectSubset<T, counselorUpdateArgs<ExtArgs>>): Prisma__counselorClient<$Result.GetResult<Prisma.$counselorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Counselors.
     * @param {counselorDeleteManyArgs} args - Arguments to filter Counselors to delete.
     * @example
     * // Delete a few Counselors
     * const { count } = await prisma.counselor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends counselorDeleteManyArgs>(args?: SelectSubset<T, counselorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Counselors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {counselorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Counselors
     * const counselor = await prisma.counselor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends counselorUpdateManyArgs>(args: SelectSubset<T, counselorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Counselor.
     * @param {counselorUpsertArgs} args - Arguments to update or create a Counselor.
     * @example
     * // Update or create a Counselor
     * const counselor = await prisma.counselor.upsert({
     *   create: {
     *     // ... data to create a Counselor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Counselor we want to update
     *   }
     * })
     */
    upsert<T extends counselorUpsertArgs>(args: SelectSubset<T, counselorUpsertArgs<ExtArgs>>): Prisma__counselorClient<$Result.GetResult<Prisma.$counselorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Counselors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {counselorCountArgs} args - Arguments to filter Counselors to count.
     * @example
     * // Count the number of Counselors
     * const count = await prisma.counselor.count({
     *   where: {
     *     // ... the filter for the Counselors we want to count
     *   }
     * })
    **/
    count<T extends counselorCountArgs>(
      args?: Subset<T, counselorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CounselorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Counselor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CounselorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CounselorAggregateArgs>(args: Subset<T, CounselorAggregateArgs>): Prisma.PrismaPromise<GetCounselorAggregateType<T>>

    /**
     * Group by Counselor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {counselorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends counselorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: counselorGroupByArgs['orderBy'] }
        : { orderBy?: counselorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, counselorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCounselorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the counselor model
   */
  readonly fields: counselorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for counselor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__counselorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    counselingsession<T extends counselor$counselingsessionArgs<ExtArgs> = {}>(args?: Subset<T, counselor$counselingsessionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$counselingsessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the counselor model
   */
  interface counselorFieldRefs {
    readonly id: FieldRef<"counselor", 'Int'>
    readonly userId: FieldRef<"counselor", 'Int'>
    readonly specialization: FieldRef<"counselor", 'String'>
    readonly bio: FieldRef<"counselor", 'String'>
    readonly verified: FieldRef<"counselor", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * counselor findUnique
   */
  export type counselorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counselor
     */
    select?: counselorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the counselor
     */
    omit?: counselorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: counselorInclude<ExtArgs> | null
    /**
     * Filter, which counselor to fetch.
     */
    where: counselorWhereUniqueInput
  }

  /**
   * counselor findUniqueOrThrow
   */
  export type counselorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counselor
     */
    select?: counselorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the counselor
     */
    omit?: counselorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: counselorInclude<ExtArgs> | null
    /**
     * Filter, which counselor to fetch.
     */
    where: counselorWhereUniqueInput
  }

  /**
   * counselor findFirst
   */
  export type counselorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counselor
     */
    select?: counselorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the counselor
     */
    omit?: counselorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: counselorInclude<ExtArgs> | null
    /**
     * Filter, which counselor to fetch.
     */
    where?: counselorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of counselors to fetch.
     */
    orderBy?: counselorOrderByWithRelationInput | counselorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for counselors.
     */
    cursor?: counselorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` counselors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` counselors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of counselors.
     */
    distinct?: CounselorScalarFieldEnum | CounselorScalarFieldEnum[]
  }

  /**
   * counselor findFirstOrThrow
   */
  export type counselorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counselor
     */
    select?: counselorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the counselor
     */
    omit?: counselorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: counselorInclude<ExtArgs> | null
    /**
     * Filter, which counselor to fetch.
     */
    where?: counselorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of counselors to fetch.
     */
    orderBy?: counselorOrderByWithRelationInput | counselorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for counselors.
     */
    cursor?: counselorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` counselors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` counselors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of counselors.
     */
    distinct?: CounselorScalarFieldEnum | CounselorScalarFieldEnum[]
  }

  /**
   * counselor findMany
   */
  export type counselorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counselor
     */
    select?: counselorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the counselor
     */
    omit?: counselorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: counselorInclude<ExtArgs> | null
    /**
     * Filter, which counselors to fetch.
     */
    where?: counselorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of counselors to fetch.
     */
    orderBy?: counselorOrderByWithRelationInput | counselorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing counselors.
     */
    cursor?: counselorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` counselors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` counselors.
     */
    skip?: number
    distinct?: CounselorScalarFieldEnum | CounselorScalarFieldEnum[]
  }

  /**
   * counselor create
   */
  export type counselorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counselor
     */
    select?: counselorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the counselor
     */
    omit?: counselorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: counselorInclude<ExtArgs> | null
    /**
     * The data needed to create a counselor.
     */
    data: XOR<counselorCreateInput, counselorUncheckedCreateInput>
  }

  /**
   * counselor createMany
   */
  export type counselorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many counselors.
     */
    data: counselorCreateManyInput | counselorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * counselor update
   */
  export type counselorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counselor
     */
    select?: counselorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the counselor
     */
    omit?: counselorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: counselorInclude<ExtArgs> | null
    /**
     * The data needed to update a counselor.
     */
    data: XOR<counselorUpdateInput, counselorUncheckedUpdateInput>
    /**
     * Choose, which counselor to update.
     */
    where: counselorWhereUniqueInput
  }

  /**
   * counselor updateMany
   */
  export type counselorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update counselors.
     */
    data: XOR<counselorUpdateManyMutationInput, counselorUncheckedUpdateManyInput>
    /**
     * Filter which counselors to update
     */
    where?: counselorWhereInput
    /**
     * Limit how many counselors to update.
     */
    limit?: number
  }

  /**
   * counselor upsert
   */
  export type counselorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counselor
     */
    select?: counselorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the counselor
     */
    omit?: counselorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: counselorInclude<ExtArgs> | null
    /**
     * The filter to search for the counselor to update in case it exists.
     */
    where: counselorWhereUniqueInput
    /**
     * In case the counselor found by the `where` argument doesn't exist, create a new counselor with this data.
     */
    create: XOR<counselorCreateInput, counselorUncheckedCreateInput>
    /**
     * In case the counselor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<counselorUpdateInput, counselorUncheckedUpdateInput>
  }

  /**
   * counselor delete
   */
  export type counselorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counselor
     */
    select?: counselorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the counselor
     */
    omit?: counselorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: counselorInclude<ExtArgs> | null
    /**
     * Filter which counselor to delete.
     */
    where: counselorWhereUniqueInput
  }

  /**
   * counselor deleteMany
   */
  export type counselorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which counselors to delete
     */
    where?: counselorWhereInput
    /**
     * Limit how many counselors to delete.
     */
    limit?: number
  }

  /**
   * counselor.counselingsession
   */
  export type counselor$counselingsessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counselingsession
     */
    select?: counselingsessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the counselingsession
     */
    omit?: counselingsessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: counselingsessionInclude<ExtArgs> | null
    where?: counselingsessionWhereInput
    orderBy?: counselingsessionOrderByWithRelationInput | counselingsessionOrderByWithRelationInput[]
    cursor?: counselingsessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CounselingsessionScalarFieldEnum | CounselingsessionScalarFieldEnum[]
  }

  /**
   * counselor without action
   */
  export type counselorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the counselor
     */
    select?: counselorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the counselor
     */
    omit?: counselorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: counselorInclude<ExtArgs> | null
  }


  /**
   * Model course
   */

  export type AggregateCourse = {
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  export type CourseAvgAggregateOutputType = {
    id: number | null
    categoryId: number | null
    price: number | null
    createdById: number | null
  }

  export type CourseSumAggregateOutputType = {
    id: number | null
    categoryId: number | null
    price: number | null
    createdById: number | null
  }

  export type CourseMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    thumbnail: string | null
    categoryId: number | null
    isPaid: boolean | null
    price: number | null
    createdById: number | null
    createdAt: Date | null
  }

  export type CourseMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    thumbnail: string | null
    categoryId: number | null
    isPaid: boolean | null
    price: number | null
    createdById: number | null
    createdAt: Date | null
  }

  export type CourseCountAggregateOutputType = {
    id: number
    title: number
    description: number
    thumbnail: number
    categoryId: number
    isPaid: number
    price: number
    createdById: number
    createdAt: number
    _all: number
  }


  export type CourseAvgAggregateInputType = {
    id?: true
    categoryId?: true
    price?: true
    createdById?: true
  }

  export type CourseSumAggregateInputType = {
    id?: true
    categoryId?: true
    price?: true
    createdById?: true
  }

  export type CourseMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    thumbnail?: true
    categoryId?: true
    isPaid?: true
    price?: true
    createdById?: true
    createdAt?: true
  }

  export type CourseMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    thumbnail?: true
    categoryId?: true
    isPaid?: true
    price?: true
    createdById?: true
    createdAt?: true
  }

  export type CourseCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    thumbnail?: true
    categoryId?: true
    isPaid?: true
    price?: true
    createdById?: true
    createdAt?: true
    _all?: true
  }

  export type CourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which course to aggregate.
     */
    where?: courseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of courses to fetch.
     */
    orderBy?: courseOrderByWithRelationInput | courseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: courseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned courses
    **/
    _count?: true | CourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseMaxAggregateInputType
  }

  export type GetCourseAggregateType<T extends CourseAggregateArgs> = {
        [P in keyof T & keyof AggregateCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourse[P]>
      : GetScalarType<T[P], AggregateCourse[P]>
  }




  export type courseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: courseWhereInput
    orderBy?: courseOrderByWithAggregationInput | courseOrderByWithAggregationInput[]
    by: CourseScalarFieldEnum[] | CourseScalarFieldEnum
    having?: courseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseCountAggregateInputType | true
    _avg?: CourseAvgAggregateInputType
    _sum?: CourseSumAggregateInputType
    _min?: CourseMinAggregateInputType
    _max?: CourseMaxAggregateInputType
  }

  export type CourseGroupByOutputType = {
    id: number
    title: string
    description: string
    thumbnail: string
    categoryId: number
    isPaid: boolean
    price: number
    createdById: number
    createdAt: Date
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  type GetCourseGroupByPayload<T extends courseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseGroupByOutputType[P]>
            : GetScalarType<T[P], CourseGroupByOutputType[P]>
        }
      >
    >


  export type courseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    thumbnail?: boolean
    categoryId?: boolean
    isPaid?: boolean
    price?: boolean
    createdById?: boolean
    createdAt?: boolean
    certificate?: boolean | course$certificateArgs<ExtArgs>
    category?: boolean | categoryDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
    courseprogress?: boolean | course$courseprogressArgs<ExtArgs>
    coursevideo?: boolean | course$coursevideoArgs<ExtArgs>
    enrollment?: boolean | course$enrollmentArgs<ExtArgs>
    lesson?: boolean | course$lessonArgs<ExtArgs>
    payment?: boolean | course$paymentArgs<ExtArgs>
    quiz?: boolean | course$quizArgs<ExtArgs>
    quizsubmission?: boolean | course$quizsubmissionArgs<ExtArgs>
    roadmapcourse?: boolean | course$roadmapcourseArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>



  export type courseSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    thumbnail?: boolean
    categoryId?: boolean
    isPaid?: boolean
    price?: boolean
    createdById?: boolean
    createdAt?: boolean
  }

  export type courseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "thumbnail" | "categoryId" | "isPaid" | "price" | "createdById" | "createdAt", ExtArgs["result"]["course"]>
  export type courseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    certificate?: boolean | course$certificateArgs<ExtArgs>
    category?: boolean | categoryDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
    courseprogress?: boolean | course$courseprogressArgs<ExtArgs>
    coursevideo?: boolean | course$coursevideoArgs<ExtArgs>
    enrollment?: boolean | course$enrollmentArgs<ExtArgs>
    lesson?: boolean | course$lessonArgs<ExtArgs>
    payment?: boolean | course$paymentArgs<ExtArgs>
    quiz?: boolean | course$quizArgs<ExtArgs>
    quizsubmission?: boolean | course$quizsubmissionArgs<ExtArgs>
    roadmapcourse?: boolean | course$roadmapcourseArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $coursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "course"
    objects: {
      certificate: Prisma.$certificatePayload<ExtArgs>[]
      category: Prisma.$categoryPayload<ExtArgs>
      users: Prisma.$UserPayload<ExtArgs>
      courseprogress: Prisma.$courseprogressPayload<ExtArgs>[]
      coursevideo: Prisma.$coursevideoPayload<ExtArgs>[]
      enrollment: Prisma.$enrollmentPayload<ExtArgs>[]
      lesson: Prisma.$lessonPayload<ExtArgs>[]
      payment: Prisma.$paymentPayload<ExtArgs>[]
      quiz: Prisma.$quizPayload<ExtArgs>[]
      quizsubmission: Prisma.$quizsubmissionPayload<ExtArgs>[]
      roadmapcourse: Prisma.$roadmapcoursePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string
      thumbnail: string
      categoryId: number
      isPaid: boolean
      price: number
      createdById: number
      createdAt: Date
    }, ExtArgs["result"]["course"]>
    composites: {}
  }

  type courseGetPayload<S extends boolean | null | undefined | courseDefaultArgs> = $Result.GetResult<Prisma.$coursePayload, S>

  type courseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<courseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseCountAggregateInputType | true
    }

  export interface courseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['course'], meta: { name: 'course' } }
    /**
     * Find zero or one Course that matches the filter.
     * @param {courseFindUniqueArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends courseFindUniqueArgs>(args: SelectSubset<T, courseFindUniqueArgs<ExtArgs>>): Prisma__courseClient<$Result.GetResult<Prisma.$coursePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Course that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {courseFindUniqueOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends courseFindUniqueOrThrowArgs>(args: SelectSubset<T, courseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__courseClient<$Result.GetResult<Prisma.$coursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Course that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {courseFindFirstArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends courseFindFirstArgs>(args?: SelectSubset<T, courseFindFirstArgs<ExtArgs>>): Prisma__courseClient<$Result.GetResult<Prisma.$coursePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Course that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {courseFindFirstOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends courseFindFirstOrThrowArgs>(args?: SelectSubset<T, courseFindFirstOrThrowArgs<ExtArgs>>): Prisma__courseClient<$Result.GetResult<Prisma.$coursePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {courseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Courses
     * const courses = await prisma.course.findMany()
     * 
     * // Get first 10 Courses
     * const courses = await prisma.course.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseWithIdOnly = await prisma.course.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends courseFindManyArgs>(args?: SelectSubset<T, courseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$coursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Course.
     * @param {courseCreateArgs} args - Arguments to create a Course.
     * @example
     * // Create one Course
     * const Course = await prisma.course.create({
     *   data: {
     *     // ... data to create a Course
     *   }
     * })
     * 
     */
    create<T extends courseCreateArgs>(args: SelectSubset<T, courseCreateArgs<ExtArgs>>): Prisma__courseClient<$Result.GetResult<Prisma.$coursePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Courses.
     * @param {courseCreateManyArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends courseCreateManyArgs>(args?: SelectSubset<T, courseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Course.
     * @param {courseDeleteArgs} args - Arguments to delete one Course.
     * @example
     * // Delete one Course
     * const Course = await prisma.course.delete({
     *   where: {
     *     // ... filter to delete one Course
     *   }
     * })
     * 
     */
    delete<T extends courseDeleteArgs>(args: SelectSubset<T, courseDeleteArgs<ExtArgs>>): Prisma__courseClient<$Result.GetResult<Prisma.$coursePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Course.
     * @param {courseUpdateArgs} args - Arguments to update one Course.
     * @example
     * // Update one Course
     * const course = await prisma.course.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends courseUpdateArgs>(args: SelectSubset<T, courseUpdateArgs<ExtArgs>>): Prisma__courseClient<$Result.GetResult<Prisma.$coursePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Courses.
     * @param {courseDeleteManyArgs} args - Arguments to filter Courses to delete.
     * @example
     * // Delete a few Courses
     * const { count } = await prisma.course.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends courseDeleteManyArgs>(args?: SelectSubset<T, courseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {courseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends courseUpdateManyArgs>(args: SelectSubset<T, courseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Course.
     * @param {courseUpsertArgs} args - Arguments to update or create a Course.
     * @example
     * // Update or create a Course
     * const course = await prisma.course.upsert({
     *   create: {
     *     // ... data to create a Course
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Course we want to update
     *   }
     * })
     */
    upsert<T extends courseUpsertArgs>(args: SelectSubset<T, courseUpsertArgs<ExtArgs>>): Prisma__courseClient<$Result.GetResult<Prisma.$coursePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {courseCountArgs} args - Arguments to filter Courses to count.
     * @example
     * // Count the number of Courses
     * const count = await prisma.course.count({
     *   where: {
     *     // ... the filter for the Courses we want to count
     *   }
     * })
    **/
    count<T extends courseCountArgs>(
      args?: Subset<T, courseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseAggregateArgs>(args: Subset<T, CourseAggregateArgs>): Prisma.PrismaPromise<GetCourseAggregateType<T>>

    /**
     * Group by Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {courseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends courseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: courseGroupByArgs['orderBy'] }
        : { orderBy?: courseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, courseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the course model
   */
  readonly fields: courseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for course.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__courseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    certificate<T extends course$certificateArgs<ExtArgs> = {}>(args?: Subset<T, course$certificateArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$certificatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    category<T extends categoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, categoryDefaultArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    courseprogress<T extends course$courseprogressArgs<ExtArgs> = {}>(args?: Subset<T, course$courseprogressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$courseprogressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    coursevideo<T extends course$coursevideoArgs<ExtArgs> = {}>(args?: Subset<T, course$coursevideoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$coursevideoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    enrollment<T extends course$enrollmentArgs<ExtArgs> = {}>(args?: Subset<T, course$enrollmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$enrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lesson<T extends course$lessonArgs<ExtArgs> = {}>(args?: Subset<T, course$lessonArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lessonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payment<T extends course$paymentArgs<ExtArgs> = {}>(args?: Subset<T, course$paymentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quiz<T extends course$quizArgs<ExtArgs> = {}>(args?: Subset<T, course$quizArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$quizPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quizsubmission<T extends course$quizsubmissionArgs<ExtArgs> = {}>(args?: Subset<T, course$quizsubmissionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$quizsubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    roadmapcourse<T extends course$roadmapcourseArgs<ExtArgs> = {}>(args?: Subset<T, course$roadmapcourseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$roadmapcoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the course model
   */
  interface courseFieldRefs {
    readonly id: FieldRef<"course", 'Int'>
    readonly title: FieldRef<"course", 'String'>
    readonly description: FieldRef<"course", 'String'>
    readonly thumbnail: FieldRef<"course", 'String'>
    readonly categoryId: FieldRef<"course", 'Int'>
    readonly isPaid: FieldRef<"course", 'Boolean'>
    readonly price: FieldRef<"course", 'Int'>
    readonly createdById: FieldRef<"course", 'Int'>
    readonly createdAt: FieldRef<"course", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * course findUnique
   */
  export type courseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course
     */
    select?: courseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course
     */
    omit?: courseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: courseInclude<ExtArgs> | null
    /**
     * Filter, which course to fetch.
     */
    where: courseWhereUniqueInput
  }

  /**
   * course findUniqueOrThrow
   */
  export type courseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course
     */
    select?: courseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course
     */
    omit?: courseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: courseInclude<ExtArgs> | null
    /**
     * Filter, which course to fetch.
     */
    where: courseWhereUniqueInput
  }

  /**
   * course findFirst
   */
  export type courseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course
     */
    select?: courseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course
     */
    omit?: courseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: courseInclude<ExtArgs> | null
    /**
     * Filter, which course to fetch.
     */
    where?: courseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of courses to fetch.
     */
    orderBy?: courseOrderByWithRelationInput | courseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for courses.
     */
    cursor?: courseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * course findFirstOrThrow
   */
  export type courseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course
     */
    select?: courseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course
     */
    omit?: courseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: courseInclude<ExtArgs> | null
    /**
     * Filter, which course to fetch.
     */
    where?: courseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of courses to fetch.
     */
    orderBy?: courseOrderByWithRelationInput | courseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for courses.
     */
    cursor?: courseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * course findMany
   */
  export type courseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course
     */
    select?: courseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course
     */
    omit?: courseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: courseInclude<ExtArgs> | null
    /**
     * Filter, which courses to fetch.
     */
    where?: courseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of courses to fetch.
     */
    orderBy?: courseOrderByWithRelationInput | courseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing courses.
     */
    cursor?: courseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` courses.
     */
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * course create
   */
  export type courseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course
     */
    select?: courseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course
     */
    omit?: courseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: courseInclude<ExtArgs> | null
    /**
     * The data needed to create a course.
     */
    data: XOR<courseCreateInput, courseUncheckedCreateInput>
  }

  /**
   * course createMany
   */
  export type courseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many courses.
     */
    data: courseCreateManyInput | courseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * course update
   */
  export type courseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course
     */
    select?: courseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course
     */
    omit?: courseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: courseInclude<ExtArgs> | null
    /**
     * The data needed to update a course.
     */
    data: XOR<courseUpdateInput, courseUncheckedUpdateInput>
    /**
     * Choose, which course to update.
     */
    where: courseWhereUniqueInput
  }

  /**
   * course updateMany
   */
  export type courseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update courses.
     */
    data: XOR<courseUpdateManyMutationInput, courseUncheckedUpdateManyInput>
    /**
     * Filter which courses to update
     */
    where?: courseWhereInput
    /**
     * Limit how many courses to update.
     */
    limit?: number
  }

  /**
   * course upsert
   */
  export type courseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course
     */
    select?: courseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course
     */
    omit?: courseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: courseInclude<ExtArgs> | null
    /**
     * The filter to search for the course to update in case it exists.
     */
    where: courseWhereUniqueInput
    /**
     * In case the course found by the `where` argument doesn't exist, create a new course with this data.
     */
    create: XOR<courseCreateInput, courseUncheckedCreateInput>
    /**
     * In case the course was found with the provided `where` argument, update it with this data.
     */
    update: XOR<courseUpdateInput, courseUncheckedUpdateInput>
  }

  /**
   * course delete
   */
  export type courseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course
     */
    select?: courseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course
     */
    omit?: courseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: courseInclude<ExtArgs> | null
    /**
     * Filter which course to delete.
     */
    where: courseWhereUniqueInput
  }

  /**
   * course deleteMany
   */
  export type courseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which courses to delete
     */
    where?: courseWhereInput
    /**
     * Limit how many courses to delete.
     */
    limit?: number
  }

  /**
   * course.certificate
   */
  export type course$certificateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificate
     */
    select?: certificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificate
     */
    omit?: certificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificateInclude<ExtArgs> | null
    where?: certificateWhereInput
    orderBy?: certificateOrderByWithRelationInput | certificateOrderByWithRelationInput[]
    cursor?: certificateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * course.courseprogress
   */
  export type course$courseprogressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courseprogress
     */
    select?: courseprogressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the courseprogress
     */
    omit?: courseprogressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: courseprogressInclude<ExtArgs> | null
    where?: courseprogressWhereInput
    orderBy?: courseprogressOrderByWithRelationInput | courseprogressOrderByWithRelationInput[]
    cursor?: courseprogressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseprogressScalarFieldEnum | CourseprogressScalarFieldEnum[]
  }

  /**
   * course.coursevideo
   */
  export type course$coursevideoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coursevideo
     */
    select?: coursevideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coursevideo
     */
    omit?: coursevideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coursevideoInclude<ExtArgs> | null
    where?: coursevideoWhereInput
    orderBy?: coursevideoOrderByWithRelationInput | coursevideoOrderByWithRelationInput[]
    cursor?: coursevideoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CoursevideoScalarFieldEnum | CoursevideoScalarFieldEnum[]
  }

  /**
   * course.enrollment
   */
  export type course$enrollmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollment
     */
    select?: enrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrollment
     */
    omit?: enrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentInclude<ExtArgs> | null
    where?: enrollmentWhereInput
    orderBy?: enrollmentOrderByWithRelationInput | enrollmentOrderByWithRelationInput[]
    cursor?: enrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * course.lesson
   */
  export type course$lessonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lesson
     */
    select?: lessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lesson
     */
    omit?: lessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lessonInclude<ExtArgs> | null
    where?: lessonWhereInput
    orderBy?: lessonOrderByWithRelationInput | lessonOrderByWithRelationInput[]
    cursor?: lessonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * course.payment
   */
  export type course$paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    where?: paymentWhereInput
    orderBy?: paymentOrderByWithRelationInput | paymentOrderByWithRelationInput[]
    cursor?: paymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * course.quiz
   */
  export type course$quizArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quiz
     */
    select?: quizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quiz
     */
    omit?: quizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quizInclude<ExtArgs> | null
    where?: quizWhereInput
    orderBy?: quizOrderByWithRelationInput | quizOrderByWithRelationInput[]
    cursor?: quizWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * course.quizsubmission
   */
  export type course$quizsubmissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quizsubmission
     */
    select?: quizsubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quizsubmission
     */
    omit?: quizsubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quizsubmissionInclude<ExtArgs> | null
    where?: quizsubmissionWhereInput
    orderBy?: quizsubmissionOrderByWithRelationInput | quizsubmissionOrderByWithRelationInput[]
    cursor?: quizsubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizsubmissionScalarFieldEnum | QuizsubmissionScalarFieldEnum[]
  }

  /**
   * course.roadmapcourse
   */
  export type course$roadmapcourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roadmapcourse
     */
    select?: roadmapcourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roadmapcourse
     */
    omit?: roadmapcourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roadmapcourseInclude<ExtArgs> | null
    where?: roadmapcourseWhereInput
    orderBy?: roadmapcourseOrderByWithRelationInput | roadmapcourseOrderByWithRelationInput[]
    cursor?: roadmapcourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoadmapcourseScalarFieldEnum | RoadmapcourseScalarFieldEnum[]
  }

  /**
   * course without action
   */
  export type courseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course
     */
    select?: courseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course
     */
    omit?: courseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: courseInclude<ExtArgs> | null
  }


  /**
   * Model courseprogress
   */

  export type AggregateCourseprogress = {
    _count: CourseprogressCountAggregateOutputType | null
    _avg: CourseprogressAvgAggregateOutputType | null
    _sum: CourseprogressSumAggregateOutputType | null
    _min: CourseprogressMinAggregateOutputType | null
    _max: CourseprogressMaxAggregateOutputType | null
  }

  export type CourseprogressAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
    completedVideoCount: number | null
    completedQuizCount: number | null
  }

  export type CourseprogressSumAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
    completedVideoCount: number | null
    completedQuizCount: number | null
  }

  export type CourseprogressMinAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
    completedVideoCount: number | null
    completedQuizCount: number | null
    isCompleted: boolean | null
  }

  export type CourseprogressMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
    completedVideoCount: number | null
    completedQuizCount: number | null
    isCompleted: boolean | null
  }

  export type CourseprogressCountAggregateOutputType = {
    id: number
    userId: number
    courseId: number
    completedVideoCount: number
    completedQuizCount: number
    isCompleted: number
    _all: number
  }


  export type CourseprogressAvgAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    completedVideoCount?: true
    completedQuizCount?: true
  }

  export type CourseprogressSumAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    completedVideoCount?: true
    completedQuizCount?: true
  }

  export type CourseprogressMinAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    completedVideoCount?: true
    completedQuizCount?: true
    isCompleted?: true
  }

  export type CourseprogressMaxAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    completedVideoCount?: true
    completedQuizCount?: true
    isCompleted?: true
  }

  export type CourseprogressCountAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    completedVideoCount?: true
    completedQuizCount?: true
    isCompleted?: true
    _all?: true
  }

  export type CourseprogressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which courseprogress to aggregate.
     */
    where?: courseprogressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of courseprogresses to fetch.
     */
    orderBy?: courseprogressOrderByWithRelationInput | courseprogressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: courseprogressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` courseprogresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` courseprogresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned courseprogresses
    **/
    _count?: true | CourseprogressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseprogressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseprogressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseprogressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseprogressMaxAggregateInputType
  }

  export type GetCourseprogressAggregateType<T extends CourseprogressAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseprogress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseprogress[P]>
      : GetScalarType<T[P], AggregateCourseprogress[P]>
  }




  export type courseprogressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: courseprogressWhereInput
    orderBy?: courseprogressOrderByWithAggregationInput | courseprogressOrderByWithAggregationInput[]
    by: CourseprogressScalarFieldEnum[] | CourseprogressScalarFieldEnum
    having?: courseprogressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseprogressCountAggregateInputType | true
    _avg?: CourseprogressAvgAggregateInputType
    _sum?: CourseprogressSumAggregateInputType
    _min?: CourseprogressMinAggregateInputType
    _max?: CourseprogressMaxAggregateInputType
  }

  export type CourseprogressGroupByOutputType = {
    id: number
    userId: number
    courseId: number
    completedVideoCount: number
    completedQuizCount: number
    isCompleted: boolean
    _count: CourseprogressCountAggregateOutputType | null
    _avg: CourseprogressAvgAggregateOutputType | null
    _sum: CourseprogressSumAggregateOutputType | null
    _min: CourseprogressMinAggregateOutputType | null
    _max: CourseprogressMaxAggregateOutputType | null
  }

  type GetCourseprogressGroupByPayload<T extends courseprogressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseprogressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseprogressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseprogressGroupByOutputType[P]>
            : GetScalarType<T[P], CourseprogressGroupByOutputType[P]>
        }
      >
    >


  export type courseprogressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    completedVideoCount?: boolean
    completedQuizCount?: boolean
    isCompleted?: boolean
    course?: boolean | courseDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseprogress"]>



  export type courseprogressSelectScalar = {
    id?: boolean
    userId?: boolean
    courseId?: boolean
    completedVideoCount?: boolean
    completedQuizCount?: boolean
    isCompleted?: boolean
  }

  export type courseprogressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "courseId" | "completedVideoCount" | "completedQuizCount" | "isCompleted", ExtArgs["result"]["courseprogress"]>
  export type courseprogressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | courseDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $courseprogressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "courseprogress"
    objects: {
      course: Prisma.$coursePayload<ExtArgs>
      users: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      courseId: number
      completedVideoCount: number
      completedQuizCount: number
      isCompleted: boolean
    }, ExtArgs["result"]["courseprogress"]>
    composites: {}
  }

  type courseprogressGetPayload<S extends boolean | null | undefined | courseprogressDefaultArgs> = $Result.GetResult<Prisma.$courseprogressPayload, S>

  type courseprogressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<courseprogressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseprogressCountAggregateInputType | true
    }

  export interface courseprogressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['courseprogress'], meta: { name: 'courseprogress' } }
    /**
     * Find zero or one Courseprogress that matches the filter.
     * @param {courseprogressFindUniqueArgs} args - Arguments to find a Courseprogress
     * @example
     * // Get one Courseprogress
     * const courseprogress = await prisma.courseprogress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends courseprogressFindUniqueArgs>(args: SelectSubset<T, courseprogressFindUniqueArgs<ExtArgs>>): Prisma__courseprogressClient<$Result.GetResult<Prisma.$courseprogressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Courseprogress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {courseprogressFindUniqueOrThrowArgs} args - Arguments to find a Courseprogress
     * @example
     * // Get one Courseprogress
     * const courseprogress = await prisma.courseprogress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends courseprogressFindUniqueOrThrowArgs>(args: SelectSubset<T, courseprogressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__courseprogressClient<$Result.GetResult<Prisma.$courseprogressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Courseprogress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {courseprogressFindFirstArgs} args - Arguments to find a Courseprogress
     * @example
     * // Get one Courseprogress
     * const courseprogress = await prisma.courseprogress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends courseprogressFindFirstArgs>(args?: SelectSubset<T, courseprogressFindFirstArgs<ExtArgs>>): Prisma__courseprogressClient<$Result.GetResult<Prisma.$courseprogressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Courseprogress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {courseprogressFindFirstOrThrowArgs} args - Arguments to find a Courseprogress
     * @example
     * // Get one Courseprogress
     * const courseprogress = await prisma.courseprogress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends courseprogressFindFirstOrThrowArgs>(args?: SelectSubset<T, courseprogressFindFirstOrThrowArgs<ExtArgs>>): Prisma__courseprogressClient<$Result.GetResult<Prisma.$courseprogressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Courseprogresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {courseprogressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Courseprogresses
     * const courseprogresses = await prisma.courseprogress.findMany()
     * 
     * // Get first 10 Courseprogresses
     * const courseprogresses = await prisma.courseprogress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseprogressWithIdOnly = await prisma.courseprogress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends courseprogressFindManyArgs>(args?: SelectSubset<T, courseprogressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$courseprogressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Courseprogress.
     * @param {courseprogressCreateArgs} args - Arguments to create a Courseprogress.
     * @example
     * // Create one Courseprogress
     * const Courseprogress = await prisma.courseprogress.create({
     *   data: {
     *     // ... data to create a Courseprogress
     *   }
     * })
     * 
     */
    create<T extends courseprogressCreateArgs>(args: SelectSubset<T, courseprogressCreateArgs<ExtArgs>>): Prisma__courseprogressClient<$Result.GetResult<Prisma.$courseprogressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Courseprogresses.
     * @param {courseprogressCreateManyArgs} args - Arguments to create many Courseprogresses.
     * @example
     * // Create many Courseprogresses
     * const courseprogress = await prisma.courseprogress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends courseprogressCreateManyArgs>(args?: SelectSubset<T, courseprogressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Courseprogress.
     * @param {courseprogressDeleteArgs} args - Arguments to delete one Courseprogress.
     * @example
     * // Delete one Courseprogress
     * const Courseprogress = await prisma.courseprogress.delete({
     *   where: {
     *     // ... filter to delete one Courseprogress
     *   }
     * })
     * 
     */
    delete<T extends courseprogressDeleteArgs>(args: SelectSubset<T, courseprogressDeleteArgs<ExtArgs>>): Prisma__courseprogressClient<$Result.GetResult<Prisma.$courseprogressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Courseprogress.
     * @param {courseprogressUpdateArgs} args - Arguments to update one Courseprogress.
     * @example
     * // Update one Courseprogress
     * const courseprogress = await prisma.courseprogress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends courseprogressUpdateArgs>(args: SelectSubset<T, courseprogressUpdateArgs<ExtArgs>>): Prisma__courseprogressClient<$Result.GetResult<Prisma.$courseprogressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Courseprogresses.
     * @param {courseprogressDeleteManyArgs} args - Arguments to filter Courseprogresses to delete.
     * @example
     * // Delete a few Courseprogresses
     * const { count } = await prisma.courseprogress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends courseprogressDeleteManyArgs>(args?: SelectSubset<T, courseprogressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courseprogresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {courseprogressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Courseprogresses
     * const courseprogress = await prisma.courseprogress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends courseprogressUpdateManyArgs>(args: SelectSubset<T, courseprogressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Courseprogress.
     * @param {courseprogressUpsertArgs} args - Arguments to update or create a Courseprogress.
     * @example
     * // Update or create a Courseprogress
     * const courseprogress = await prisma.courseprogress.upsert({
     *   create: {
     *     // ... data to create a Courseprogress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Courseprogress we want to update
     *   }
     * })
     */
    upsert<T extends courseprogressUpsertArgs>(args: SelectSubset<T, courseprogressUpsertArgs<ExtArgs>>): Prisma__courseprogressClient<$Result.GetResult<Prisma.$courseprogressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Courseprogresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {courseprogressCountArgs} args - Arguments to filter Courseprogresses to count.
     * @example
     * // Count the number of Courseprogresses
     * const count = await prisma.courseprogress.count({
     *   where: {
     *     // ... the filter for the Courseprogresses we want to count
     *   }
     * })
    **/
    count<T extends courseprogressCountArgs>(
      args?: Subset<T, courseprogressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseprogressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Courseprogress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseprogressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseprogressAggregateArgs>(args: Subset<T, CourseprogressAggregateArgs>): Prisma.PrismaPromise<GetCourseprogressAggregateType<T>>

    /**
     * Group by Courseprogress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {courseprogressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends courseprogressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: courseprogressGroupByArgs['orderBy'] }
        : { orderBy?: courseprogressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, courseprogressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseprogressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the courseprogress model
   */
  readonly fields: courseprogressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for courseprogress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__courseprogressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends courseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, courseDefaultArgs<ExtArgs>>): Prisma__courseClient<$Result.GetResult<Prisma.$coursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the courseprogress model
   */
  interface courseprogressFieldRefs {
    readonly id: FieldRef<"courseprogress", 'Int'>
    readonly userId: FieldRef<"courseprogress", 'Int'>
    readonly courseId: FieldRef<"courseprogress", 'Int'>
    readonly completedVideoCount: FieldRef<"courseprogress", 'Int'>
    readonly completedQuizCount: FieldRef<"courseprogress", 'Int'>
    readonly isCompleted: FieldRef<"courseprogress", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * courseprogress findUnique
   */
  export type courseprogressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courseprogress
     */
    select?: courseprogressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the courseprogress
     */
    omit?: courseprogressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: courseprogressInclude<ExtArgs> | null
    /**
     * Filter, which courseprogress to fetch.
     */
    where: courseprogressWhereUniqueInput
  }

  /**
   * courseprogress findUniqueOrThrow
   */
  export type courseprogressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courseprogress
     */
    select?: courseprogressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the courseprogress
     */
    omit?: courseprogressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: courseprogressInclude<ExtArgs> | null
    /**
     * Filter, which courseprogress to fetch.
     */
    where: courseprogressWhereUniqueInput
  }

  /**
   * courseprogress findFirst
   */
  export type courseprogressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courseprogress
     */
    select?: courseprogressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the courseprogress
     */
    omit?: courseprogressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: courseprogressInclude<ExtArgs> | null
    /**
     * Filter, which courseprogress to fetch.
     */
    where?: courseprogressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of courseprogresses to fetch.
     */
    orderBy?: courseprogressOrderByWithRelationInput | courseprogressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for courseprogresses.
     */
    cursor?: courseprogressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` courseprogresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` courseprogresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of courseprogresses.
     */
    distinct?: CourseprogressScalarFieldEnum | CourseprogressScalarFieldEnum[]
  }

  /**
   * courseprogress findFirstOrThrow
   */
  export type courseprogressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courseprogress
     */
    select?: courseprogressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the courseprogress
     */
    omit?: courseprogressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: courseprogressInclude<ExtArgs> | null
    /**
     * Filter, which courseprogress to fetch.
     */
    where?: courseprogressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of courseprogresses to fetch.
     */
    orderBy?: courseprogressOrderByWithRelationInput | courseprogressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for courseprogresses.
     */
    cursor?: courseprogressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` courseprogresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` courseprogresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of courseprogresses.
     */
    distinct?: CourseprogressScalarFieldEnum | CourseprogressScalarFieldEnum[]
  }

  /**
   * courseprogress findMany
   */
  export type courseprogressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courseprogress
     */
    select?: courseprogressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the courseprogress
     */
    omit?: courseprogressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: courseprogressInclude<ExtArgs> | null
    /**
     * Filter, which courseprogresses to fetch.
     */
    where?: courseprogressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of courseprogresses to fetch.
     */
    orderBy?: courseprogressOrderByWithRelationInput | courseprogressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing courseprogresses.
     */
    cursor?: courseprogressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` courseprogresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` courseprogresses.
     */
    skip?: number
    distinct?: CourseprogressScalarFieldEnum | CourseprogressScalarFieldEnum[]
  }

  /**
   * courseprogress create
   */
  export type courseprogressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courseprogress
     */
    select?: courseprogressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the courseprogress
     */
    omit?: courseprogressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: courseprogressInclude<ExtArgs> | null
    /**
     * The data needed to create a courseprogress.
     */
    data: XOR<courseprogressCreateInput, courseprogressUncheckedCreateInput>
  }

  /**
   * courseprogress createMany
   */
  export type courseprogressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many courseprogresses.
     */
    data: courseprogressCreateManyInput | courseprogressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * courseprogress update
   */
  export type courseprogressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courseprogress
     */
    select?: courseprogressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the courseprogress
     */
    omit?: courseprogressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: courseprogressInclude<ExtArgs> | null
    /**
     * The data needed to update a courseprogress.
     */
    data: XOR<courseprogressUpdateInput, courseprogressUncheckedUpdateInput>
    /**
     * Choose, which courseprogress to update.
     */
    where: courseprogressWhereUniqueInput
  }

  /**
   * courseprogress updateMany
   */
  export type courseprogressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update courseprogresses.
     */
    data: XOR<courseprogressUpdateManyMutationInput, courseprogressUncheckedUpdateManyInput>
    /**
     * Filter which courseprogresses to update
     */
    where?: courseprogressWhereInput
    /**
     * Limit how many courseprogresses to update.
     */
    limit?: number
  }

  /**
   * courseprogress upsert
   */
  export type courseprogressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courseprogress
     */
    select?: courseprogressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the courseprogress
     */
    omit?: courseprogressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: courseprogressInclude<ExtArgs> | null
    /**
     * The filter to search for the courseprogress to update in case it exists.
     */
    where: courseprogressWhereUniqueInput
    /**
     * In case the courseprogress found by the `where` argument doesn't exist, create a new courseprogress with this data.
     */
    create: XOR<courseprogressCreateInput, courseprogressUncheckedCreateInput>
    /**
     * In case the courseprogress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<courseprogressUpdateInput, courseprogressUncheckedUpdateInput>
  }

  /**
   * courseprogress delete
   */
  export type courseprogressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courseprogress
     */
    select?: courseprogressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the courseprogress
     */
    omit?: courseprogressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: courseprogressInclude<ExtArgs> | null
    /**
     * Filter which courseprogress to delete.
     */
    where: courseprogressWhereUniqueInput
  }

  /**
   * courseprogress deleteMany
   */
  export type courseprogressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which courseprogresses to delete
     */
    where?: courseprogressWhereInput
    /**
     * Limit how many courseprogresses to delete.
     */
    limit?: number
  }

  /**
   * courseprogress without action
   */
  export type courseprogressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courseprogress
     */
    select?: courseprogressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the courseprogress
     */
    omit?: courseprogressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: courseprogressInclude<ExtArgs> | null
  }


  /**
   * Model coursevideo
   */

  export type AggregateCoursevideo = {
    _count: CoursevideoCountAggregateOutputType | null
    _avg: CoursevideoAvgAggregateOutputType | null
    _sum: CoursevideoSumAggregateOutputType | null
    _min: CoursevideoMinAggregateOutputType | null
    _max: CoursevideoMaxAggregateOutputType | null
  }

  export type CoursevideoAvgAggregateOutputType = {
    id: number | null
    courseId: number | null
    order: number | null
  }

  export type CoursevideoSumAggregateOutputType = {
    id: number | null
    courseId: number | null
    order: number | null
  }

  export type CoursevideoMinAggregateOutputType = {
    id: number | null
    courseId: number | null
    title: string | null
    videoUrl: string | null
    isLocked: boolean | null
    order: number | null
    s3Key: string | null
  }

  export type CoursevideoMaxAggregateOutputType = {
    id: number | null
    courseId: number | null
    title: string | null
    videoUrl: string | null
    isLocked: boolean | null
    order: number | null
    s3Key: string | null
  }

  export type CoursevideoCountAggregateOutputType = {
    id: number
    courseId: number
    title: number
    videoUrl: number
    isLocked: number
    order: number
    s3Key: number
    _all: number
  }


  export type CoursevideoAvgAggregateInputType = {
    id?: true
    courseId?: true
    order?: true
  }

  export type CoursevideoSumAggregateInputType = {
    id?: true
    courseId?: true
    order?: true
  }

  export type CoursevideoMinAggregateInputType = {
    id?: true
    courseId?: true
    title?: true
    videoUrl?: true
    isLocked?: true
    order?: true
    s3Key?: true
  }

  export type CoursevideoMaxAggregateInputType = {
    id?: true
    courseId?: true
    title?: true
    videoUrl?: true
    isLocked?: true
    order?: true
    s3Key?: true
  }

  export type CoursevideoCountAggregateInputType = {
    id?: true
    courseId?: true
    title?: true
    videoUrl?: true
    isLocked?: true
    order?: true
    s3Key?: true
    _all?: true
  }

  export type CoursevideoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which coursevideo to aggregate.
     */
    where?: coursevideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of coursevideos to fetch.
     */
    orderBy?: coursevideoOrderByWithRelationInput | coursevideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: coursevideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` coursevideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` coursevideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned coursevideos
    **/
    _count?: true | CoursevideoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CoursevideoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CoursevideoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CoursevideoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CoursevideoMaxAggregateInputType
  }

  export type GetCoursevideoAggregateType<T extends CoursevideoAggregateArgs> = {
        [P in keyof T & keyof AggregateCoursevideo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoursevideo[P]>
      : GetScalarType<T[P], AggregateCoursevideo[P]>
  }




  export type coursevideoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: coursevideoWhereInput
    orderBy?: coursevideoOrderByWithAggregationInput | coursevideoOrderByWithAggregationInput[]
    by: CoursevideoScalarFieldEnum[] | CoursevideoScalarFieldEnum
    having?: coursevideoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CoursevideoCountAggregateInputType | true
    _avg?: CoursevideoAvgAggregateInputType
    _sum?: CoursevideoSumAggregateInputType
    _min?: CoursevideoMinAggregateInputType
    _max?: CoursevideoMaxAggregateInputType
  }

  export type CoursevideoGroupByOutputType = {
    id: number
    courseId: number
    title: string
    videoUrl: string
    isLocked: boolean
    order: number
    s3Key: string | null
    _count: CoursevideoCountAggregateOutputType | null
    _avg: CoursevideoAvgAggregateOutputType | null
    _sum: CoursevideoSumAggregateOutputType | null
    _min: CoursevideoMinAggregateOutputType | null
    _max: CoursevideoMaxAggregateOutputType | null
  }

  type GetCoursevideoGroupByPayload<T extends coursevideoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CoursevideoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CoursevideoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CoursevideoGroupByOutputType[P]>
            : GetScalarType<T[P], CoursevideoGroupByOutputType[P]>
        }
      >
    >


  export type coursevideoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    title?: boolean
    videoUrl?: boolean
    isLocked?: boolean
    order?: boolean
    s3Key?: boolean
    course?: boolean | courseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coursevideo"]>



  export type coursevideoSelectScalar = {
    id?: boolean
    courseId?: boolean
    title?: boolean
    videoUrl?: boolean
    isLocked?: boolean
    order?: boolean
    s3Key?: boolean
  }

  export type coursevideoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "courseId" | "title" | "videoUrl" | "isLocked" | "order" | "s3Key", ExtArgs["result"]["coursevideo"]>
  export type coursevideoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | courseDefaultArgs<ExtArgs>
  }

  export type $coursevideoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "coursevideo"
    objects: {
      course: Prisma.$coursePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      courseId: number
      title: string
      videoUrl: string
      isLocked: boolean
      order: number
      s3Key: string | null
    }, ExtArgs["result"]["coursevideo"]>
    composites: {}
  }

  type coursevideoGetPayload<S extends boolean | null | undefined | coursevideoDefaultArgs> = $Result.GetResult<Prisma.$coursevideoPayload, S>

  type coursevideoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<coursevideoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CoursevideoCountAggregateInputType | true
    }

  export interface coursevideoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['coursevideo'], meta: { name: 'coursevideo' } }
    /**
     * Find zero or one Coursevideo that matches the filter.
     * @param {coursevideoFindUniqueArgs} args - Arguments to find a Coursevideo
     * @example
     * // Get one Coursevideo
     * const coursevideo = await prisma.coursevideo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends coursevideoFindUniqueArgs>(args: SelectSubset<T, coursevideoFindUniqueArgs<ExtArgs>>): Prisma__coursevideoClient<$Result.GetResult<Prisma.$coursevideoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Coursevideo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {coursevideoFindUniqueOrThrowArgs} args - Arguments to find a Coursevideo
     * @example
     * // Get one Coursevideo
     * const coursevideo = await prisma.coursevideo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends coursevideoFindUniqueOrThrowArgs>(args: SelectSubset<T, coursevideoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__coursevideoClient<$Result.GetResult<Prisma.$coursevideoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Coursevideo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {coursevideoFindFirstArgs} args - Arguments to find a Coursevideo
     * @example
     * // Get one Coursevideo
     * const coursevideo = await prisma.coursevideo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends coursevideoFindFirstArgs>(args?: SelectSubset<T, coursevideoFindFirstArgs<ExtArgs>>): Prisma__coursevideoClient<$Result.GetResult<Prisma.$coursevideoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Coursevideo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {coursevideoFindFirstOrThrowArgs} args - Arguments to find a Coursevideo
     * @example
     * // Get one Coursevideo
     * const coursevideo = await prisma.coursevideo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends coursevideoFindFirstOrThrowArgs>(args?: SelectSubset<T, coursevideoFindFirstOrThrowArgs<ExtArgs>>): Prisma__coursevideoClient<$Result.GetResult<Prisma.$coursevideoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Coursevideos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {coursevideoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Coursevideos
     * const coursevideos = await prisma.coursevideo.findMany()
     * 
     * // Get first 10 Coursevideos
     * const coursevideos = await prisma.coursevideo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const coursevideoWithIdOnly = await prisma.coursevideo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends coursevideoFindManyArgs>(args?: SelectSubset<T, coursevideoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$coursevideoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Coursevideo.
     * @param {coursevideoCreateArgs} args - Arguments to create a Coursevideo.
     * @example
     * // Create one Coursevideo
     * const Coursevideo = await prisma.coursevideo.create({
     *   data: {
     *     // ... data to create a Coursevideo
     *   }
     * })
     * 
     */
    create<T extends coursevideoCreateArgs>(args: SelectSubset<T, coursevideoCreateArgs<ExtArgs>>): Prisma__coursevideoClient<$Result.GetResult<Prisma.$coursevideoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Coursevideos.
     * @param {coursevideoCreateManyArgs} args - Arguments to create many Coursevideos.
     * @example
     * // Create many Coursevideos
     * const coursevideo = await prisma.coursevideo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends coursevideoCreateManyArgs>(args?: SelectSubset<T, coursevideoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Coursevideo.
     * @param {coursevideoDeleteArgs} args - Arguments to delete one Coursevideo.
     * @example
     * // Delete one Coursevideo
     * const Coursevideo = await prisma.coursevideo.delete({
     *   where: {
     *     // ... filter to delete one Coursevideo
     *   }
     * })
     * 
     */
    delete<T extends coursevideoDeleteArgs>(args: SelectSubset<T, coursevideoDeleteArgs<ExtArgs>>): Prisma__coursevideoClient<$Result.GetResult<Prisma.$coursevideoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Coursevideo.
     * @param {coursevideoUpdateArgs} args - Arguments to update one Coursevideo.
     * @example
     * // Update one Coursevideo
     * const coursevideo = await prisma.coursevideo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends coursevideoUpdateArgs>(args: SelectSubset<T, coursevideoUpdateArgs<ExtArgs>>): Prisma__coursevideoClient<$Result.GetResult<Prisma.$coursevideoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Coursevideos.
     * @param {coursevideoDeleteManyArgs} args - Arguments to filter Coursevideos to delete.
     * @example
     * // Delete a few Coursevideos
     * const { count } = await prisma.coursevideo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends coursevideoDeleteManyArgs>(args?: SelectSubset<T, coursevideoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Coursevideos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {coursevideoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Coursevideos
     * const coursevideo = await prisma.coursevideo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends coursevideoUpdateManyArgs>(args: SelectSubset<T, coursevideoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Coursevideo.
     * @param {coursevideoUpsertArgs} args - Arguments to update or create a Coursevideo.
     * @example
     * // Update or create a Coursevideo
     * const coursevideo = await prisma.coursevideo.upsert({
     *   create: {
     *     // ... data to create a Coursevideo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Coursevideo we want to update
     *   }
     * })
     */
    upsert<T extends coursevideoUpsertArgs>(args: SelectSubset<T, coursevideoUpsertArgs<ExtArgs>>): Prisma__coursevideoClient<$Result.GetResult<Prisma.$coursevideoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Coursevideos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {coursevideoCountArgs} args - Arguments to filter Coursevideos to count.
     * @example
     * // Count the number of Coursevideos
     * const count = await prisma.coursevideo.count({
     *   where: {
     *     // ... the filter for the Coursevideos we want to count
     *   }
     * })
    **/
    count<T extends coursevideoCountArgs>(
      args?: Subset<T, coursevideoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CoursevideoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Coursevideo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursevideoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CoursevideoAggregateArgs>(args: Subset<T, CoursevideoAggregateArgs>): Prisma.PrismaPromise<GetCoursevideoAggregateType<T>>

    /**
     * Group by Coursevideo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {coursevideoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends coursevideoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: coursevideoGroupByArgs['orderBy'] }
        : { orderBy?: coursevideoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, coursevideoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCoursevideoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the coursevideo model
   */
  readonly fields: coursevideoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for coursevideo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__coursevideoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends courseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, courseDefaultArgs<ExtArgs>>): Prisma__courseClient<$Result.GetResult<Prisma.$coursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the coursevideo model
   */
  interface coursevideoFieldRefs {
    readonly id: FieldRef<"coursevideo", 'Int'>
    readonly courseId: FieldRef<"coursevideo", 'Int'>
    readonly title: FieldRef<"coursevideo", 'String'>
    readonly videoUrl: FieldRef<"coursevideo", 'String'>
    readonly isLocked: FieldRef<"coursevideo", 'Boolean'>
    readonly order: FieldRef<"coursevideo", 'Int'>
    readonly s3Key: FieldRef<"coursevideo", 'String'>
  }
    

  // Custom InputTypes
  /**
   * coursevideo findUnique
   */
  export type coursevideoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coursevideo
     */
    select?: coursevideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coursevideo
     */
    omit?: coursevideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coursevideoInclude<ExtArgs> | null
    /**
     * Filter, which coursevideo to fetch.
     */
    where: coursevideoWhereUniqueInput
  }

  /**
   * coursevideo findUniqueOrThrow
   */
  export type coursevideoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coursevideo
     */
    select?: coursevideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coursevideo
     */
    omit?: coursevideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coursevideoInclude<ExtArgs> | null
    /**
     * Filter, which coursevideo to fetch.
     */
    where: coursevideoWhereUniqueInput
  }

  /**
   * coursevideo findFirst
   */
  export type coursevideoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coursevideo
     */
    select?: coursevideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coursevideo
     */
    omit?: coursevideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coursevideoInclude<ExtArgs> | null
    /**
     * Filter, which coursevideo to fetch.
     */
    where?: coursevideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of coursevideos to fetch.
     */
    orderBy?: coursevideoOrderByWithRelationInput | coursevideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for coursevideos.
     */
    cursor?: coursevideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` coursevideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` coursevideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of coursevideos.
     */
    distinct?: CoursevideoScalarFieldEnum | CoursevideoScalarFieldEnum[]
  }

  /**
   * coursevideo findFirstOrThrow
   */
  export type coursevideoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coursevideo
     */
    select?: coursevideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coursevideo
     */
    omit?: coursevideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coursevideoInclude<ExtArgs> | null
    /**
     * Filter, which coursevideo to fetch.
     */
    where?: coursevideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of coursevideos to fetch.
     */
    orderBy?: coursevideoOrderByWithRelationInput | coursevideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for coursevideos.
     */
    cursor?: coursevideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` coursevideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` coursevideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of coursevideos.
     */
    distinct?: CoursevideoScalarFieldEnum | CoursevideoScalarFieldEnum[]
  }

  /**
   * coursevideo findMany
   */
  export type coursevideoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coursevideo
     */
    select?: coursevideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coursevideo
     */
    omit?: coursevideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coursevideoInclude<ExtArgs> | null
    /**
     * Filter, which coursevideos to fetch.
     */
    where?: coursevideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of coursevideos to fetch.
     */
    orderBy?: coursevideoOrderByWithRelationInput | coursevideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing coursevideos.
     */
    cursor?: coursevideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` coursevideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` coursevideos.
     */
    skip?: number
    distinct?: CoursevideoScalarFieldEnum | CoursevideoScalarFieldEnum[]
  }

  /**
   * coursevideo create
   */
  export type coursevideoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coursevideo
     */
    select?: coursevideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coursevideo
     */
    omit?: coursevideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coursevideoInclude<ExtArgs> | null
    /**
     * The data needed to create a coursevideo.
     */
    data: XOR<coursevideoCreateInput, coursevideoUncheckedCreateInput>
  }

  /**
   * coursevideo createMany
   */
  export type coursevideoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many coursevideos.
     */
    data: coursevideoCreateManyInput | coursevideoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * coursevideo update
   */
  export type coursevideoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coursevideo
     */
    select?: coursevideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coursevideo
     */
    omit?: coursevideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coursevideoInclude<ExtArgs> | null
    /**
     * The data needed to update a coursevideo.
     */
    data: XOR<coursevideoUpdateInput, coursevideoUncheckedUpdateInput>
    /**
     * Choose, which coursevideo to update.
     */
    where: coursevideoWhereUniqueInput
  }

  /**
   * coursevideo updateMany
   */
  export type coursevideoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update coursevideos.
     */
    data: XOR<coursevideoUpdateManyMutationInput, coursevideoUncheckedUpdateManyInput>
    /**
     * Filter which coursevideos to update
     */
    where?: coursevideoWhereInput
    /**
     * Limit how many coursevideos to update.
     */
    limit?: number
  }

  /**
   * coursevideo upsert
   */
  export type coursevideoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coursevideo
     */
    select?: coursevideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coursevideo
     */
    omit?: coursevideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coursevideoInclude<ExtArgs> | null
    /**
     * The filter to search for the coursevideo to update in case it exists.
     */
    where: coursevideoWhereUniqueInput
    /**
     * In case the coursevideo found by the `where` argument doesn't exist, create a new coursevideo with this data.
     */
    create: XOR<coursevideoCreateInput, coursevideoUncheckedCreateInput>
    /**
     * In case the coursevideo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<coursevideoUpdateInput, coursevideoUncheckedUpdateInput>
  }

  /**
   * coursevideo delete
   */
  export type coursevideoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coursevideo
     */
    select?: coursevideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coursevideo
     */
    omit?: coursevideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coursevideoInclude<ExtArgs> | null
    /**
     * Filter which coursevideo to delete.
     */
    where: coursevideoWhereUniqueInput
  }

  /**
   * coursevideo deleteMany
   */
  export type coursevideoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which coursevideos to delete
     */
    where?: coursevideoWhereInput
    /**
     * Limit how many coursevideos to delete.
     */
    limit?: number
  }

  /**
   * coursevideo without action
   */
  export type coursevideoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the coursevideo
     */
    select?: coursevideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the coursevideo
     */
    omit?: coursevideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coursevideoInclude<ExtArgs> | null
  }


  /**
   * Model cvreview
   */

  export type AggregateCvreview = {
    _count: CvreviewCountAggregateOutputType | null
    _avg: CvreviewAvgAggregateOutputType | null
    _sum: CvreviewSumAggregateOutputType | null
    _min: CvreviewMinAggregateOutputType | null
    _max: CvreviewMaxAggregateOutputType | null
  }

  export type CvreviewAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    cvVersion: number | null
    relevanceScore: number | null
  }

  export type CvreviewSumAggregateOutputType = {
    id: number | null
    userId: number | null
    cvVersion: number | null
    relevanceScore: number | null
  }

  export type CvreviewMinAggregateOutputType = {
    id: number | null
    userId: number | null
    cvFilePath: string | null
    cvVersion: number | null
    reviewResult: string | null
    relevanceScore: number | null
    feedback: string | null
    createdAt: Date | null
  }

  export type CvreviewMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    cvFilePath: string | null
    cvVersion: number | null
    reviewResult: string | null
    relevanceScore: number | null
    feedback: string | null
    createdAt: Date | null
  }

  export type CvreviewCountAggregateOutputType = {
    id: number
    userId: number
    cvFilePath: number
    cvVersion: number
    reviewResult: number
    relevanceScore: number
    feedback: number
    createdAt: number
    _all: number
  }


  export type CvreviewAvgAggregateInputType = {
    id?: true
    userId?: true
    cvVersion?: true
    relevanceScore?: true
  }

  export type CvreviewSumAggregateInputType = {
    id?: true
    userId?: true
    cvVersion?: true
    relevanceScore?: true
  }

  export type CvreviewMinAggregateInputType = {
    id?: true
    userId?: true
    cvFilePath?: true
    cvVersion?: true
    reviewResult?: true
    relevanceScore?: true
    feedback?: true
    createdAt?: true
  }

  export type CvreviewMaxAggregateInputType = {
    id?: true
    userId?: true
    cvFilePath?: true
    cvVersion?: true
    reviewResult?: true
    relevanceScore?: true
    feedback?: true
    createdAt?: true
  }

  export type CvreviewCountAggregateInputType = {
    id?: true
    userId?: true
    cvFilePath?: true
    cvVersion?: true
    reviewResult?: true
    relevanceScore?: true
    feedback?: true
    createdAt?: true
    _all?: true
  }

  export type CvreviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cvreview to aggregate.
     */
    where?: cvreviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cvreviews to fetch.
     */
    orderBy?: cvreviewOrderByWithRelationInput | cvreviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cvreviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cvreviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cvreviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cvreviews
    **/
    _count?: true | CvreviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CvreviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CvreviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CvreviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CvreviewMaxAggregateInputType
  }

  export type GetCvreviewAggregateType<T extends CvreviewAggregateArgs> = {
        [P in keyof T & keyof AggregateCvreview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCvreview[P]>
      : GetScalarType<T[P], AggregateCvreview[P]>
  }




  export type cvreviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cvreviewWhereInput
    orderBy?: cvreviewOrderByWithAggregationInput | cvreviewOrderByWithAggregationInput[]
    by: CvreviewScalarFieldEnum[] | CvreviewScalarFieldEnum
    having?: cvreviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CvreviewCountAggregateInputType | true
    _avg?: CvreviewAvgAggregateInputType
    _sum?: CvreviewSumAggregateInputType
    _min?: CvreviewMinAggregateInputType
    _max?: CvreviewMaxAggregateInputType
  }

  export type CvreviewGroupByOutputType = {
    id: number
    userId: number
    cvFilePath: string
    cvVersion: number
    reviewResult: string
    relevanceScore: number
    feedback: string
    createdAt: Date
    _count: CvreviewCountAggregateOutputType | null
    _avg: CvreviewAvgAggregateOutputType | null
    _sum: CvreviewSumAggregateOutputType | null
    _min: CvreviewMinAggregateOutputType | null
    _max: CvreviewMaxAggregateOutputType | null
  }

  type GetCvreviewGroupByPayload<T extends cvreviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CvreviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CvreviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CvreviewGroupByOutputType[P]>
            : GetScalarType<T[P], CvreviewGroupByOutputType[P]>
        }
      >
    >


  export type cvreviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    cvFilePath?: boolean
    cvVersion?: boolean
    reviewResult?: boolean
    relevanceScore?: boolean
    feedback?: boolean
    createdAt?: boolean
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cvreview"]>



  export type cvreviewSelectScalar = {
    id?: boolean
    userId?: boolean
    cvFilePath?: boolean
    cvVersion?: boolean
    reviewResult?: boolean
    relevanceScore?: boolean
    feedback?: boolean
    createdAt?: boolean
  }

  export type cvreviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "cvFilePath" | "cvVersion" | "reviewResult" | "relevanceScore" | "feedback" | "createdAt", ExtArgs["result"]["cvreview"]>
  export type cvreviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $cvreviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cvreview"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      cvFilePath: string
      cvVersion: number
      reviewResult: string
      relevanceScore: number
      feedback: string
      createdAt: Date
    }, ExtArgs["result"]["cvreview"]>
    composites: {}
  }

  type cvreviewGetPayload<S extends boolean | null | undefined | cvreviewDefaultArgs> = $Result.GetResult<Prisma.$cvreviewPayload, S>

  type cvreviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<cvreviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CvreviewCountAggregateInputType | true
    }

  export interface cvreviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cvreview'], meta: { name: 'cvreview' } }
    /**
     * Find zero or one Cvreview that matches the filter.
     * @param {cvreviewFindUniqueArgs} args - Arguments to find a Cvreview
     * @example
     * // Get one Cvreview
     * const cvreview = await prisma.cvreview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends cvreviewFindUniqueArgs>(args: SelectSubset<T, cvreviewFindUniqueArgs<ExtArgs>>): Prisma__cvreviewClient<$Result.GetResult<Prisma.$cvreviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cvreview that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {cvreviewFindUniqueOrThrowArgs} args - Arguments to find a Cvreview
     * @example
     * // Get one Cvreview
     * const cvreview = await prisma.cvreview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends cvreviewFindUniqueOrThrowArgs>(args: SelectSubset<T, cvreviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__cvreviewClient<$Result.GetResult<Prisma.$cvreviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cvreview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cvreviewFindFirstArgs} args - Arguments to find a Cvreview
     * @example
     * // Get one Cvreview
     * const cvreview = await prisma.cvreview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends cvreviewFindFirstArgs>(args?: SelectSubset<T, cvreviewFindFirstArgs<ExtArgs>>): Prisma__cvreviewClient<$Result.GetResult<Prisma.$cvreviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cvreview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cvreviewFindFirstOrThrowArgs} args - Arguments to find a Cvreview
     * @example
     * // Get one Cvreview
     * const cvreview = await prisma.cvreview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends cvreviewFindFirstOrThrowArgs>(args?: SelectSubset<T, cvreviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__cvreviewClient<$Result.GetResult<Prisma.$cvreviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cvreviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cvreviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cvreviews
     * const cvreviews = await prisma.cvreview.findMany()
     * 
     * // Get first 10 Cvreviews
     * const cvreviews = await prisma.cvreview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cvreviewWithIdOnly = await prisma.cvreview.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends cvreviewFindManyArgs>(args?: SelectSubset<T, cvreviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cvreviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cvreview.
     * @param {cvreviewCreateArgs} args - Arguments to create a Cvreview.
     * @example
     * // Create one Cvreview
     * const Cvreview = await prisma.cvreview.create({
     *   data: {
     *     // ... data to create a Cvreview
     *   }
     * })
     * 
     */
    create<T extends cvreviewCreateArgs>(args: SelectSubset<T, cvreviewCreateArgs<ExtArgs>>): Prisma__cvreviewClient<$Result.GetResult<Prisma.$cvreviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cvreviews.
     * @param {cvreviewCreateManyArgs} args - Arguments to create many Cvreviews.
     * @example
     * // Create many Cvreviews
     * const cvreview = await prisma.cvreview.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends cvreviewCreateManyArgs>(args?: SelectSubset<T, cvreviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Cvreview.
     * @param {cvreviewDeleteArgs} args - Arguments to delete one Cvreview.
     * @example
     * // Delete one Cvreview
     * const Cvreview = await prisma.cvreview.delete({
     *   where: {
     *     // ... filter to delete one Cvreview
     *   }
     * })
     * 
     */
    delete<T extends cvreviewDeleteArgs>(args: SelectSubset<T, cvreviewDeleteArgs<ExtArgs>>): Prisma__cvreviewClient<$Result.GetResult<Prisma.$cvreviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cvreview.
     * @param {cvreviewUpdateArgs} args - Arguments to update one Cvreview.
     * @example
     * // Update one Cvreview
     * const cvreview = await prisma.cvreview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends cvreviewUpdateArgs>(args: SelectSubset<T, cvreviewUpdateArgs<ExtArgs>>): Prisma__cvreviewClient<$Result.GetResult<Prisma.$cvreviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cvreviews.
     * @param {cvreviewDeleteManyArgs} args - Arguments to filter Cvreviews to delete.
     * @example
     * // Delete a few Cvreviews
     * const { count } = await prisma.cvreview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends cvreviewDeleteManyArgs>(args?: SelectSubset<T, cvreviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cvreviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cvreviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cvreviews
     * const cvreview = await prisma.cvreview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends cvreviewUpdateManyArgs>(args: SelectSubset<T, cvreviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cvreview.
     * @param {cvreviewUpsertArgs} args - Arguments to update or create a Cvreview.
     * @example
     * // Update or create a Cvreview
     * const cvreview = await prisma.cvreview.upsert({
     *   create: {
     *     // ... data to create a Cvreview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cvreview we want to update
     *   }
     * })
     */
    upsert<T extends cvreviewUpsertArgs>(args: SelectSubset<T, cvreviewUpsertArgs<ExtArgs>>): Prisma__cvreviewClient<$Result.GetResult<Prisma.$cvreviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cvreviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cvreviewCountArgs} args - Arguments to filter Cvreviews to count.
     * @example
     * // Count the number of Cvreviews
     * const count = await prisma.cvreview.count({
     *   where: {
     *     // ... the filter for the Cvreviews we want to count
     *   }
     * })
    **/
    count<T extends cvreviewCountArgs>(
      args?: Subset<T, cvreviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CvreviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cvreview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CvreviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CvreviewAggregateArgs>(args: Subset<T, CvreviewAggregateArgs>): Prisma.PrismaPromise<GetCvreviewAggregateType<T>>

    /**
     * Group by Cvreview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cvreviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends cvreviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cvreviewGroupByArgs['orderBy'] }
        : { orderBy?: cvreviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, cvreviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCvreviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cvreview model
   */
  readonly fields: cvreviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cvreview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__cvreviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the cvreview model
   */
  interface cvreviewFieldRefs {
    readonly id: FieldRef<"cvreview", 'Int'>
    readonly userId: FieldRef<"cvreview", 'Int'>
    readonly cvFilePath: FieldRef<"cvreview", 'String'>
    readonly cvVersion: FieldRef<"cvreview", 'Int'>
    readonly reviewResult: FieldRef<"cvreview", 'String'>
    readonly relevanceScore: FieldRef<"cvreview", 'Int'>
    readonly feedback: FieldRef<"cvreview", 'String'>
    readonly createdAt: FieldRef<"cvreview", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * cvreview findUnique
   */
  export type cvreviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cvreview
     */
    select?: cvreviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cvreview
     */
    omit?: cvreviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cvreviewInclude<ExtArgs> | null
    /**
     * Filter, which cvreview to fetch.
     */
    where: cvreviewWhereUniqueInput
  }

  /**
   * cvreview findUniqueOrThrow
   */
  export type cvreviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cvreview
     */
    select?: cvreviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cvreview
     */
    omit?: cvreviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cvreviewInclude<ExtArgs> | null
    /**
     * Filter, which cvreview to fetch.
     */
    where: cvreviewWhereUniqueInput
  }

  /**
   * cvreview findFirst
   */
  export type cvreviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cvreview
     */
    select?: cvreviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cvreview
     */
    omit?: cvreviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cvreviewInclude<ExtArgs> | null
    /**
     * Filter, which cvreview to fetch.
     */
    where?: cvreviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cvreviews to fetch.
     */
    orderBy?: cvreviewOrderByWithRelationInput | cvreviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cvreviews.
     */
    cursor?: cvreviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cvreviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cvreviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cvreviews.
     */
    distinct?: CvreviewScalarFieldEnum | CvreviewScalarFieldEnum[]
  }

  /**
   * cvreview findFirstOrThrow
   */
  export type cvreviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cvreview
     */
    select?: cvreviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cvreview
     */
    omit?: cvreviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cvreviewInclude<ExtArgs> | null
    /**
     * Filter, which cvreview to fetch.
     */
    where?: cvreviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cvreviews to fetch.
     */
    orderBy?: cvreviewOrderByWithRelationInput | cvreviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cvreviews.
     */
    cursor?: cvreviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cvreviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cvreviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cvreviews.
     */
    distinct?: CvreviewScalarFieldEnum | CvreviewScalarFieldEnum[]
  }

  /**
   * cvreview findMany
   */
  export type cvreviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cvreview
     */
    select?: cvreviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cvreview
     */
    omit?: cvreviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cvreviewInclude<ExtArgs> | null
    /**
     * Filter, which cvreviews to fetch.
     */
    where?: cvreviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cvreviews to fetch.
     */
    orderBy?: cvreviewOrderByWithRelationInput | cvreviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cvreviews.
     */
    cursor?: cvreviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cvreviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cvreviews.
     */
    skip?: number
    distinct?: CvreviewScalarFieldEnum | CvreviewScalarFieldEnum[]
  }

  /**
   * cvreview create
   */
  export type cvreviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cvreview
     */
    select?: cvreviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cvreview
     */
    omit?: cvreviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cvreviewInclude<ExtArgs> | null
    /**
     * The data needed to create a cvreview.
     */
    data: XOR<cvreviewCreateInput, cvreviewUncheckedCreateInput>
  }

  /**
   * cvreview createMany
   */
  export type cvreviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many cvreviews.
     */
    data: cvreviewCreateManyInput | cvreviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cvreview update
   */
  export type cvreviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cvreview
     */
    select?: cvreviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cvreview
     */
    omit?: cvreviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cvreviewInclude<ExtArgs> | null
    /**
     * The data needed to update a cvreview.
     */
    data: XOR<cvreviewUpdateInput, cvreviewUncheckedUpdateInput>
    /**
     * Choose, which cvreview to update.
     */
    where: cvreviewWhereUniqueInput
  }

  /**
   * cvreview updateMany
   */
  export type cvreviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update cvreviews.
     */
    data: XOR<cvreviewUpdateManyMutationInput, cvreviewUncheckedUpdateManyInput>
    /**
     * Filter which cvreviews to update
     */
    where?: cvreviewWhereInput
    /**
     * Limit how many cvreviews to update.
     */
    limit?: number
  }

  /**
   * cvreview upsert
   */
  export type cvreviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cvreview
     */
    select?: cvreviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cvreview
     */
    omit?: cvreviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cvreviewInclude<ExtArgs> | null
    /**
     * The filter to search for the cvreview to update in case it exists.
     */
    where: cvreviewWhereUniqueInput
    /**
     * In case the cvreview found by the `where` argument doesn't exist, create a new cvreview with this data.
     */
    create: XOR<cvreviewCreateInput, cvreviewUncheckedCreateInput>
    /**
     * In case the cvreview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cvreviewUpdateInput, cvreviewUncheckedUpdateInput>
  }

  /**
   * cvreview delete
   */
  export type cvreviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cvreview
     */
    select?: cvreviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cvreview
     */
    omit?: cvreviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cvreviewInclude<ExtArgs> | null
    /**
     * Filter which cvreview to delete.
     */
    where: cvreviewWhereUniqueInput
  }

  /**
   * cvreview deleteMany
   */
  export type cvreviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cvreviews to delete
     */
    where?: cvreviewWhereInput
    /**
     * Limit how many cvreviews to delete.
     */
    limit?: number
  }

  /**
   * cvreview without action
   */
  export type cvreviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cvreview
     */
    select?: cvreviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cvreview
     */
    omit?: cvreviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cvreviewInclude<ExtArgs> | null
  }


  /**
   * Model enrollment
   */

  export type AggregateEnrollment = {
    _count: EnrollmentCountAggregateOutputType | null
    _avg: EnrollmentAvgAggregateOutputType | null
    _sum: EnrollmentSumAggregateOutputType | null
    _min: EnrollmentMinAggregateOutputType | null
    _max: EnrollmentMaxAggregateOutputType | null
  }

  export type EnrollmentAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
    paymentId: number | null
  }

  export type EnrollmentSumAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
    paymentId: number | null
  }

  export type EnrollmentMinAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
    enrolledAt: Date | null
    isPaid: boolean | null
    paymentId: number | null
  }

  export type EnrollmentMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
    enrolledAt: Date | null
    isPaid: boolean | null
    paymentId: number | null
  }

  export type EnrollmentCountAggregateOutputType = {
    id: number
    userId: number
    courseId: number
    enrolledAt: number
    isPaid: number
    paymentId: number
    _all: number
  }


  export type EnrollmentAvgAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    paymentId?: true
  }

  export type EnrollmentSumAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    paymentId?: true
  }

  export type EnrollmentMinAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    enrolledAt?: true
    isPaid?: true
    paymentId?: true
  }

  export type EnrollmentMaxAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    enrolledAt?: true
    isPaid?: true
    paymentId?: true
  }

  export type EnrollmentCountAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    enrolledAt?: true
    isPaid?: true
    paymentId?: true
    _all?: true
  }

  export type EnrollmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which enrollment to aggregate.
     */
    where?: enrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of enrollments to fetch.
     */
    orderBy?: enrollmentOrderByWithRelationInput | enrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: enrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` enrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned enrollments
    **/
    _count?: true | EnrollmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EnrollmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EnrollmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnrollmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnrollmentMaxAggregateInputType
  }

  export type GetEnrollmentAggregateType<T extends EnrollmentAggregateArgs> = {
        [P in keyof T & keyof AggregateEnrollment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnrollment[P]>
      : GetScalarType<T[P], AggregateEnrollment[P]>
  }




  export type enrollmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: enrollmentWhereInput
    orderBy?: enrollmentOrderByWithAggregationInput | enrollmentOrderByWithAggregationInput[]
    by: EnrollmentScalarFieldEnum[] | EnrollmentScalarFieldEnum
    having?: enrollmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnrollmentCountAggregateInputType | true
    _avg?: EnrollmentAvgAggregateInputType
    _sum?: EnrollmentSumAggregateInputType
    _min?: EnrollmentMinAggregateInputType
    _max?: EnrollmentMaxAggregateInputType
  }

  export type EnrollmentGroupByOutputType = {
    id: number
    userId: number
    courseId: number
    enrolledAt: Date
    isPaid: boolean
    paymentId: number | null
    _count: EnrollmentCountAggregateOutputType | null
    _avg: EnrollmentAvgAggregateOutputType | null
    _sum: EnrollmentSumAggregateOutputType | null
    _min: EnrollmentMinAggregateOutputType | null
    _max: EnrollmentMaxAggregateOutputType | null
  }

  type GetEnrollmentGroupByPayload<T extends enrollmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EnrollmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnrollmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnrollmentGroupByOutputType[P]>
            : GetScalarType<T[P], EnrollmentGroupByOutputType[P]>
        }
      >
    >


  export type enrollmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    enrolledAt?: boolean
    isPaid?: boolean
    paymentId?: boolean
    course?: boolean | courseDefaultArgs<ExtArgs>
    payment?: boolean | enrollment$paymentArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enrollment"]>



  export type enrollmentSelectScalar = {
    id?: boolean
    userId?: boolean
    courseId?: boolean
    enrolledAt?: boolean
    isPaid?: boolean
    paymentId?: boolean
  }

  export type enrollmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "courseId" | "enrolledAt" | "isPaid" | "paymentId", ExtArgs["result"]["enrollment"]>
  export type enrollmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | courseDefaultArgs<ExtArgs>
    payment?: boolean | enrollment$paymentArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $enrollmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "enrollment"
    objects: {
      course: Prisma.$coursePayload<ExtArgs>
      payment: Prisma.$paymentPayload<ExtArgs> | null
      users: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      courseId: number
      enrolledAt: Date
      isPaid: boolean
      paymentId: number | null
    }, ExtArgs["result"]["enrollment"]>
    composites: {}
  }

  type enrollmentGetPayload<S extends boolean | null | undefined | enrollmentDefaultArgs> = $Result.GetResult<Prisma.$enrollmentPayload, S>

  type enrollmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<enrollmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EnrollmentCountAggregateInputType | true
    }

  export interface enrollmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['enrollment'], meta: { name: 'enrollment' } }
    /**
     * Find zero or one Enrollment that matches the filter.
     * @param {enrollmentFindUniqueArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends enrollmentFindUniqueArgs>(args: SelectSubset<T, enrollmentFindUniqueArgs<ExtArgs>>): Prisma__enrollmentClient<$Result.GetResult<Prisma.$enrollmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Enrollment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {enrollmentFindUniqueOrThrowArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends enrollmentFindUniqueOrThrowArgs>(args: SelectSubset<T, enrollmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__enrollmentClient<$Result.GetResult<Prisma.$enrollmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Enrollment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {enrollmentFindFirstArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends enrollmentFindFirstArgs>(args?: SelectSubset<T, enrollmentFindFirstArgs<ExtArgs>>): Prisma__enrollmentClient<$Result.GetResult<Prisma.$enrollmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Enrollment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {enrollmentFindFirstOrThrowArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends enrollmentFindFirstOrThrowArgs>(args?: SelectSubset<T, enrollmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__enrollmentClient<$Result.GetResult<Prisma.$enrollmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Enrollments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {enrollmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Enrollments
     * const enrollments = await prisma.enrollment.findMany()
     * 
     * // Get first 10 Enrollments
     * const enrollments = await prisma.enrollment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const enrollmentWithIdOnly = await prisma.enrollment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends enrollmentFindManyArgs>(args?: SelectSubset<T, enrollmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$enrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Enrollment.
     * @param {enrollmentCreateArgs} args - Arguments to create a Enrollment.
     * @example
     * // Create one Enrollment
     * const Enrollment = await prisma.enrollment.create({
     *   data: {
     *     // ... data to create a Enrollment
     *   }
     * })
     * 
     */
    create<T extends enrollmentCreateArgs>(args: SelectSubset<T, enrollmentCreateArgs<ExtArgs>>): Prisma__enrollmentClient<$Result.GetResult<Prisma.$enrollmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Enrollments.
     * @param {enrollmentCreateManyArgs} args - Arguments to create many Enrollments.
     * @example
     * // Create many Enrollments
     * const enrollment = await prisma.enrollment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends enrollmentCreateManyArgs>(args?: SelectSubset<T, enrollmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Enrollment.
     * @param {enrollmentDeleteArgs} args - Arguments to delete one Enrollment.
     * @example
     * // Delete one Enrollment
     * const Enrollment = await prisma.enrollment.delete({
     *   where: {
     *     // ... filter to delete one Enrollment
     *   }
     * })
     * 
     */
    delete<T extends enrollmentDeleteArgs>(args: SelectSubset<T, enrollmentDeleteArgs<ExtArgs>>): Prisma__enrollmentClient<$Result.GetResult<Prisma.$enrollmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Enrollment.
     * @param {enrollmentUpdateArgs} args - Arguments to update one Enrollment.
     * @example
     * // Update one Enrollment
     * const enrollment = await prisma.enrollment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends enrollmentUpdateArgs>(args: SelectSubset<T, enrollmentUpdateArgs<ExtArgs>>): Prisma__enrollmentClient<$Result.GetResult<Prisma.$enrollmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Enrollments.
     * @param {enrollmentDeleteManyArgs} args - Arguments to filter Enrollments to delete.
     * @example
     * // Delete a few Enrollments
     * const { count } = await prisma.enrollment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends enrollmentDeleteManyArgs>(args?: SelectSubset<T, enrollmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Enrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {enrollmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Enrollments
     * const enrollment = await prisma.enrollment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends enrollmentUpdateManyArgs>(args: SelectSubset<T, enrollmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Enrollment.
     * @param {enrollmentUpsertArgs} args - Arguments to update or create a Enrollment.
     * @example
     * // Update or create a Enrollment
     * const enrollment = await prisma.enrollment.upsert({
     *   create: {
     *     // ... data to create a Enrollment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Enrollment we want to update
     *   }
     * })
     */
    upsert<T extends enrollmentUpsertArgs>(args: SelectSubset<T, enrollmentUpsertArgs<ExtArgs>>): Prisma__enrollmentClient<$Result.GetResult<Prisma.$enrollmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Enrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {enrollmentCountArgs} args - Arguments to filter Enrollments to count.
     * @example
     * // Count the number of Enrollments
     * const count = await prisma.enrollment.count({
     *   where: {
     *     // ... the filter for the Enrollments we want to count
     *   }
     * })
    **/
    count<T extends enrollmentCountArgs>(
      args?: Subset<T, enrollmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnrollmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Enrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnrollmentAggregateArgs>(args: Subset<T, EnrollmentAggregateArgs>): Prisma.PrismaPromise<GetEnrollmentAggregateType<T>>

    /**
     * Group by Enrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {enrollmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends enrollmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: enrollmentGroupByArgs['orderBy'] }
        : { orderBy?: enrollmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, enrollmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnrollmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the enrollment model
   */
  readonly fields: enrollmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for enrollment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__enrollmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends courseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, courseDefaultArgs<ExtArgs>>): Prisma__courseClient<$Result.GetResult<Prisma.$coursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payment<T extends enrollment$paymentArgs<ExtArgs> = {}>(args?: Subset<T, enrollment$paymentArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the enrollment model
   */
  interface enrollmentFieldRefs {
    readonly id: FieldRef<"enrollment", 'Int'>
    readonly userId: FieldRef<"enrollment", 'Int'>
    readonly courseId: FieldRef<"enrollment", 'Int'>
    readonly enrolledAt: FieldRef<"enrollment", 'DateTime'>
    readonly isPaid: FieldRef<"enrollment", 'Boolean'>
    readonly paymentId: FieldRef<"enrollment", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * enrollment findUnique
   */
  export type enrollmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollment
     */
    select?: enrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrollment
     */
    omit?: enrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentInclude<ExtArgs> | null
    /**
     * Filter, which enrollment to fetch.
     */
    where: enrollmentWhereUniqueInput
  }

  /**
   * enrollment findUniqueOrThrow
   */
  export type enrollmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollment
     */
    select?: enrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrollment
     */
    omit?: enrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentInclude<ExtArgs> | null
    /**
     * Filter, which enrollment to fetch.
     */
    where: enrollmentWhereUniqueInput
  }

  /**
   * enrollment findFirst
   */
  export type enrollmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollment
     */
    select?: enrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrollment
     */
    omit?: enrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentInclude<ExtArgs> | null
    /**
     * Filter, which enrollment to fetch.
     */
    where?: enrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of enrollments to fetch.
     */
    orderBy?: enrollmentOrderByWithRelationInput | enrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for enrollments.
     */
    cursor?: enrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` enrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of enrollments.
     */
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * enrollment findFirstOrThrow
   */
  export type enrollmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollment
     */
    select?: enrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrollment
     */
    omit?: enrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentInclude<ExtArgs> | null
    /**
     * Filter, which enrollment to fetch.
     */
    where?: enrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of enrollments to fetch.
     */
    orderBy?: enrollmentOrderByWithRelationInput | enrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for enrollments.
     */
    cursor?: enrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` enrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of enrollments.
     */
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * enrollment findMany
   */
  export type enrollmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollment
     */
    select?: enrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrollment
     */
    omit?: enrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentInclude<ExtArgs> | null
    /**
     * Filter, which enrollments to fetch.
     */
    where?: enrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of enrollments to fetch.
     */
    orderBy?: enrollmentOrderByWithRelationInput | enrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing enrollments.
     */
    cursor?: enrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` enrollments.
     */
    skip?: number
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * enrollment create
   */
  export type enrollmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollment
     */
    select?: enrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrollment
     */
    omit?: enrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentInclude<ExtArgs> | null
    /**
     * The data needed to create a enrollment.
     */
    data: XOR<enrollmentCreateInput, enrollmentUncheckedCreateInput>
  }

  /**
   * enrollment createMany
   */
  export type enrollmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many enrollments.
     */
    data: enrollmentCreateManyInput | enrollmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * enrollment update
   */
  export type enrollmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollment
     */
    select?: enrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrollment
     */
    omit?: enrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentInclude<ExtArgs> | null
    /**
     * The data needed to update a enrollment.
     */
    data: XOR<enrollmentUpdateInput, enrollmentUncheckedUpdateInput>
    /**
     * Choose, which enrollment to update.
     */
    where: enrollmentWhereUniqueInput
  }

  /**
   * enrollment updateMany
   */
  export type enrollmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update enrollments.
     */
    data: XOR<enrollmentUpdateManyMutationInput, enrollmentUncheckedUpdateManyInput>
    /**
     * Filter which enrollments to update
     */
    where?: enrollmentWhereInput
    /**
     * Limit how many enrollments to update.
     */
    limit?: number
  }

  /**
   * enrollment upsert
   */
  export type enrollmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollment
     */
    select?: enrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrollment
     */
    omit?: enrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentInclude<ExtArgs> | null
    /**
     * The filter to search for the enrollment to update in case it exists.
     */
    where: enrollmentWhereUniqueInput
    /**
     * In case the enrollment found by the `where` argument doesn't exist, create a new enrollment with this data.
     */
    create: XOR<enrollmentCreateInput, enrollmentUncheckedCreateInput>
    /**
     * In case the enrollment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<enrollmentUpdateInput, enrollmentUncheckedUpdateInput>
  }

  /**
   * enrollment delete
   */
  export type enrollmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollment
     */
    select?: enrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrollment
     */
    omit?: enrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentInclude<ExtArgs> | null
    /**
     * Filter which enrollment to delete.
     */
    where: enrollmentWhereUniqueInput
  }

  /**
   * enrollment deleteMany
   */
  export type enrollmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which enrollments to delete
     */
    where?: enrollmentWhereInput
    /**
     * Limit how many enrollments to delete.
     */
    limit?: number
  }

  /**
   * enrollment.payment
   */
  export type enrollment$paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    where?: paymentWhereInput
  }

  /**
   * enrollment without action
   */
  export type enrollmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollment
     */
    select?: enrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrollment
     */
    omit?: enrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentInclude<ExtArgs> | null
  }


  /**
   * Model jobmatch
   */

  export type AggregateJobmatch = {
    _count: JobmatchCountAggregateOutputType | null
    _avg: JobmatchAvgAggregateOutputType | null
    _sum: JobmatchSumAggregateOutputType | null
    _min: JobmatchMinAggregateOutputType | null
    _max: JobmatchMaxAggregateOutputType | null
  }

  export type JobmatchAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type JobmatchSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type JobmatchMinAggregateOutputType = {
    id: number | null
    userId: number | null
    cvFilePath: string | null
    generatedAt: Date | null
  }

  export type JobmatchMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    cvFilePath: string | null
    generatedAt: Date | null
  }

  export type JobmatchCountAggregateOutputType = {
    id: number
    userId: number
    cvFilePath: number
    matchedJobs: number
    generatedAt: number
    _all: number
  }


  export type JobmatchAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type JobmatchSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type JobmatchMinAggregateInputType = {
    id?: true
    userId?: true
    cvFilePath?: true
    generatedAt?: true
  }

  export type JobmatchMaxAggregateInputType = {
    id?: true
    userId?: true
    cvFilePath?: true
    generatedAt?: true
  }

  export type JobmatchCountAggregateInputType = {
    id?: true
    userId?: true
    cvFilePath?: true
    matchedJobs?: true
    generatedAt?: true
    _all?: true
  }

  export type JobmatchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which jobmatch to aggregate.
     */
    where?: jobmatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobmatches to fetch.
     */
    orderBy?: jobmatchOrderByWithRelationInput | jobmatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: jobmatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobmatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobmatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned jobmatches
    **/
    _count?: true | JobmatchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobmatchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobmatchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobmatchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobmatchMaxAggregateInputType
  }

  export type GetJobmatchAggregateType<T extends JobmatchAggregateArgs> = {
        [P in keyof T & keyof AggregateJobmatch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobmatch[P]>
      : GetScalarType<T[P], AggregateJobmatch[P]>
  }




  export type jobmatchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: jobmatchWhereInput
    orderBy?: jobmatchOrderByWithAggregationInput | jobmatchOrderByWithAggregationInput[]
    by: JobmatchScalarFieldEnum[] | JobmatchScalarFieldEnum
    having?: jobmatchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobmatchCountAggregateInputType | true
    _avg?: JobmatchAvgAggregateInputType
    _sum?: JobmatchSumAggregateInputType
    _min?: JobmatchMinAggregateInputType
    _max?: JobmatchMaxAggregateInputType
  }

  export type JobmatchGroupByOutputType = {
    id: number
    userId: number
    cvFilePath: string
    matchedJobs: JsonValue
    generatedAt: Date
    _count: JobmatchCountAggregateOutputType | null
    _avg: JobmatchAvgAggregateOutputType | null
    _sum: JobmatchSumAggregateOutputType | null
    _min: JobmatchMinAggregateOutputType | null
    _max: JobmatchMaxAggregateOutputType | null
  }

  type GetJobmatchGroupByPayload<T extends jobmatchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobmatchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobmatchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobmatchGroupByOutputType[P]>
            : GetScalarType<T[P], JobmatchGroupByOutputType[P]>
        }
      >
    >


  export type jobmatchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    cvFilePath?: boolean
    matchedJobs?: boolean
    generatedAt?: boolean
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobmatch"]>



  export type jobmatchSelectScalar = {
    id?: boolean
    userId?: boolean
    cvFilePath?: boolean
    matchedJobs?: boolean
    generatedAt?: boolean
  }

  export type jobmatchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "cvFilePath" | "matchedJobs" | "generatedAt", ExtArgs["result"]["jobmatch"]>
  export type jobmatchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $jobmatchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "jobmatch"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      cvFilePath: string
      matchedJobs: Prisma.JsonValue
      generatedAt: Date
    }, ExtArgs["result"]["jobmatch"]>
    composites: {}
  }

  type jobmatchGetPayload<S extends boolean | null | undefined | jobmatchDefaultArgs> = $Result.GetResult<Prisma.$jobmatchPayload, S>

  type jobmatchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<jobmatchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobmatchCountAggregateInputType | true
    }

  export interface jobmatchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['jobmatch'], meta: { name: 'jobmatch' } }
    /**
     * Find zero or one Jobmatch that matches the filter.
     * @param {jobmatchFindUniqueArgs} args - Arguments to find a Jobmatch
     * @example
     * // Get one Jobmatch
     * const jobmatch = await prisma.jobmatch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends jobmatchFindUniqueArgs>(args: SelectSubset<T, jobmatchFindUniqueArgs<ExtArgs>>): Prisma__jobmatchClient<$Result.GetResult<Prisma.$jobmatchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Jobmatch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {jobmatchFindUniqueOrThrowArgs} args - Arguments to find a Jobmatch
     * @example
     * // Get one Jobmatch
     * const jobmatch = await prisma.jobmatch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends jobmatchFindUniqueOrThrowArgs>(args: SelectSubset<T, jobmatchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__jobmatchClient<$Result.GetResult<Prisma.$jobmatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Jobmatch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobmatchFindFirstArgs} args - Arguments to find a Jobmatch
     * @example
     * // Get one Jobmatch
     * const jobmatch = await prisma.jobmatch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends jobmatchFindFirstArgs>(args?: SelectSubset<T, jobmatchFindFirstArgs<ExtArgs>>): Prisma__jobmatchClient<$Result.GetResult<Prisma.$jobmatchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Jobmatch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobmatchFindFirstOrThrowArgs} args - Arguments to find a Jobmatch
     * @example
     * // Get one Jobmatch
     * const jobmatch = await prisma.jobmatch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends jobmatchFindFirstOrThrowArgs>(args?: SelectSubset<T, jobmatchFindFirstOrThrowArgs<ExtArgs>>): Prisma__jobmatchClient<$Result.GetResult<Prisma.$jobmatchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Jobmatches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobmatchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Jobmatches
     * const jobmatches = await prisma.jobmatch.findMany()
     * 
     * // Get first 10 Jobmatches
     * const jobmatches = await prisma.jobmatch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobmatchWithIdOnly = await prisma.jobmatch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends jobmatchFindManyArgs>(args?: SelectSubset<T, jobmatchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$jobmatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Jobmatch.
     * @param {jobmatchCreateArgs} args - Arguments to create a Jobmatch.
     * @example
     * // Create one Jobmatch
     * const Jobmatch = await prisma.jobmatch.create({
     *   data: {
     *     // ... data to create a Jobmatch
     *   }
     * })
     * 
     */
    create<T extends jobmatchCreateArgs>(args: SelectSubset<T, jobmatchCreateArgs<ExtArgs>>): Prisma__jobmatchClient<$Result.GetResult<Prisma.$jobmatchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Jobmatches.
     * @param {jobmatchCreateManyArgs} args - Arguments to create many Jobmatches.
     * @example
     * // Create many Jobmatches
     * const jobmatch = await prisma.jobmatch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends jobmatchCreateManyArgs>(args?: SelectSubset<T, jobmatchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Jobmatch.
     * @param {jobmatchDeleteArgs} args - Arguments to delete one Jobmatch.
     * @example
     * // Delete one Jobmatch
     * const Jobmatch = await prisma.jobmatch.delete({
     *   where: {
     *     // ... filter to delete one Jobmatch
     *   }
     * })
     * 
     */
    delete<T extends jobmatchDeleteArgs>(args: SelectSubset<T, jobmatchDeleteArgs<ExtArgs>>): Prisma__jobmatchClient<$Result.GetResult<Prisma.$jobmatchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Jobmatch.
     * @param {jobmatchUpdateArgs} args - Arguments to update one Jobmatch.
     * @example
     * // Update one Jobmatch
     * const jobmatch = await prisma.jobmatch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends jobmatchUpdateArgs>(args: SelectSubset<T, jobmatchUpdateArgs<ExtArgs>>): Prisma__jobmatchClient<$Result.GetResult<Prisma.$jobmatchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Jobmatches.
     * @param {jobmatchDeleteManyArgs} args - Arguments to filter Jobmatches to delete.
     * @example
     * // Delete a few Jobmatches
     * const { count } = await prisma.jobmatch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends jobmatchDeleteManyArgs>(args?: SelectSubset<T, jobmatchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jobmatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobmatchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Jobmatches
     * const jobmatch = await prisma.jobmatch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends jobmatchUpdateManyArgs>(args: SelectSubset<T, jobmatchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Jobmatch.
     * @param {jobmatchUpsertArgs} args - Arguments to update or create a Jobmatch.
     * @example
     * // Update or create a Jobmatch
     * const jobmatch = await prisma.jobmatch.upsert({
     *   create: {
     *     // ... data to create a Jobmatch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Jobmatch we want to update
     *   }
     * })
     */
    upsert<T extends jobmatchUpsertArgs>(args: SelectSubset<T, jobmatchUpsertArgs<ExtArgs>>): Prisma__jobmatchClient<$Result.GetResult<Prisma.$jobmatchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Jobmatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobmatchCountArgs} args - Arguments to filter Jobmatches to count.
     * @example
     * // Count the number of Jobmatches
     * const count = await prisma.jobmatch.count({
     *   where: {
     *     // ... the filter for the Jobmatches we want to count
     *   }
     * })
    **/
    count<T extends jobmatchCountArgs>(
      args?: Subset<T, jobmatchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobmatchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Jobmatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobmatchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobmatchAggregateArgs>(args: Subset<T, JobmatchAggregateArgs>): Prisma.PrismaPromise<GetJobmatchAggregateType<T>>

    /**
     * Group by Jobmatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobmatchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends jobmatchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: jobmatchGroupByArgs['orderBy'] }
        : { orderBy?: jobmatchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, jobmatchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobmatchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the jobmatch model
   */
  readonly fields: jobmatchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for jobmatch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__jobmatchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the jobmatch model
   */
  interface jobmatchFieldRefs {
    readonly id: FieldRef<"jobmatch", 'Int'>
    readonly userId: FieldRef<"jobmatch", 'Int'>
    readonly cvFilePath: FieldRef<"jobmatch", 'String'>
    readonly matchedJobs: FieldRef<"jobmatch", 'Json'>
    readonly generatedAt: FieldRef<"jobmatch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * jobmatch findUnique
   */
  export type jobmatchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobmatch
     */
    select?: jobmatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobmatch
     */
    omit?: jobmatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobmatchInclude<ExtArgs> | null
    /**
     * Filter, which jobmatch to fetch.
     */
    where: jobmatchWhereUniqueInput
  }

  /**
   * jobmatch findUniqueOrThrow
   */
  export type jobmatchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobmatch
     */
    select?: jobmatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobmatch
     */
    omit?: jobmatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobmatchInclude<ExtArgs> | null
    /**
     * Filter, which jobmatch to fetch.
     */
    where: jobmatchWhereUniqueInput
  }

  /**
   * jobmatch findFirst
   */
  export type jobmatchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobmatch
     */
    select?: jobmatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobmatch
     */
    omit?: jobmatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobmatchInclude<ExtArgs> | null
    /**
     * Filter, which jobmatch to fetch.
     */
    where?: jobmatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobmatches to fetch.
     */
    orderBy?: jobmatchOrderByWithRelationInput | jobmatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for jobmatches.
     */
    cursor?: jobmatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobmatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobmatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of jobmatches.
     */
    distinct?: JobmatchScalarFieldEnum | JobmatchScalarFieldEnum[]
  }

  /**
   * jobmatch findFirstOrThrow
   */
  export type jobmatchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobmatch
     */
    select?: jobmatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobmatch
     */
    omit?: jobmatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobmatchInclude<ExtArgs> | null
    /**
     * Filter, which jobmatch to fetch.
     */
    where?: jobmatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobmatches to fetch.
     */
    orderBy?: jobmatchOrderByWithRelationInput | jobmatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for jobmatches.
     */
    cursor?: jobmatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobmatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobmatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of jobmatches.
     */
    distinct?: JobmatchScalarFieldEnum | JobmatchScalarFieldEnum[]
  }

  /**
   * jobmatch findMany
   */
  export type jobmatchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobmatch
     */
    select?: jobmatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobmatch
     */
    omit?: jobmatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobmatchInclude<ExtArgs> | null
    /**
     * Filter, which jobmatches to fetch.
     */
    where?: jobmatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobmatches to fetch.
     */
    orderBy?: jobmatchOrderByWithRelationInput | jobmatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing jobmatches.
     */
    cursor?: jobmatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobmatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobmatches.
     */
    skip?: number
    distinct?: JobmatchScalarFieldEnum | JobmatchScalarFieldEnum[]
  }

  /**
   * jobmatch create
   */
  export type jobmatchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobmatch
     */
    select?: jobmatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobmatch
     */
    omit?: jobmatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobmatchInclude<ExtArgs> | null
    /**
     * The data needed to create a jobmatch.
     */
    data: XOR<jobmatchCreateInput, jobmatchUncheckedCreateInput>
  }

  /**
   * jobmatch createMany
   */
  export type jobmatchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many jobmatches.
     */
    data: jobmatchCreateManyInput | jobmatchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * jobmatch update
   */
  export type jobmatchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobmatch
     */
    select?: jobmatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobmatch
     */
    omit?: jobmatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobmatchInclude<ExtArgs> | null
    /**
     * The data needed to update a jobmatch.
     */
    data: XOR<jobmatchUpdateInput, jobmatchUncheckedUpdateInput>
    /**
     * Choose, which jobmatch to update.
     */
    where: jobmatchWhereUniqueInput
  }

  /**
   * jobmatch updateMany
   */
  export type jobmatchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update jobmatches.
     */
    data: XOR<jobmatchUpdateManyMutationInput, jobmatchUncheckedUpdateManyInput>
    /**
     * Filter which jobmatches to update
     */
    where?: jobmatchWhereInput
    /**
     * Limit how many jobmatches to update.
     */
    limit?: number
  }

  /**
   * jobmatch upsert
   */
  export type jobmatchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobmatch
     */
    select?: jobmatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobmatch
     */
    omit?: jobmatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobmatchInclude<ExtArgs> | null
    /**
     * The filter to search for the jobmatch to update in case it exists.
     */
    where: jobmatchWhereUniqueInput
    /**
     * In case the jobmatch found by the `where` argument doesn't exist, create a new jobmatch with this data.
     */
    create: XOR<jobmatchCreateInput, jobmatchUncheckedCreateInput>
    /**
     * In case the jobmatch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<jobmatchUpdateInput, jobmatchUncheckedUpdateInput>
  }

  /**
   * jobmatch delete
   */
  export type jobmatchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobmatch
     */
    select?: jobmatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobmatch
     */
    omit?: jobmatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobmatchInclude<ExtArgs> | null
    /**
     * Filter which jobmatch to delete.
     */
    where: jobmatchWhereUniqueInput
  }

  /**
   * jobmatch deleteMany
   */
  export type jobmatchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which jobmatches to delete
     */
    where?: jobmatchWhereInput
    /**
     * Limit how many jobmatches to delete.
     */
    limit?: number
  }

  /**
   * jobmatch without action
   */
  export type jobmatchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobmatch
     */
    select?: jobmatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobmatch
     */
    omit?: jobmatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobmatchInclude<ExtArgs> | null
  }


  /**
   * Model lesson
   */

  export type AggregateLesson = {
    _count: LessonCountAggregateOutputType | null
    _avg: LessonAvgAggregateOutputType | null
    _sum: LessonSumAggregateOutputType | null
    _min: LessonMinAggregateOutputType | null
    _max: LessonMaxAggregateOutputType | null
  }

  export type LessonAvgAggregateOutputType = {
    id: number | null
    courseId: number | null
    order: number | null
  }

  export type LessonSumAggregateOutputType = {
    id: number | null
    courseId: number | null
    order: number | null
  }

  export type LessonMinAggregateOutputType = {
    id: number | null
    title: string | null
    courseId: number | null
    content: string | null
    order: number | null
  }

  export type LessonMaxAggregateOutputType = {
    id: number | null
    title: string | null
    courseId: number | null
    content: string | null
    order: number | null
  }

  export type LessonCountAggregateOutputType = {
    id: number
    title: number
    courseId: number
    content: number
    order: number
    _all: number
  }


  export type LessonAvgAggregateInputType = {
    id?: true
    courseId?: true
    order?: true
  }

  export type LessonSumAggregateInputType = {
    id?: true
    courseId?: true
    order?: true
  }

  export type LessonMinAggregateInputType = {
    id?: true
    title?: true
    courseId?: true
    content?: true
    order?: true
  }

  export type LessonMaxAggregateInputType = {
    id?: true
    title?: true
    courseId?: true
    content?: true
    order?: true
  }

  export type LessonCountAggregateInputType = {
    id?: true
    title?: true
    courseId?: true
    content?: true
    order?: true
    _all?: true
  }

  export type LessonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which lesson to aggregate.
     */
    where?: lessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lessons to fetch.
     */
    orderBy?: lessonOrderByWithRelationInput | lessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: lessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned lessons
    **/
    _count?: true | LessonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LessonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LessonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LessonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LessonMaxAggregateInputType
  }

  export type GetLessonAggregateType<T extends LessonAggregateArgs> = {
        [P in keyof T & keyof AggregateLesson]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLesson[P]>
      : GetScalarType<T[P], AggregateLesson[P]>
  }




  export type lessonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: lessonWhereInput
    orderBy?: lessonOrderByWithAggregationInput | lessonOrderByWithAggregationInput[]
    by: LessonScalarFieldEnum[] | LessonScalarFieldEnum
    having?: lessonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LessonCountAggregateInputType | true
    _avg?: LessonAvgAggregateInputType
    _sum?: LessonSumAggregateInputType
    _min?: LessonMinAggregateInputType
    _max?: LessonMaxAggregateInputType
  }

  export type LessonGroupByOutputType = {
    id: number
    title: string
    courseId: number
    content: string
    order: number
    _count: LessonCountAggregateOutputType | null
    _avg: LessonAvgAggregateOutputType | null
    _sum: LessonSumAggregateOutputType | null
    _min: LessonMinAggregateOutputType | null
    _max: LessonMaxAggregateOutputType | null
  }

  type GetLessonGroupByPayload<T extends lessonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LessonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LessonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LessonGroupByOutputType[P]>
            : GetScalarType<T[P], LessonGroupByOutputType[P]>
        }
      >
    >


  export type lessonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    courseId?: boolean
    content?: boolean
    order?: boolean
    course?: boolean | courseDefaultArgs<ExtArgs>
    lessonprogress?: boolean | lesson$lessonprogressArgs<ExtArgs>
    _count?: boolean | LessonCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lesson"]>



  export type lessonSelectScalar = {
    id?: boolean
    title?: boolean
    courseId?: boolean
    content?: boolean
    order?: boolean
  }

  export type lessonOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "courseId" | "content" | "order", ExtArgs["result"]["lesson"]>
  export type lessonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | courseDefaultArgs<ExtArgs>
    lessonprogress?: boolean | lesson$lessonprogressArgs<ExtArgs>
    _count?: boolean | LessonCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $lessonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "lesson"
    objects: {
      course: Prisma.$coursePayload<ExtArgs>
      lessonprogress: Prisma.$lessonprogressPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      courseId: number
      content: string
      order: number
    }, ExtArgs["result"]["lesson"]>
    composites: {}
  }

  type lessonGetPayload<S extends boolean | null | undefined | lessonDefaultArgs> = $Result.GetResult<Prisma.$lessonPayload, S>

  type lessonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<lessonFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LessonCountAggregateInputType | true
    }

  export interface lessonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['lesson'], meta: { name: 'lesson' } }
    /**
     * Find zero or one Lesson that matches the filter.
     * @param {lessonFindUniqueArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends lessonFindUniqueArgs>(args: SelectSubset<T, lessonFindUniqueArgs<ExtArgs>>): Prisma__lessonClient<$Result.GetResult<Prisma.$lessonPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lesson that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {lessonFindUniqueOrThrowArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends lessonFindUniqueOrThrowArgs>(args: SelectSubset<T, lessonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__lessonClient<$Result.GetResult<Prisma.$lessonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lesson that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lessonFindFirstArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends lessonFindFirstArgs>(args?: SelectSubset<T, lessonFindFirstArgs<ExtArgs>>): Prisma__lessonClient<$Result.GetResult<Prisma.$lessonPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lesson that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lessonFindFirstOrThrowArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends lessonFindFirstOrThrowArgs>(args?: SelectSubset<T, lessonFindFirstOrThrowArgs<ExtArgs>>): Prisma__lessonClient<$Result.GetResult<Prisma.$lessonPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Lessons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lessonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lessons
     * const lessons = await prisma.lesson.findMany()
     * 
     * // Get first 10 Lessons
     * const lessons = await prisma.lesson.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lessonWithIdOnly = await prisma.lesson.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends lessonFindManyArgs>(args?: SelectSubset<T, lessonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lessonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lesson.
     * @param {lessonCreateArgs} args - Arguments to create a Lesson.
     * @example
     * // Create one Lesson
     * const Lesson = await prisma.lesson.create({
     *   data: {
     *     // ... data to create a Lesson
     *   }
     * })
     * 
     */
    create<T extends lessonCreateArgs>(args: SelectSubset<T, lessonCreateArgs<ExtArgs>>): Prisma__lessonClient<$Result.GetResult<Prisma.$lessonPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Lessons.
     * @param {lessonCreateManyArgs} args - Arguments to create many Lessons.
     * @example
     * // Create many Lessons
     * const lesson = await prisma.lesson.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends lessonCreateManyArgs>(args?: SelectSubset<T, lessonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Lesson.
     * @param {lessonDeleteArgs} args - Arguments to delete one Lesson.
     * @example
     * // Delete one Lesson
     * const Lesson = await prisma.lesson.delete({
     *   where: {
     *     // ... filter to delete one Lesson
     *   }
     * })
     * 
     */
    delete<T extends lessonDeleteArgs>(args: SelectSubset<T, lessonDeleteArgs<ExtArgs>>): Prisma__lessonClient<$Result.GetResult<Prisma.$lessonPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lesson.
     * @param {lessonUpdateArgs} args - Arguments to update one Lesson.
     * @example
     * // Update one Lesson
     * const lesson = await prisma.lesson.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends lessonUpdateArgs>(args: SelectSubset<T, lessonUpdateArgs<ExtArgs>>): Prisma__lessonClient<$Result.GetResult<Prisma.$lessonPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Lessons.
     * @param {lessonDeleteManyArgs} args - Arguments to filter Lessons to delete.
     * @example
     * // Delete a few Lessons
     * const { count } = await prisma.lesson.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends lessonDeleteManyArgs>(args?: SelectSubset<T, lessonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lessonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lessons
     * const lesson = await prisma.lesson.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends lessonUpdateManyArgs>(args: SelectSubset<T, lessonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lesson.
     * @param {lessonUpsertArgs} args - Arguments to update or create a Lesson.
     * @example
     * // Update or create a Lesson
     * const lesson = await prisma.lesson.upsert({
     *   create: {
     *     // ... data to create a Lesson
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lesson we want to update
     *   }
     * })
     */
    upsert<T extends lessonUpsertArgs>(args: SelectSubset<T, lessonUpsertArgs<ExtArgs>>): Prisma__lessonClient<$Result.GetResult<Prisma.$lessonPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lessonCountArgs} args - Arguments to filter Lessons to count.
     * @example
     * // Count the number of Lessons
     * const count = await prisma.lesson.count({
     *   where: {
     *     // ... the filter for the Lessons we want to count
     *   }
     * })
    **/
    count<T extends lessonCountArgs>(
      args?: Subset<T, lessonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LessonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lesson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LessonAggregateArgs>(args: Subset<T, LessonAggregateArgs>): Prisma.PrismaPromise<GetLessonAggregateType<T>>

    /**
     * Group by Lesson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lessonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends lessonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: lessonGroupByArgs['orderBy'] }
        : { orderBy?: lessonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, lessonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLessonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the lesson model
   */
  readonly fields: lessonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for lesson.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__lessonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends courseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, courseDefaultArgs<ExtArgs>>): Prisma__courseClient<$Result.GetResult<Prisma.$coursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lessonprogress<T extends lesson$lessonprogressArgs<ExtArgs> = {}>(args?: Subset<T, lesson$lessonprogressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lessonprogressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the lesson model
   */
  interface lessonFieldRefs {
    readonly id: FieldRef<"lesson", 'Int'>
    readonly title: FieldRef<"lesson", 'String'>
    readonly courseId: FieldRef<"lesson", 'Int'>
    readonly content: FieldRef<"lesson", 'String'>
    readonly order: FieldRef<"lesson", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * lesson findUnique
   */
  export type lessonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lesson
     */
    select?: lessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lesson
     */
    omit?: lessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lessonInclude<ExtArgs> | null
    /**
     * Filter, which lesson to fetch.
     */
    where: lessonWhereUniqueInput
  }

  /**
   * lesson findUniqueOrThrow
   */
  export type lessonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lesson
     */
    select?: lessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lesson
     */
    omit?: lessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lessonInclude<ExtArgs> | null
    /**
     * Filter, which lesson to fetch.
     */
    where: lessonWhereUniqueInput
  }

  /**
   * lesson findFirst
   */
  export type lessonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lesson
     */
    select?: lessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lesson
     */
    omit?: lessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lessonInclude<ExtArgs> | null
    /**
     * Filter, which lesson to fetch.
     */
    where?: lessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lessons to fetch.
     */
    orderBy?: lessonOrderByWithRelationInput | lessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lessons.
     */
    cursor?: lessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lessons.
     */
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * lesson findFirstOrThrow
   */
  export type lessonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lesson
     */
    select?: lessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lesson
     */
    omit?: lessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lessonInclude<ExtArgs> | null
    /**
     * Filter, which lesson to fetch.
     */
    where?: lessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lessons to fetch.
     */
    orderBy?: lessonOrderByWithRelationInput | lessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lessons.
     */
    cursor?: lessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lessons.
     */
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * lesson findMany
   */
  export type lessonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lesson
     */
    select?: lessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lesson
     */
    omit?: lessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lessonInclude<ExtArgs> | null
    /**
     * Filter, which lessons to fetch.
     */
    where?: lessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lessons to fetch.
     */
    orderBy?: lessonOrderByWithRelationInput | lessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing lessons.
     */
    cursor?: lessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lessons.
     */
    skip?: number
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * lesson create
   */
  export type lessonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lesson
     */
    select?: lessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lesson
     */
    omit?: lessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lessonInclude<ExtArgs> | null
    /**
     * The data needed to create a lesson.
     */
    data: XOR<lessonCreateInput, lessonUncheckedCreateInput>
  }

  /**
   * lesson createMany
   */
  export type lessonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many lessons.
     */
    data: lessonCreateManyInput | lessonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * lesson update
   */
  export type lessonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lesson
     */
    select?: lessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lesson
     */
    omit?: lessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lessonInclude<ExtArgs> | null
    /**
     * The data needed to update a lesson.
     */
    data: XOR<lessonUpdateInput, lessonUncheckedUpdateInput>
    /**
     * Choose, which lesson to update.
     */
    where: lessonWhereUniqueInput
  }

  /**
   * lesson updateMany
   */
  export type lessonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update lessons.
     */
    data: XOR<lessonUpdateManyMutationInput, lessonUncheckedUpdateManyInput>
    /**
     * Filter which lessons to update
     */
    where?: lessonWhereInput
    /**
     * Limit how many lessons to update.
     */
    limit?: number
  }

  /**
   * lesson upsert
   */
  export type lessonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lesson
     */
    select?: lessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lesson
     */
    omit?: lessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lessonInclude<ExtArgs> | null
    /**
     * The filter to search for the lesson to update in case it exists.
     */
    where: lessonWhereUniqueInput
    /**
     * In case the lesson found by the `where` argument doesn't exist, create a new lesson with this data.
     */
    create: XOR<lessonCreateInput, lessonUncheckedCreateInput>
    /**
     * In case the lesson was found with the provided `where` argument, update it with this data.
     */
    update: XOR<lessonUpdateInput, lessonUncheckedUpdateInput>
  }

  /**
   * lesson delete
   */
  export type lessonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lesson
     */
    select?: lessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lesson
     */
    omit?: lessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lessonInclude<ExtArgs> | null
    /**
     * Filter which lesson to delete.
     */
    where: lessonWhereUniqueInput
  }

  /**
   * lesson deleteMany
   */
  export type lessonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which lessons to delete
     */
    where?: lessonWhereInput
    /**
     * Limit how many lessons to delete.
     */
    limit?: number
  }

  /**
   * lesson.lessonprogress
   */
  export type lesson$lessonprogressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lessonprogress
     */
    select?: lessonprogressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lessonprogress
     */
    omit?: lessonprogressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lessonprogressInclude<ExtArgs> | null
    where?: lessonprogressWhereInput
    orderBy?: lessonprogressOrderByWithRelationInput | lessonprogressOrderByWithRelationInput[]
    cursor?: lessonprogressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonprogressScalarFieldEnum | LessonprogressScalarFieldEnum[]
  }

  /**
   * lesson without action
   */
  export type lessonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lesson
     */
    select?: lessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lesson
     */
    omit?: lessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lessonInclude<ExtArgs> | null
  }


  /**
   * Model lessonprogress
   */

  export type AggregateLessonprogress = {
    _count: LessonprogressCountAggregateOutputType | null
    _avg: LessonprogressAvgAggregateOutputType | null
    _sum: LessonprogressSumAggregateOutputType | null
    _min: LessonprogressMinAggregateOutputType | null
    _max: LessonprogressMaxAggregateOutputType | null
  }

  export type LessonprogressAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    lessonId: number | null
  }

  export type LessonprogressSumAggregateOutputType = {
    id: number | null
    userId: number | null
    lessonId: number | null
  }

  export type LessonprogressMinAggregateOutputType = {
    id: number | null
    userId: number | null
    lessonId: number | null
    isCompleted: boolean | null
    updatedAt: Date | null
  }

  export type LessonprogressMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    lessonId: number | null
    isCompleted: boolean | null
    updatedAt: Date | null
  }

  export type LessonprogressCountAggregateOutputType = {
    id: number
    userId: number
    lessonId: number
    isCompleted: number
    updatedAt: number
    _all: number
  }


  export type LessonprogressAvgAggregateInputType = {
    id?: true
    userId?: true
    lessonId?: true
  }

  export type LessonprogressSumAggregateInputType = {
    id?: true
    userId?: true
    lessonId?: true
  }

  export type LessonprogressMinAggregateInputType = {
    id?: true
    userId?: true
    lessonId?: true
    isCompleted?: true
    updatedAt?: true
  }

  export type LessonprogressMaxAggregateInputType = {
    id?: true
    userId?: true
    lessonId?: true
    isCompleted?: true
    updatedAt?: true
  }

  export type LessonprogressCountAggregateInputType = {
    id?: true
    userId?: true
    lessonId?: true
    isCompleted?: true
    updatedAt?: true
    _all?: true
  }

  export type LessonprogressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which lessonprogress to aggregate.
     */
    where?: lessonprogressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lessonprogresses to fetch.
     */
    orderBy?: lessonprogressOrderByWithRelationInput | lessonprogressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: lessonprogressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lessonprogresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lessonprogresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned lessonprogresses
    **/
    _count?: true | LessonprogressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LessonprogressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LessonprogressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LessonprogressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LessonprogressMaxAggregateInputType
  }

  export type GetLessonprogressAggregateType<T extends LessonprogressAggregateArgs> = {
        [P in keyof T & keyof AggregateLessonprogress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLessonprogress[P]>
      : GetScalarType<T[P], AggregateLessonprogress[P]>
  }




  export type lessonprogressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: lessonprogressWhereInput
    orderBy?: lessonprogressOrderByWithAggregationInput | lessonprogressOrderByWithAggregationInput[]
    by: LessonprogressScalarFieldEnum[] | LessonprogressScalarFieldEnum
    having?: lessonprogressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LessonprogressCountAggregateInputType | true
    _avg?: LessonprogressAvgAggregateInputType
    _sum?: LessonprogressSumAggregateInputType
    _min?: LessonprogressMinAggregateInputType
    _max?: LessonprogressMaxAggregateInputType
  }

  export type LessonprogressGroupByOutputType = {
    id: number
    userId: number
    lessonId: number
    isCompleted: boolean
    updatedAt: Date
    _count: LessonprogressCountAggregateOutputType | null
    _avg: LessonprogressAvgAggregateOutputType | null
    _sum: LessonprogressSumAggregateOutputType | null
    _min: LessonprogressMinAggregateOutputType | null
    _max: LessonprogressMaxAggregateOutputType | null
  }

  type GetLessonprogressGroupByPayload<T extends lessonprogressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LessonprogressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LessonprogressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LessonprogressGroupByOutputType[P]>
            : GetScalarType<T[P], LessonprogressGroupByOutputType[P]>
        }
      >
    >


  export type lessonprogressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    lessonId?: boolean
    isCompleted?: boolean
    updatedAt?: boolean
    lesson?: boolean | lessonDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lessonprogress"]>



  export type lessonprogressSelectScalar = {
    id?: boolean
    userId?: boolean
    lessonId?: boolean
    isCompleted?: boolean
    updatedAt?: boolean
  }

  export type lessonprogressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "lessonId" | "isCompleted" | "updatedAt", ExtArgs["result"]["lessonprogress"]>
  export type lessonprogressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | lessonDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $lessonprogressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "lessonprogress"
    objects: {
      lesson: Prisma.$lessonPayload<ExtArgs>
      users: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      lessonId: number
      isCompleted: boolean
      updatedAt: Date
    }, ExtArgs["result"]["lessonprogress"]>
    composites: {}
  }

  type lessonprogressGetPayload<S extends boolean | null | undefined | lessonprogressDefaultArgs> = $Result.GetResult<Prisma.$lessonprogressPayload, S>

  type lessonprogressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<lessonprogressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LessonprogressCountAggregateInputType | true
    }

  export interface lessonprogressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['lessonprogress'], meta: { name: 'lessonprogress' } }
    /**
     * Find zero or one Lessonprogress that matches the filter.
     * @param {lessonprogressFindUniqueArgs} args - Arguments to find a Lessonprogress
     * @example
     * // Get one Lessonprogress
     * const lessonprogress = await prisma.lessonprogress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends lessonprogressFindUniqueArgs>(args: SelectSubset<T, lessonprogressFindUniqueArgs<ExtArgs>>): Prisma__lessonprogressClient<$Result.GetResult<Prisma.$lessonprogressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lessonprogress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {lessonprogressFindUniqueOrThrowArgs} args - Arguments to find a Lessonprogress
     * @example
     * // Get one Lessonprogress
     * const lessonprogress = await prisma.lessonprogress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends lessonprogressFindUniqueOrThrowArgs>(args: SelectSubset<T, lessonprogressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__lessonprogressClient<$Result.GetResult<Prisma.$lessonprogressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lessonprogress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lessonprogressFindFirstArgs} args - Arguments to find a Lessonprogress
     * @example
     * // Get one Lessonprogress
     * const lessonprogress = await prisma.lessonprogress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends lessonprogressFindFirstArgs>(args?: SelectSubset<T, lessonprogressFindFirstArgs<ExtArgs>>): Prisma__lessonprogressClient<$Result.GetResult<Prisma.$lessonprogressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lessonprogress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lessonprogressFindFirstOrThrowArgs} args - Arguments to find a Lessonprogress
     * @example
     * // Get one Lessonprogress
     * const lessonprogress = await prisma.lessonprogress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends lessonprogressFindFirstOrThrowArgs>(args?: SelectSubset<T, lessonprogressFindFirstOrThrowArgs<ExtArgs>>): Prisma__lessonprogressClient<$Result.GetResult<Prisma.$lessonprogressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Lessonprogresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lessonprogressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lessonprogresses
     * const lessonprogresses = await prisma.lessonprogress.findMany()
     * 
     * // Get first 10 Lessonprogresses
     * const lessonprogresses = await prisma.lessonprogress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lessonprogressWithIdOnly = await prisma.lessonprogress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends lessonprogressFindManyArgs>(args?: SelectSubset<T, lessonprogressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lessonprogressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lessonprogress.
     * @param {lessonprogressCreateArgs} args - Arguments to create a Lessonprogress.
     * @example
     * // Create one Lessonprogress
     * const Lessonprogress = await prisma.lessonprogress.create({
     *   data: {
     *     // ... data to create a Lessonprogress
     *   }
     * })
     * 
     */
    create<T extends lessonprogressCreateArgs>(args: SelectSubset<T, lessonprogressCreateArgs<ExtArgs>>): Prisma__lessonprogressClient<$Result.GetResult<Prisma.$lessonprogressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Lessonprogresses.
     * @param {lessonprogressCreateManyArgs} args - Arguments to create many Lessonprogresses.
     * @example
     * // Create many Lessonprogresses
     * const lessonprogress = await prisma.lessonprogress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends lessonprogressCreateManyArgs>(args?: SelectSubset<T, lessonprogressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Lessonprogress.
     * @param {lessonprogressDeleteArgs} args - Arguments to delete one Lessonprogress.
     * @example
     * // Delete one Lessonprogress
     * const Lessonprogress = await prisma.lessonprogress.delete({
     *   where: {
     *     // ... filter to delete one Lessonprogress
     *   }
     * })
     * 
     */
    delete<T extends lessonprogressDeleteArgs>(args: SelectSubset<T, lessonprogressDeleteArgs<ExtArgs>>): Prisma__lessonprogressClient<$Result.GetResult<Prisma.$lessonprogressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lessonprogress.
     * @param {lessonprogressUpdateArgs} args - Arguments to update one Lessonprogress.
     * @example
     * // Update one Lessonprogress
     * const lessonprogress = await prisma.lessonprogress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends lessonprogressUpdateArgs>(args: SelectSubset<T, lessonprogressUpdateArgs<ExtArgs>>): Prisma__lessonprogressClient<$Result.GetResult<Prisma.$lessonprogressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Lessonprogresses.
     * @param {lessonprogressDeleteManyArgs} args - Arguments to filter Lessonprogresses to delete.
     * @example
     * // Delete a few Lessonprogresses
     * const { count } = await prisma.lessonprogress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends lessonprogressDeleteManyArgs>(args?: SelectSubset<T, lessonprogressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lessonprogresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lessonprogressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lessonprogresses
     * const lessonprogress = await prisma.lessonprogress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends lessonprogressUpdateManyArgs>(args: SelectSubset<T, lessonprogressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lessonprogress.
     * @param {lessonprogressUpsertArgs} args - Arguments to update or create a Lessonprogress.
     * @example
     * // Update or create a Lessonprogress
     * const lessonprogress = await prisma.lessonprogress.upsert({
     *   create: {
     *     // ... data to create a Lessonprogress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lessonprogress we want to update
     *   }
     * })
     */
    upsert<T extends lessonprogressUpsertArgs>(args: SelectSubset<T, lessonprogressUpsertArgs<ExtArgs>>): Prisma__lessonprogressClient<$Result.GetResult<Prisma.$lessonprogressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Lessonprogresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lessonprogressCountArgs} args - Arguments to filter Lessonprogresses to count.
     * @example
     * // Count the number of Lessonprogresses
     * const count = await prisma.lessonprogress.count({
     *   where: {
     *     // ... the filter for the Lessonprogresses we want to count
     *   }
     * })
    **/
    count<T extends lessonprogressCountArgs>(
      args?: Subset<T, lessonprogressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LessonprogressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lessonprogress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonprogressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LessonprogressAggregateArgs>(args: Subset<T, LessonprogressAggregateArgs>): Prisma.PrismaPromise<GetLessonprogressAggregateType<T>>

    /**
     * Group by Lessonprogress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lessonprogressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends lessonprogressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: lessonprogressGroupByArgs['orderBy'] }
        : { orderBy?: lessonprogressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, lessonprogressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLessonprogressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the lessonprogress model
   */
  readonly fields: lessonprogressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for lessonprogress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__lessonprogressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lesson<T extends lessonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, lessonDefaultArgs<ExtArgs>>): Prisma__lessonClient<$Result.GetResult<Prisma.$lessonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the lessonprogress model
   */
  interface lessonprogressFieldRefs {
    readonly id: FieldRef<"lessonprogress", 'Int'>
    readonly userId: FieldRef<"lessonprogress", 'Int'>
    readonly lessonId: FieldRef<"lessonprogress", 'Int'>
    readonly isCompleted: FieldRef<"lessonprogress", 'Boolean'>
    readonly updatedAt: FieldRef<"lessonprogress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * lessonprogress findUnique
   */
  export type lessonprogressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lessonprogress
     */
    select?: lessonprogressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lessonprogress
     */
    omit?: lessonprogressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lessonprogressInclude<ExtArgs> | null
    /**
     * Filter, which lessonprogress to fetch.
     */
    where: lessonprogressWhereUniqueInput
  }

  /**
   * lessonprogress findUniqueOrThrow
   */
  export type lessonprogressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lessonprogress
     */
    select?: lessonprogressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lessonprogress
     */
    omit?: lessonprogressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lessonprogressInclude<ExtArgs> | null
    /**
     * Filter, which lessonprogress to fetch.
     */
    where: lessonprogressWhereUniqueInput
  }

  /**
   * lessonprogress findFirst
   */
  export type lessonprogressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lessonprogress
     */
    select?: lessonprogressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lessonprogress
     */
    omit?: lessonprogressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lessonprogressInclude<ExtArgs> | null
    /**
     * Filter, which lessonprogress to fetch.
     */
    where?: lessonprogressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lessonprogresses to fetch.
     */
    orderBy?: lessonprogressOrderByWithRelationInput | lessonprogressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lessonprogresses.
     */
    cursor?: lessonprogressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lessonprogresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lessonprogresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lessonprogresses.
     */
    distinct?: LessonprogressScalarFieldEnum | LessonprogressScalarFieldEnum[]
  }

  /**
   * lessonprogress findFirstOrThrow
   */
  export type lessonprogressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lessonprogress
     */
    select?: lessonprogressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lessonprogress
     */
    omit?: lessonprogressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lessonprogressInclude<ExtArgs> | null
    /**
     * Filter, which lessonprogress to fetch.
     */
    where?: lessonprogressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lessonprogresses to fetch.
     */
    orderBy?: lessonprogressOrderByWithRelationInput | lessonprogressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lessonprogresses.
     */
    cursor?: lessonprogressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lessonprogresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lessonprogresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lessonprogresses.
     */
    distinct?: LessonprogressScalarFieldEnum | LessonprogressScalarFieldEnum[]
  }

  /**
   * lessonprogress findMany
   */
  export type lessonprogressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lessonprogress
     */
    select?: lessonprogressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lessonprogress
     */
    omit?: lessonprogressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lessonprogressInclude<ExtArgs> | null
    /**
     * Filter, which lessonprogresses to fetch.
     */
    where?: lessonprogressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lessonprogresses to fetch.
     */
    orderBy?: lessonprogressOrderByWithRelationInput | lessonprogressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing lessonprogresses.
     */
    cursor?: lessonprogressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lessonprogresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lessonprogresses.
     */
    skip?: number
    distinct?: LessonprogressScalarFieldEnum | LessonprogressScalarFieldEnum[]
  }

  /**
   * lessonprogress create
   */
  export type lessonprogressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lessonprogress
     */
    select?: lessonprogressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lessonprogress
     */
    omit?: lessonprogressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lessonprogressInclude<ExtArgs> | null
    /**
     * The data needed to create a lessonprogress.
     */
    data: XOR<lessonprogressCreateInput, lessonprogressUncheckedCreateInput>
  }

  /**
   * lessonprogress createMany
   */
  export type lessonprogressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many lessonprogresses.
     */
    data: lessonprogressCreateManyInput | lessonprogressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * lessonprogress update
   */
  export type lessonprogressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lessonprogress
     */
    select?: lessonprogressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lessonprogress
     */
    omit?: lessonprogressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lessonprogressInclude<ExtArgs> | null
    /**
     * The data needed to update a lessonprogress.
     */
    data: XOR<lessonprogressUpdateInput, lessonprogressUncheckedUpdateInput>
    /**
     * Choose, which lessonprogress to update.
     */
    where: lessonprogressWhereUniqueInput
  }

  /**
   * lessonprogress updateMany
   */
  export type lessonprogressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update lessonprogresses.
     */
    data: XOR<lessonprogressUpdateManyMutationInput, lessonprogressUncheckedUpdateManyInput>
    /**
     * Filter which lessonprogresses to update
     */
    where?: lessonprogressWhereInput
    /**
     * Limit how many lessonprogresses to update.
     */
    limit?: number
  }

  /**
   * lessonprogress upsert
   */
  export type lessonprogressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lessonprogress
     */
    select?: lessonprogressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lessonprogress
     */
    omit?: lessonprogressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lessonprogressInclude<ExtArgs> | null
    /**
     * The filter to search for the lessonprogress to update in case it exists.
     */
    where: lessonprogressWhereUniqueInput
    /**
     * In case the lessonprogress found by the `where` argument doesn't exist, create a new lessonprogress with this data.
     */
    create: XOR<lessonprogressCreateInput, lessonprogressUncheckedCreateInput>
    /**
     * In case the lessonprogress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<lessonprogressUpdateInput, lessonprogressUncheckedUpdateInput>
  }

  /**
   * lessonprogress delete
   */
  export type lessonprogressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lessonprogress
     */
    select?: lessonprogressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lessonprogress
     */
    omit?: lessonprogressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lessonprogressInclude<ExtArgs> | null
    /**
     * Filter which lessonprogress to delete.
     */
    where: lessonprogressWhereUniqueInput
  }

  /**
   * lessonprogress deleteMany
   */
  export type lessonprogressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which lessonprogresses to delete
     */
    where?: lessonprogressWhereInput
    /**
     * Limit how many lessonprogresses to delete.
     */
    limit?: number
  }

  /**
   * lessonprogress without action
   */
  export type lessonprogressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lessonprogress
     */
    select?: lessonprogressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lessonprogress
     */
    omit?: lessonprogressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lessonprogressInclude<ExtArgs> | null
  }


  /**
   * Model notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type NotificationSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type NotificationMinAggregateOutputType = {
    id: number | null
    userId: number | null
    message: string | null
    isRead: boolean | null
    createdAt: Date | null
    type: string | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    message: string | null
    isRead: boolean | null
    createdAt: Date | null
    type: string | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    message: number
    isRead: number
    createdAt: number
    type: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NotificationSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    message?: true
    isRead?: true
    createdAt?: true
    type?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    message?: true
    isRead?: true
    createdAt?: true
    type?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    message?: true
    isRead?: true
    createdAt?: true
    type?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notification to aggregate.
     */
    where?: notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationOrderByWithRelationInput | notificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type notificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationWhereInput
    orderBy?: notificationOrderByWithAggregationInput | notificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: notificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _avg?: NotificationAvgAggregateInputType
    _sum?: NotificationSumAggregateInputType
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: number
    userId: number
    message: string
    isRead: boolean
    createdAt: Date
    type: string
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends notificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type notificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
    type?: boolean
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>



  export type notificationSelectScalar = {
    id?: boolean
    userId?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
    type?: boolean
  }

  export type notificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "message" | "isRead" | "createdAt" | "type", ExtArgs["result"]["notification"]>
  export type notificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $notificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "notification"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      message: string
      isRead: boolean
      createdAt: Date
      type: string
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type notificationGetPayload<S extends boolean | null | undefined | notificationDefaultArgs> = $Result.GetResult<Prisma.$notificationPayload, S>

  type notificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<notificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface notificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['notification'], meta: { name: 'notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {notificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends notificationFindUniqueArgs>(args: SelectSubset<T, notificationFindUniqueArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {notificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends notificationFindUniqueOrThrowArgs>(args: SelectSubset<T, notificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends notificationFindFirstArgs>(args?: SelectSubset<T, notificationFindFirstArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends notificationFindFirstOrThrowArgs>(args?: SelectSubset<T, notificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends notificationFindManyArgs>(args?: SelectSubset<T, notificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {notificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends notificationCreateArgs>(args: SelectSubset<T, notificationCreateArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {notificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends notificationCreateManyArgs>(args?: SelectSubset<T, notificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notification.
     * @param {notificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends notificationDeleteArgs>(args: SelectSubset<T, notificationDeleteArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {notificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends notificationUpdateArgs>(args: SelectSubset<T, notificationUpdateArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {notificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends notificationDeleteManyArgs>(args?: SelectSubset<T, notificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends notificationUpdateManyArgs>(args: SelectSubset<T, notificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {notificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends notificationUpsertArgs>(args: SelectSubset<T, notificationUpsertArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends notificationCountArgs>(
      args?: Subset<T, notificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends notificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: notificationGroupByArgs['orderBy'] }
        : { orderBy?: notificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, notificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the notification model
   */
  readonly fields: notificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__notificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the notification model
   */
  interface notificationFieldRefs {
    readonly id: FieldRef<"notification", 'Int'>
    readonly userId: FieldRef<"notification", 'Int'>
    readonly message: FieldRef<"notification", 'String'>
    readonly isRead: FieldRef<"notification", 'Boolean'>
    readonly createdAt: FieldRef<"notification", 'DateTime'>
    readonly type: FieldRef<"notification", 'String'>
  }
    

  // Custom InputTypes
  /**
   * notification findUnique
   */
  export type notificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter, which notification to fetch.
     */
    where: notificationWhereUniqueInput
  }

  /**
   * notification findUniqueOrThrow
   */
  export type notificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter, which notification to fetch.
     */
    where: notificationWhereUniqueInput
  }

  /**
   * notification findFirst
   */
  export type notificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter, which notification to fetch.
     */
    where?: notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationOrderByWithRelationInput | notificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * notification findFirstOrThrow
   */
  export type notificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter, which notification to fetch.
     */
    where?: notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationOrderByWithRelationInput | notificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * notification findMany
   */
  export type notificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationOrderByWithRelationInput | notificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notifications.
     */
    cursor?: notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * notification create
   */
  export type notificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * The data needed to create a notification.
     */
    data: XOR<notificationCreateInput, notificationUncheckedCreateInput>
  }

  /**
   * notification createMany
   */
  export type notificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many notifications.
     */
    data: notificationCreateManyInput | notificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * notification update
   */
  export type notificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * The data needed to update a notification.
     */
    data: XOR<notificationUpdateInput, notificationUncheckedUpdateInput>
    /**
     * Choose, which notification to update.
     */
    where: notificationWhereUniqueInput
  }

  /**
   * notification updateMany
   */
  export type notificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update notifications.
     */
    data: XOR<notificationUpdateManyMutationInput, notificationUncheckedUpdateManyInput>
    /**
     * Filter which notifications to update
     */
    where?: notificationWhereInput
    /**
     * Limit how many notifications to update.
     */
    limit?: number
  }

  /**
   * notification upsert
   */
  export type notificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * The filter to search for the notification to update in case it exists.
     */
    where: notificationWhereUniqueInput
    /**
     * In case the notification found by the `where` argument doesn't exist, create a new notification with this data.
     */
    create: XOR<notificationCreateInput, notificationUncheckedCreateInput>
    /**
     * In case the notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<notificationUpdateInput, notificationUncheckedUpdateInput>
  }

  /**
   * notification delete
   */
  export type notificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter which notification to delete.
     */
    where: notificationWhereUniqueInput
  }

  /**
   * notification deleteMany
   */
  export type notificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notifications to delete
     */
    where?: notificationWhereInput
    /**
     * Limit how many notifications to delete.
     */
    limit?: number
  }

  /**
   * notification without action
   */
  export type notificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notification
     */
    omit?: notificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
  }


  /**
   * Model payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
    roadmapId: number | null
    amount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
    roadmapId: number | null
    amount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
    roadmapId: number | null
    amount: number | null
    paymentStatus: string | null
    status: string | null
    paidAt: Date | null
    createdAt: Date | null
    orderId: string | null
    snapToken: string | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
    roadmapId: number | null
    amount: number | null
    paymentStatus: string | null
    status: string | null
    paidAt: Date | null
    createdAt: Date | null
    orderId: string | null
    snapToken: string | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    userId: number
    courseId: number
    roadmapId: number
    amount: number
    paymentStatus: number
    status: number
    paidAt: number
    createdAt: number
    orderId: number
    snapToken: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    roadmapId?: true
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    roadmapId?: true
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    roadmapId?: true
    amount?: true
    paymentStatus?: true
    status?: true
    paidAt?: true
    createdAt?: true
    orderId?: true
    snapToken?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    roadmapId?: true
    amount?: true
    paymentStatus?: true
    status?: true
    paidAt?: true
    createdAt?: true
    orderId?: true
    snapToken?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    roadmapId?: true
    amount?: true
    paymentStatus?: true
    status?: true
    paidAt?: true
    createdAt?: true
    orderId?: true
    snapToken?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payment to aggregate.
     */
    where?: paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentOrderByWithRelationInput | paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type paymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentWhereInput
    orderBy?: paymentOrderByWithAggregationInput | paymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: paymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: number
    userId: number
    courseId: number | null
    roadmapId: number | null
    amount: number
    paymentStatus: string
    status: string
    paidAt: Date
    createdAt: Date
    orderId: string | null
    snapToken: string | null
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends paymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type paymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    roadmapId?: boolean
    amount?: boolean
    paymentStatus?: boolean
    status?: boolean
    paidAt?: boolean
    createdAt?: boolean
    orderId?: boolean
    snapToken?: boolean
    enrollment?: boolean | payment$enrollmentArgs<ExtArgs>
    course?: boolean | payment$courseArgs<ExtArgs>
    roadmap?: boolean | payment$roadmapArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | PaymentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>



  export type paymentSelectScalar = {
    id?: boolean
    userId?: boolean
    courseId?: boolean
    roadmapId?: boolean
    amount?: boolean
    paymentStatus?: boolean
    status?: boolean
    paidAt?: boolean
    createdAt?: boolean
    orderId?: boolean
    snapToken?: boolean
  }

  export type paymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "courseId" | "roadmapId" | "amount" | "paymentStatus" | "status" | "paidAt" | "createdAt" | "orderId" | "snapToken", ExtArgs["result"]["payment"]>
  export type paymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enrollment?: boolean | payment$enrollmentArgs<ExtArgs>
    course?: boolean | payment$courseArgs<ExtArgs>
    roadmap?: boolean | payment$roadmapArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | PaymentCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $paymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "payment"
    objects: {
      enrollment: Prisma.$enrollmentPayload<ExtArgs>[]
      course: Prisma.$coursePayload<ExtArgs> | null
      roadmap: Prisma.$roadmapPayload<ExtArgs> | null
      users: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      courseId: number | null
      roadmapId: number | null
      amount: number
      paymentStatus: string
      status: string
      paidAt: Date
      createdAt: Date
      orderId: string | null
      snapToken: string | null
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type paymentGetPayload<S extends boolean | null | undefined | paymentDefaultArgs> = $Result.GetResult<Prisma.$paymentPayload, S>

  type paymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<paymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface paymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['payment'], meta: { name: 'payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {paymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends paymentFindUniqueArgs>(args: SelectSubset<T, paymentFindUniqueArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {paymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends paymentFindUniqueOrThrowArgs>(args: SelectSubset<T, paymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends paymentFindFirstArgs>(args?: SelectSubset<T, paymentFindFirstArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends paymentFindFirstOrThrowArgs>(args?: SelectSubset<T, paymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends paymentFindManyArgs>(args?: SelectSubset<T, paymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {paymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends paymentCreateArgs>(args: SelectSubset<T, paymentCreateArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {paymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends paymentCreateManyArgs>(args?: SelectSubset<T, paymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Payment.
     * @param {paymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends paymentDeleteArgs>(args: SelectSubset<T, paymentDeleteArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {paymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends paymentUpdateArgs>(args: SelectSubset<T, paymentUpdateArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {paymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends paymentDeleteManyArgs>(args?: SelectSubset<T, paymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends paymentUpdateManyArgs>(args: SelectSubset<T, paymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {paymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends paymentUpsertArgs>(args: SelectSubset<T, paymentUpsertArgs<ExtArgs>>): Prisma__paymentClient<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends paymentCountArgs>(
      args?: Subset<T, paymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends paymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: paymentGroupByArgs['orderBy'] }
        : { orderBy?: paymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, paymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the payment model
   */
  readonly fields: paymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__paymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    enrollment<T extends payment$enrollmentArgs<ExtArgs> = {}>(args?: Subset<T, payment$enrollmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$enrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    course<T extends payment$courseArgs<ExtArgs> = {}>(args?: Subset<T, payment$courseArgs<ExtArgs>>): Prisma__courseClient<$Result.GetResult<Prisma.$coursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    roadmap<T extends payment$roadmapArgs<ExtArgs> = {}>(args?: Subset<T, payment$roadmapArgs<ExtArgs>>): Prisma__roadmapClient<$Result.GetResult<Prisma.$roadmapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the payment model
   */
  interface paymentFieldRefs {
    readonly id: FieldRef<"payment", 'Int'>
    readonly userId: FieldRef<"payment", 'Int'>
    readonly courseId: FieldRef<"payment", 'Int'>
    readonly roadmapId: FieldRef<"payment", 'Int'>
    readonly amount: FieldRef<"payment", 'Int'>
    readonly paymentStatus: FieldRef<"payment", 'String'>
    readonly status: FieldRef<"payment", 'String'>
    readonly paidAt: FieldRef<"payment", 'DateTime'>
    readonly createdAt: FieldRef<"payment", 'DateTime'>
    readonly orderId: FieldRef<"payment", 'String'>
    readonly snapToken: FieldRef<"payment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * payment findUnique
   */
  export type paymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    /**
     * Filter, which payment to fetch.
     */
    where: paymentWhereUniqueInput
  }

  /**
   * payment findUniqueOrThrow
   */
  export type paymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    /**
     * Filter, which payment to fetch.
     */
    where: paymentWhereUniqueInput
  }

  /**
   * payment findFirst
   */
  export type paymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    /**
     * Filter, which payment to fetch.
     */
    where?: paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentOrderByWithRelationInput | paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * payment findFirstOrThrow
   */
  export type paymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    /**
     * Filter, which payment to fetch.
     */
    where?: paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentOrderByWithRelationInput | paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * payment findMany
   */
  export type paymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentOrderByWithRelationInput | paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payments.
     */
    cursor?: paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * payment create
   */
  export type paymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    /**
     * The data needed to create a payment.
     */
    data: XOR<paymentCreateInput, paymentUncheckedCreateInput>
  }

  /**
   * payment createMany
   */
  export type paymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many payments.
     */
    data: paymentCreateManyInput | paymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * payment update
   */
  export type paymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    /**
     * The data needed to update a payment.
     */
    data: XOR<paymentUpdateInput, paymentUncheckedUpdateInput>
    /**
     * Choose, which payment to update.
     */
    where: paymentWhereUniqueInput
  }

  /**
   * payment updateMany
   */
  export type paymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update payments.
     */
    data: XOR<paymentUpdateManyMutationInput, paymentUncheckedUpdateManyInput>
    /**
     * Filter which payments to update
     */
    where?: paymentWhereInput
    /**
     * Limit how many payments to update.
     */
    limit?: number
  }

  /**
   * payment upsert
   */
  export type paymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    /**
     * The filter to search for the payment to update in case it exists.
     */
    where: paymentWhereUniqueInput
    /**
     * In case the payment found by the `where` argument doesn't exist, create a new payment with this data.
     */
    create: XOR<paymentCreateInput, paymentUncheckedCreateInput>
    /**
     * In case the payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<paymentUpdateInput, paymentUncheckedUpdateInput>
  }

  /**
   * payment delete
   */
  export type paymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    /**
     * Filter which payment to delete.
     */
    where: paymentWhereUniqueInput
  }

  /**
   * payment deleteMany
   */
  export type paymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payments to delete
     */
    where?: paymentWhereInput
    /**
     * Limit how many payments to delete.
     */
    limit?: number
  }

  /**
   * payment.enrollment
   */
  export type payment$enrollmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollment
     */
    select?: enrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrollment
     */
    omit?: enrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentInclude<ExtArgs> | null
    where?: enrollmentWhereInput
    orderBy?: enrollmentOrderByWithRelationInput | enrollmentOrderByWithRelationInput[]
    cursor?: enrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * payment.course
   */
  export type payment$courseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course
     */
    select?: courseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course
     */
    omit?: courseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: courseInclude<ExtArgs> | null
    where?: courseWhereInput
  }

  /**
   * payment.roadmap
   */
  export type payment$roadmapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roadmap
     */
    select?: roadmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roadmap
     */
    omit?: roadmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roadmapInclude<ExtArgs> | null
    where?: roadmapWhereInput
  }

  /**
   * payment without action
   */
  export type paymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
  }


  /**
   * Model quiz
   */

  export type AggregateQuiz = {
    _count: QuizCountAggregateOutputType | null
    _avg: QuizAvgAggregateOutputType | null
    _sum: QuizSumAggregateOutputType | null
    _min: QuizMinAggregateOutputType | null
    _max: QuizMaxAggregateOutputType | null
  }

  export type QuizAvgAggregateOutputType = {
    id: number | null
    courseId: number | null
  }

  export type QuizSumAggregateOutputType = {
    id: number | null
    courseId: number | null
  }

  export type QuizMinAggregateOutputType = {
    id: number | null
    courseId: number | null
    question: string | null
    correctAnswer: string | null
    isLocked: boolean | null
  }

  export type QuizMaxAggregateOutputType = {
    id: number | null
    courseId: number | null
    question: string | null
    correctAnswer: string | null
    isLocked: boolean | null
  }

  export type QuizCountAggregateOutputType = {
    id: number
    courseId: number
    question: number
    options: number
    correctAnswer: number
    isLocked: number
    _all: number
  }


  export type QuizAvgAggregateInputType = {
    id?: true
    courseId?: true
  }

  export type QuizSumAggregateInputType = {
    id?: true
    courseId?: true
  }

  export type QuizMinAggregateInputType = {
    id?: true
    courseId?: true
    question?: true
    correctAnswer?: true
    isLocked?: true
  }

  export type QuizMaxAggregateInputType = {
    id?: true
    courseId?: true
    question?: true
    correctAnswer?: true
    isLocked?: true
  }

  export type QuizCountAggregateInputType = {
    id?: true
    courseId?: true
    question?: true
    options?: true
    correctAnswer?: true
    isLocked?: true
    _all?: true
  }

  export type QuizAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which quiz to aggregate.
     */
    where?: quizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quizzes to fetch.
     */
    orderBy?: quizOrderByWithRelationInput | quizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: quizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quizzes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned quizzes
    **/
    _count?: true | QuizCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizMaxAggregateInputType
  }

  export type GetQuizAggregateType<T extends QuizAggregateArgs> = {
        [P in keyof T & keyof AggregateQuiz]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuiz[P]>
      : GetScalarType<T[P], AggregateQuiz[P]>
  }




  export type quizGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: quizWhereInput
    orderBy?: quizOrderByWithAggregationInput | quizOrderByWithAggregationInput[]
    by: QuizScalarFieldEnum[] | QuizScalarFieldEnum
    having?: quizScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizCountAggregateInputType | true
    _avg?: QuizAvgAggregateInputType
    _sum?: QuizSumAggregateInputType
    _min?: QuizMinAggregateInputType
    _max?: QuizMaxAggregateInputType
  }

  export type QuizGroupByOutputType = {
    id: number
    courseId: number
    question: string
    options: JsonValue
    correctAnswer: string
    isLocked: boolean
    _count: QuizCountAggregateOutputType | null
    _avg: QuizAvgAggregateOutputType | null
    _sum: QuizSumAggregateOutputType | null
    _min: QuizMinAggregateOutputType | null
    _max: QuizMaxAggregateOutputType | null
  }

  type GetQuizGroupByPayload<T extends quizGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizGroupByOutputType[P]>
            : GetScalarType<T[P], QuizGroupByOutputType[P]>
        }
      >
    >


  export type quizSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    question?: boolean
    options?: boolean
    correctAnswer?: boolean
    isLocked?: boolean
    course?: boolean | courseDefaultArgs<ExtArgs>
    quizsubmission?: boolean | quiz$quizsubmissionArgs<ExtArgs>
    _count?: boolean | QuizCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quiz"]>



  export type quizSelectScalar = {
    id?: boolean
    courseId?: boolean
    question?: boolean
    options?: boolean
    correctAnswer?: boolean
    isLocked?: boolean
  }

  export type quizOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "courseId" | "question" | "options" | "correctAnswer" | "isLocked", ExtArgs["result"]["quiz"]>
  export type quizInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | courseDefaultArgs<ExtArgs>
    quizsubmission?: boolean | quiz$quizsubmissionArgs<ExtArgs>
    _count?: boolean | QuizCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $quizPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "quiz"
    objects: {
      course: Prisma.$coursePayload<ExtArgs>
      quizsubmission: Prisma.$quizsubmissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      courseId: number
      question: string
      options: Prisma.JsonValue
      correctAnswer: string
      isLocked: boolean
    }, ExtArgs["result"]["quiz"]>
    composites: {}
  }

  type quizGetPayload<S extends boolean | null | undefined | quizDefaultArgs> = $Result.GetResult<Prisma.$quizPayload, S>

  type quizCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<quizFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizCountAggregateInputType | true
    }

  export interface quizDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['quiz'], meta: { name: 'quiz' } }
    /**
     * Find zero or one Quiz that matches the filter.
     * @param {quizFindUniqueArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends quizFindUniqueArgs>(args: SelectSubset<T, quizFindUniqueArgs<ExtArgs>>): Prisma__quizClient<$Result.GetResult<Prisma.$quizPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Quiz that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {quizFindUniqueOrThrowArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends quizFindUniqueOrThrowArgs>(args: SelectSubset<T, quizFindUniqueOrThrowArgs<ExtArgs>>): Prisma__quizClient<$Result.GetResult<Prisma.$quizPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quiz that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quizFindFirstArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends quizFindFirstArgs>(args?: SelectSubset<T, quizFindFirstArgs<ExtArgs>>): Prisma__quizClient<$Result.GetResult<Prisma.$quizPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quiz that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quizFindFirstOrThrowArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends quizFindFirstOrThrowArgs>(args?: SelectSubset<T, quizFindFirstOrThrowArgs<ExtArgs>>): Prisma__quizClient<$Result.GetResult<Prisma.$quizPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Quizzes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quizFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quizzes
     * const quizzes = await prisma.quiz.findMany()
     * 
     * // Get first 10 Quizzes
     * const quizzes = await prisma.quiz.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizWithIdOnly = await prisma.quiz.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends quizFindManyArgs>(args?: SelectSubset<T, quizFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$quizPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Quiz.
     * @param {quizCreateArgs} args - Arguments to create a Quiz.
     * @example
     * // Create one Quiz
     * const Quiz = await prisma.quiz.create({
     *   data: {
     *     // ... data to create a Quiz
     *   }
     * })
     * 
     */
    create<T extends quizCreateArgs>(args: SelectSubset<T, quizCreateArgs<ExtArgs>>): Prisma__quizClient<$Result.GetResult<Prisma.$quizPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Quizzes.
     * @param {quizCreateManyArgs} args - Arguments to create many Quizzes.
     * @example
     * // Create many Quizzes
     * const quiz = await prisma.quiz.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends quizCreateManyArgs>(args?: SelectSubset<T, quizCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Quiz.
     * @param {quizDeleteArgs} args - Arguments to delete one Quiz.
     * @example
     * // Delete one Quiz
     * const Quiz = await prisma.quiz.delete({
     *   where: {
     *     // ... filter to delete one Quiz
     *   }
     * })
     * 
     */
    delete<T extends quizDeleteArgs>(args: SelectSubset<T, quizDeleteArgs<ExtArgs>>): Prisma__quizClient<$Result.GetResult<Prisma.$quizPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Quiz.
     * @param {quizUpdateArgs} args - Arguments to update one Quiz.
     * @example
     * // Update one Quiz
     * const quiz = await prisma.quiz.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends quizUpdateArgs>(args: SelectSubset<T, quizUpdateArgs<ExtArgs>>): Prisma__quizClient<$Result.GetResult<Prisma.$quizPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Quizzes.
     * @param {quizDeleteManyArgs} args - Arguments to filter Quizzes to delete.
     * @example
     * // Delete a few Quizzes
     * const { count } = await prisma.quiz.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends quizDeleteManyArgs>(args?: SelectSubset<T, quizDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quizzes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quizUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quizzes
     * const quiz = await prisma.quiz.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends quizUpdateManyArgs>(args: SelectSubset<T, quizUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Quiz.
     * @param {quizUpsertArgs} args - Arguments to update or create a Quiz.
     * @example
     * // Update or create a Quiz
     * const quiz = await prisma.quiz.upsert({
     *   create: {
     *     // ... data to create a Quiz
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quiz we want to update
     *   }
     * })
     */
    upsert<T extends quizUpsertArgs>(args: SelectSubset<T, quizUpsertArgs<ExtArgs>>): Prisma__quizClient<$Result.GetResult<Prisma.$quizPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Quizzes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quizCountArgs} args - Arguments to filter Quizzes to count.
     * @example
     * // Count the number of Quizzes
     * const count = await prisma.quiz.count({
     *   where: {
     *     // ... the filter for the Quizzes we want to count
     *   }
     * })
    **/
    count<T extends quizCountArgs>(
      args?: Subset<T, quizCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quiz.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizAggregateArgs>(args: Subset<T, QuizAggregateArgs>): Prisma.PrismaPromise<GetQuizAggregateType<T>>

    /**
     * Group by Quiz.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quizGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends quizGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: quizGroupByArgs['orderBy'] }
        : { orderBy?: quizGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, quizGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the quiz model
   */
  readonly fields: quizFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for quiz.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__quizClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends courseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, courseDefaultArgs<ExtArgs>>): Prisma__courseClient<$Result.GetResult<Prisma.$coursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    quizsubmission<T extends quiz$quizsubmissionArgs<ExtArgs> = {}>(args?: Subset<T, quiz$quizsubmissionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$quizsubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the quiz model
   */
  interface quizFieldRefs {
    readonly id: FieldRef<"quiz", 'Int'>
    readonly courseId: FieldRef<"quiz", 'Int'>
    readonly question: FieldRef<"quiz", 'String'>
    readonly options: FieldRef<"quiz", 'Json'>
    readonly correctAnswer: FieldRef<"quiz", 'String'>
    readonly isLocked: FieldRef<"quiz", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * quiz findUnique
   */
  export type quizFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quiz
     */
    select?: quizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quiz
     */
    omit?: quizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quizInclude<ExtArgs> | null
    /**
     * Filter, which quiz to fetch.
     */
    where: quizWhereUniqueInput
  }

  /**
   * quiz findUniqueOrThrow
   */
  export type quizFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quiz
     */
    select?: quizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quiz
     */
    omit?: quizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quizInclude<ExtArgs> | null
    /**
     * Filter, which quiz to fetch.
     */
    where: quizWhereUniqueInput
  }

  /**
   * quiz findFirst
   */
  export type quizFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quiz
     */
    select?: quizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quiz
     */
    omit?: quizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quizInclude<ExtArgs> | null
    /**
     * Filter, which quiz to fetch.
     */
    where?: quizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quizzes to fetch.
     */
    orderBy?: quizOrderByWithRelationInput | quizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for quizzes.
     */
    cursor?: quizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quizzes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of quizzes.
     */
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * quiz findFirstOrThrow
   */
  export type quizFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quiz
     */
    select?: quizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quiz
     */
    omit?: quizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quizInclude<ExtArgs> | null
    /**
     * Filter, which quiz to fetch.
     */
    where?: quizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quizzes to fetch.
     */
    orderBy?: quizOrderByWithRelationInput | quizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for quizzes.
     */
    cursor?: quizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quizzes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of quizzes.
     */
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * quiz findMany
   */
  export type quizFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quiz
     */
    select?: quizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quiz
     */
    omit?: quizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quizInclude<ExtArgs> | null
    /**
     * Filter, which quizzes to fetch.
     */
    where?: quizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quizzes to fetch.
     */
    orderBy?: quizOrderByWithRelationInput | quizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing quizzes.
     */
    cursor?: quizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quizzes.
     */
    skip?: number
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * quiz create
   */
  export type quizCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quiz
     */
    select?: quizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quiz
     */
    omit?: quizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quizInclude<ExtArgs> | null
    /**
     * The data needed to create a quiz.
     */
    data: XOR<quizCreateInput, quizUncheckedCreateInput>
  }

  /**
   * quiz createMany
   */
  export type quizCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many quizzes.
     */
    data: quizCreateManyInput | quizCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * quiz update
   */
  export type quizUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quiz
     */
    select?: quizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quiz
     */
    omit?: quizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quizInclude<ExtArgs> | null
    /**
     * The data needed to update a quiz.
     */
    data: XOR<quizUpdateInput, quizUncheckedUpdateInput>
    /**
     * Choose, which quiz to update.
     */
    where: quizWhereUniqueInput
  }

  /**
   * quiz updateMany
   */
  export type quizUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update quizzes.
     */
    data: XOR<quizUpdateManyMutationInput, quizUncheckedUpdateManyInput>
    /**
     * Filter which quizzes to update
     */
    where?: quizWhereInput
    /**
     * Limit how many quizzes to update.
     */
    limit?: number
  }

  /**
   * quiz upsert
   */
  export type quizUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quiz
     */
    select?: quizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quiz
     */
    omit?: quizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quizInclude<ExtArgs> | null
    /**
     * The filter to search for the quiz to update in case it exists.
     */
    where: quizWhereUniqueInput
    /**
     * In case the quiz found by the `where` argument doesn't exist, create a new quiz with this data.
     */
    create: XOR<quizCreateInput, quizUncheckedCreateInput>
    /**
     * In case the quiz was found with the provided `where` argument, update it with this data.
     */
    update: XOR<quizUpdateInput, quizUncheckedUpdateInput>
  }

  /**
   * quiz delete
   */
  export type quizDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quiz
     */
    select?: quizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quiz
     */
    omit?: quizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quizInclude<ExtArgs> | null
    /**
     * Filter which quiz to delete.
     */
    where: quizWhereUniqueInput
  }

  /**
   * quiz deleteMany
   */
  export type quizDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which quizzes to delete
     */
    where?: quizWhereInput
    /**
     * Limit how many quizzes to delete.
     */
    limit?: number
  }

  /**
   * quiz.quizsubmission
   */
  export type quiz$quizsubmissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quizsubmission
     */
    select?: quizsubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quizsubmission
     */
    omit?: quizsubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quizsubmissionInclude<ExtArgs> | null
    where?: quizsubmissionWhereInput
    orderBy?: quizsubmissionOrderByWithRelationInput | quizsubmissionOrderByWithRelationInput[]
    cursor?: quizsubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizsubmissionScalarFieldEnum | QuizsubmissionScalarFieldEnum[]
  }

  /**
   * quiz without action
   */
  export type quizDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quiz
     */
    select?: quizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quiz
     */
    omit?: quizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quizInclude<ExtArgs> | null
  }


  /**
   * Model quizsubmission
   */

  export type AggregateQuizsubmission = {
    _count: QuizsubmissionCountAggregateOutputType | null
    _avg: QuizsubmissionAvgAggregateOutputType | null
    _sum: QuizsubmissionSumAggregateOutputType | null
    _min: QuizsubmissionMinAggregateOutputType | null
    _max: QuizsubmissionMaxAggregateOutputType | null
  }

  export type QuizsubmissionAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
    quizId: number | null
    score: number | null
    totalQuestions: number | null
  }

  export type QuizsubmissionSumAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
    quizId: number | null
    score: number | null
    totalQuestions: number | null
  }

  export type QuizsubmissionMinAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
    quizId: number | null
    score: number | null
    totalQuestions: number | null
    isPassed: boolean | null
    createdAt: Date | null
  }

  export type QuizsubmissionMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    courseId: number | null
    quizId: number | null
    score: number | null
    totalQuestions: number | null
    isPassed: boolean | null
    createdAt: Date | null
  }

  export type QuizsubmissionCountAggregateOutputType = {
    id: number
    userId: number
    courseId: number
    quizId: number
    answers: number
    score: number
    totalQuestions: number
    isPassed: number
    createdAt: number
    _all: number
  }


  export type QuizsubmissionAvgAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    quizId?: true
    score?: true
    totalQuestions?: true
  }

  export type QuizsubmissionSumAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    quizId?: true
    score?: true
    totalQuestions?: true
  }

  export type QuizsubmissionMinAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    quizId?: true
    score?: true
    totalQuestions?: true
    isPassed?: true
    createdAt?: true
  }

  export type QuizsubmissionMaxAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    quizId?: true
    score?: true
    totalQuestions?: true
    isPassed?: true
    createdAt?: true
  }

  export type QuizsubmissionCountAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    quizId?: true
    answers?: true
    score?: true
    totalQuestions?: true
    isPassed?: true
    createdAt?: true
    _all?: true
  }

  export type QuizsubmissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which quizsubmission to aggregate.
     */
    where?: quizsubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quizsubmissions to fetch.
     */
    orderBy?: quizsubmissionOrderByWithRelationInput | quizsubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: quizsubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quizsubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quizsubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned quizsubmissions
    **/
    _count?: true | QuizsubmissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizsubmissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizsubmissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizsubmissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizsubmissionMaxAggregateInputType
  }

  export type GetQuizsubmissionAggregateType<T extends QuizsubmissionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizsubmission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizsubmission[P]>
      : GetScalarType<T[P], AggregateQuizsubmission[P]>
  }




  export type quizsubmissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: quizsubmissionWhereInput
    orderBy?: quizsubmissionOrderByWithAggregationInput | quizsubmissionOrderByWithAggregationInput[]
    by: QuizsubmissionScalarFieldEnum[] | QuizsubmissionScalarFieldEnum
    having?: quizsubmissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizsubmissionCountAggregateInputType | true
    _avg?: QuizsubmissionAvgAggregateInputType
    _sum?: QuizsubmissionSumAggregateInputType
    _min?: QuizsubmissionMinAggregateInputType
    _max?: QuizsubmissionMaxAggregateInputType
  }

  export type QuizsubmissionGroupByOutputType = {
    id: number
    userId: number
    courseId: number
    quizId: number
    answers: JsonValue
    score: number
    totalQuestions: number
    isPassed: boolean
    createdAt: Date
    _count: QuizsubmissionCountAggregateOutputType | null
    _avg: QuizsubmissionAvgAggregateOutputType | null
    _sum: QuizsubmissionSumAggregateOutputType | null
    _min: QuizsubmissionMinAggregateOutputType | null
    _max: QuizsubmissionMaxAggregateOutputType | null
  }

  type GetQuizsubmissionGroupByPayload<T extends quizsubmissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizsubmissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizsubmissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizsubmissionGroupByOutputType[P]>
            : GetScalarType<T[P], QuizsubmissionGroupByOutputType[P]>
        }
      >
    >


  export type quizsubmissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    quizId?: boolean
    answers?: boolean
    score?: boolean
    totalQuestions?: boolean
    isPassed?: boolean
    createdAt?: boolean
    course?: boolean | courseDefaultArgs<ExtArgs>
    quiz?: boolean | quizDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizsubmission"]>



  export type quizsubmissionSelectScalar = {
    id?: boolean
    userId?: boolean
    courseId?: boolean
    quizId?: boolean
    answers?: boolean
    score?: boolean
    totalQuestions?: boolean
    isPassed?: boolean
    createdAt?: boolean
  }

  export type quizsubmissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "courseId" | "quizId" | "answers" | "score" | "totalQuestions" | "isPassed" | "createdAt", ExtArgs["result"]["quizsubmission"]>
  export type quizsubmissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | courseDefaultArgs<ExtArgs>
    quiz?: boolean | quizDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $quizsubmissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "quizsubmission"
    objects: {
      course: Prisma.$coursePayload<ExtArgs>
      quiz: Prisma.$quizPayload<ExtArgs>
      users: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      courseId: number
      quizId: number
      answers: Prisma.JsonValue
      score: number
      totalQuestions: number
      isPassed: boolean
      createdAt: Date
    }, ExtArgs["result"]["quizsubmission"]>
    composites: {}
  }

  type quizsubmissionGetPayload<S extends boolean | null | undefined | quizsubmissionDefaultArgs> = $Result.GetResult<Prisma.$quizsubmissionPayload, S>

  type quizsubmissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<quizsubmissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizsubmissionCountAggregateInputType | true
    }

  export interface quizsubmissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['quizsubmission'], meta: { name: 'quizsubmission' } }
    /**
     * Find zero or one Quizsubmission that matches the filter.
     * @param {quizsubmissionFindUniqueArgs} args - Arguments to find a Quizsubmission
     * @example
     * // Get one Quizsubmission
     * const quizsubmission = await prisma.quizsubmission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends quizsubmissionFindUniqueArgs>(args: SelectSubset<T, quizsubmissionFindUniqueArgs<ExtArgs>>): Prisma__quizsubmissionClient<$Result.GetResult<Prisma.$quizsubmissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Quizsubmission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {quizsubmissionFindUniqueOrThrowArgs} args - Arguments to find a Quizsubmission
     * @example
     * // Get one Quizsubmission
     * const quizsubmission = await prisma.quizsubmission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends quizsubmissionFindUniqueOrThrowArgs>(args: SelectSubset<T, quizsubmissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__quizsubmissionClient<$Result.GetResult<Prisma.$quizsubmissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quizsubmission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quizsubmissionFindFirstArgs} args - Arguments to find a Quizsubmission
     * @example
     * // Get one Quizsubmission
     * const quizsubmission = await prisma.quizsubmission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends quizsubmissionFindFirstArgs>(args?: SelectSubset<T, quizsubmissionFindFirstArgs<ExtArgs>>): Prisma__quizsubmissionClient<$Result.GetResult<Prisma.$quizsubmissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quizsubmission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quizsubmissionFindFirstOrThrowArgs} args - Arguments to find a Quizsubmission
     * @example
     * // Get one Quizsubmission
     * const quizsubmission = await prisma.quizsubmission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends quizsubmissionFindFirstOrThrowArgs>(args?: SelectSubset<T, quizsubmissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__quizsubmissionClient<$Result.GetResult<Prisma.$quizsubmissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Quizsubmissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quizsubmissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quizsubmissions
     * const quizsubmissions = await prisma.quizsubmission.findMany()
     * 
     * // Get first 10 Quizsubmissions
     * const quizsubmissions = await prisma.quizsubmission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizsubmissionWithIdOnly = await prisma.quizsubmission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends quizsubmissionFindManyArgs>(args?: SelectSubset<T, quizsubmissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$quizsubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Quizsubmission.
     * @param {quizsubmissionCreateArgs} args - Arguments to create a Quizsubmission.
     * @example
     * // Create one Quizsubmission
     * const Quizsubmission = await prisma.quizsubmission.create({
     *   data: {
     *     // ... data to create a Quizsubmission
     *   }
     * })
     * 
     */
    create<T extends quizsubmissionCreateArgs>(args: SelectSubset<T, quizsubmissionCreateArgs<ExtArgs>>): Prisma__quizsubmissionClient<$Result.GetResult<Prisma.$quizsubmissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Quizsubmissions.
     * @param {quizsubmissionCreateManyArgs} args - Arguments to create many Quizsubmissions.
     * @example
     * // Create many Quizsubmissions
     * const quizsubmission = await prisma.quizsubmission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends quizsubmissionCreateManyArgs>(args?: SelectSubset<T, quizsubmissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Quizsubmission.
     * @param {quizsubmissionDeleteArgs} args - Arguments to delete one Quizsubmission.
     * @example
     * // Delete one Quizsubmission
     * const Quizsubmission = await prisma.quizsubmission.delete({
     *   where: {
     *     // ... filter to delete one Quizsubmission
     *   }
     * })
     * 
     */
    delete<T extends quizsubmissionDeleteArgs>(args: SelectSubset<T, quizsubmissionDeleteArgs<ExtArgs>>): Prisma__quizsubmissionClient<$Result.GetResult<Prisma.$quizsubmissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Quizsubmission.
     * @param {quizsubmissionUpdateArgs} args - Arguments to update one Quizsubmission.
     * @example
     * // Update one Quizsubmission
     * const quizsubmission = await prisma.quizsubmission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends quizsubmissionUpdateArgs>(args: SelectSubset<T, quizsubmissionUpdateArgs<ExtArgs>>): Prisma__quizsubmissionClient<$Result.GetResult<Prisma.$quizsubmissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Quizsubmissions.
     * @param {quizsubmissionDeleteManyArgs} args - Arguments to filter Quizsubmissions to delete.
     * @example
     * // Delete a few Quizsubmissions
     * const { count } = await prisma.quizsubmission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends quizsubmissionDeleteManyArgs>(args?: SelectSubset<T, quizsubmissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quizsubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quizsubmissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quizsubmissions
     * const quizsubmission = await prisma.quizsubmission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends quizsubmissionUpdateManyArgs>(args: SelectSubset<T, quizsubmissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Quizsubmission.
     * @param {quizsubmissionUpsertArgs} args - Arguments to update or create a Quizsubmission.
     * @example
     * // Update or create a Quizsubmission
     * const quizsubmission = await prisma.quizsubmission.upsert({
     *   create: {
     *     // ... data to create a Quizsubmission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quizsubmission we want to update
     *   }
     * })
     */
    upsert<T extends quizsubmissionUpsertArgs>(args: SelectSubset<T, quizsubmissionUpsertArgs<ExtArgs>>): Prisma__quizsubmissionClient<$Result.GetResult<Prisma.$quizsubmissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Quizsubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quizsubmissionCountArgs} args - Arguments to filter Quizsubmissions to count.
     * @example
     * // Count the number of Quizsubmissions
     * const count = await prisma.quizsubmission.count({
     *   where: {
     *     // ... the filter for the Quizsubmissions we want to count
     *   }
     * })
    **/
    count<T extends quizsubmissionCountArgs>(
      args?: Subset<T, quizsubmissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizsubmissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quizsubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizsubmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizsubmissionAggregateArgs>(args: Subset<T, QuizsubmissionAggregateArgs>): Prisma.PrismaPromise<GetQuizsubmissionAggregateType<T>>

    /**
     * Group by Quizsubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quizsubmissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends quizsubmissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: quizsubmissionGroupByArgs['orderBy'] }
        : { orderBy?: quizsubmissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, quizsubmissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizsubmissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the quizsubmission model
   */
  readonly fields: quizsubmissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for quizsubmission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__quizsubmissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends courseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, courseDefaultArgs<ExtArgs>>): Prisma__courseClient<$Result.GetResult<Prisma.$coursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    quiz<T extends quizDefaultArgs<ExtArgs> = {}>(args?: Subset<T, quizDefaultArgs<ExtArgs>>): Prisma__quizClient<$Result.GetResult<Prisma.$quizPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the quizsubmission model
   */
  interface quizsubmissionFieldRefs {
    readonly id: FieldRef<"quizsubmission", 'Int'>
    readonly userId: FieldRef<"quizsubmission", 'Int'>
    readonly courseId: FieldRef<"quizsubmission", 'Int'>
    readonly quizId: FieldRef<"quizsubmission", 'Int'>
    readonly answers: FieldRef<"quizsubmission", 'Json'>
    readonly score: FieldRef<"quizsubmission", 'Int'>
    readonly totalQuestions: FieldRef<"quizsubmission", 'Int'>
    readonly isPassed: FieldRef<"quizsubmission", 'Boolean'>
    readonly createdAt: FieldRef<"quizsubmission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * quizsubmission findUnique
   */
  export type quizsubmissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quizsubmission
     */
    select?: quizsubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quizsubmission
     */
    omit?: quizsubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quizsubmissionInclude<ExtArgs> | null
    /**
     * Filter, which quizsubmission to fetch.
     */
    where: quizsubmissionWhereUniqueInput
  }

  /**
   * quizsubmission findUniqueOrThrow
   */
  export type quizsubmissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quizsubmission
     */
    select?: quizsubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quizsubmission
     */
    omit?: quizsubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quizsubmissionInclude<ExtArgs> | null
    /**
     * Filter, which quizsubmission to fetch.
     */
    where: quizsubmissionWhereUniqueInput
  }

  /**
   * quizsubmission findFirst
   */
  export type quizsubmissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quizsubmission
     */
    select?: quizsubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quizsubmission
     */
    omit?: quizsubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quizsubmissionInclude<ExtArgs> | null
    /**
     * Filter, which quizsubmission to fetch.
     */
    where?: quizsubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quizsubmissions to fetch.
     */
    orderBy?: quizsubmissionOrderByWithRelationInput | quizsubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for quizsubmissions.
     */
    cursor?: quizsubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quizsubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quizsubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of quizsubmissions.
     */
    distinct?: QuizsubmissionScalarFieldEnum | QuizsubmissionScalarFieldEnum[]
  }

  /**
   * quizsubmission findFirstOrThrow
   */
  export type quizsubmissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quizsubmission
     */
    select?: quizsubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quizsubmission
     */
    omit?: quizsubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quizsubmissionInclude<ExtArgs> | null
    /**
     * Filter, which quizsubmission to fetch.
     */
    where?: quizsubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quizsubmissions to fetch.
     */
    orderBy?: quizsubmissionOrderByWithRelationInput | quizsubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for quizsubmissions.
     */
    cursor?: quizsubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quizsubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quizsubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of quizsubmissions.
     */
    distinct?: QuizsubmissionScalarFieldEnum | QuizsubmissionScalarFieldEnum[]
  }

  /**
   * quizsubmission findMany
   */
  export type quizsubmissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quizsubmission
     */
    select?: quizsubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quizsubmission
     */
    omit?: quizsubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quizsubmissionInclude<ExtArgs> | null
    /**
     * Filter, which quizsubmissions to fetch.
     */
    where?: quizsubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quizsubmissions to fetch.
     */
    orderBy?: quizsubmissionOrderByWithRelationInput | quizsubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing quizsubmissions.
     */
    cursor?: quizsubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quizsubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quizsubmissions.
     */
    skip?: number
    distinct?: QuizsubmissionScalarFieldEnum | QuizsubmissionScalarFieldEnum[]
  }

  /**
   * quizsubmission create
   */
  export type quizsubmissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quizsubmission
     */
    select?: quizsubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quizsubmission
     */
    omit?: quizsubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quizsubmissionInclude<ExtArgs> | null
    /**
     * The data needed to create a quizsubmission.
     */
    data: XOR<quizsubmissionCreateInput, quizsubmissionUncheckedCreateInput>
  }

  /**
   * quizsubmission createMany
   */
  export type quizsubmissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many quizsubmissions.
     */
    data: quizsubmissionCreateManyInput | quizsubmissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * quizsubmission update
   */
  export type quizsubmissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quizsubmission
     */
    select?: quizsubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quizsubmission
     */
    omit?: quizsubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quizsubmissionInclude<ExtArgs> | null
    /**
     * The data needed to update a quizsubmission.
     */
    data: XOR<quizsubmissionUpdateInput, quizsubmissionUncheckedUpdateInput>
    /**
     * Choose, which quizsubmission to update.
     */
    where: quizsubmissionWhereUniqueInput
  }

  /**
   * quizsubmission updateMany
   */
  export type quizsubmissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update quizsubmissions.
     */
    data: XOR<quizsubmissionUpdateManyMutationInput, quizsubmissionUncheckedUpdateManyInput>
    /**
     * Filter which quizsubmissions to update
     */
    where?: quizsubmissionWhereInput
    /**
     * Limit how many quizsubmissions to update.
     */
    limit?: number
  }

  /**
   * quizsubmission upsert
   */
  export type quizsubmissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quizsubmission
     */
    select?: quizsubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quizsubmission
     */
    omit?: quizsubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quizsubmissionInclude<ExtArgs> | null
    /**
     * The filter to search for the quizsubmission to update in case it exists.
     */
    where: quizsubmissionWhereUniqueInput
    /**
     * In case the quizsubmission found by the `where` argument doesn't exist, create a new quizsubmission with this data.
     */
    create: XOR<quizsubmissionCreateInput, quizsubmissionUncheckedCreateInput>
    /**
     * In case the quizsubmission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<quizsubmissionUpdateInput, quizsubmissionUncheckedUpdateInput>
  }

  /**
   * quizsubmission delete
   */
  export type quizsubmissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quizsubmission
     */
    select?: quizsubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quizsubmission
     */
    omit?: quizsubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quizsubmissionInclude<ExtArgs> | null
    /**
     * Filter which quizsubmission to delete.
     */
    where: quizsubmissionWhereUniqueInput
  }

  /**
   * quizsubmission deleteMany
   */
  export type quizsubmissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which quizsubmissions to delete
     */
    where?: quizsubmissionWhereInput
    /**
     * Limit how many quizsubmissions to delete.
     */
    limit?: number
  }

  /**
   * quizsubmission without action
   */
  export type quizsubmissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quizsubmission
     */
    select?: quizsubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quizsubmission
     */
    omit?: quizsubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quizsubmissionInclude<ExtArgs> | null
  }


  /**
   * Model roadmap
   */

  export type AggregateRoadmap = {
    _count: RoadmapCountAggregateOutputType | null
    _avg: RoadmapAvgAggregateOutputType | null
    _sum: RoadmapSumAggregateOutputType | null
    _min: RoadmapMinAggregateOutputType | null
    _max: RoadmapMaxAggregateOutputType | null
  }

  export type RoadmapAvgAggregateOutputType = {
    id: number | null
  }

  export type RoadmapSumAggregateOutputType = {
    id: number | null
  }

  export type RoadmapMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    rewardVoucher: string | null
  }

  export type RoadmapMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    rewardVoucher: string | null
  }

  export type RoadmapCountAggregateOutputType = {
    id: number
    name: number
    description: number
    rewardVoucher: number
    _all: number
  }


  export type RoadmapAvgAggregateInputType = {
    id?: true
  }

  export type RoadmapSumAggregateInputType = {
    id?: true
  }

  export type RoadmapMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    rewardVoucher?: true
  }

  export type RoadmapMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    rewardVoucher?: true
  }

  export type RoadmapCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    rewardVoucher?: true
    _all?: true
  }

  export type RoadmapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roadmap to aggregate.
     */
    where?: roadmapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roadmaps to fetch.
     */
    orderBy?: roadmapOrderByWithRelationInput | roadmapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: roadmapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roadmaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roadmaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned roadmaps
    **/
    _count?: true | RoadmapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoadmapAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoadmapSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoadmapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoadmapMaxAggregateInputType
  }

  export type GetRoadmapAggregateType<T extends RoadmapAggregateArgs> = {
        [P in keyof T & keyof AggregateRoadmap]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoadmap[P]>
      : GetScalarType<T[P], AggregateRoadmap[P]>
  }




  export type roadmapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: roadmapWhereInput
    orderBy?: roadmapOrderByWithAggregationInput | roadmapOrderByWithAggregationInput[]
    by: RoadmapScalarFieldEnum[] | RoadmapScalarFieldEnum
    having?: roadmapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoadmapCountAggregateInputType | true
    _avg?: RoadmapAvgAggregateInputType
    _sum?: RoadmapSumAggregateInputType
    _min?: RoadmapMinAggregateInputType
    _max?: RoadmapMaxAggregateInputType
  }

  export type RoadmapGroupByOutputType = {
    id: number
    name: string
    description: string
    rewardVoucher: string
    _count: RoadmapCountAggregateOutputType | null
    _avg: RoadmapAvgAggregateOutputType | null
    _sum: RoadmapSumAggregateOutputType | null
    _min: RoadmapMinAggregateOutputType | null
    _max: RoadmapMaxAggregateOutputType | null
  }

  type GetRoadmapGroupByPayload<T extends roadmapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoadmapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoadmapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoadmapGroupByOutputType[P]>
            : GetScalarType<T[P], RoadmapGroupByOutputType[P]>
        }
      >
    >


  export type roadmapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    rewardVoucher?: boolean
    payment?: boolean | roadmap$paymentArgs<ExtArgs>
    roadmapcourse?: boolean | roadmap$roadmapcourseArgs<ExtArgs>
    userroadmap?: boolean | roadmap$userroadmapArgs<ExtArgs>
    _count?: boolean | RoadmapCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roadmap"]>



  export type roadmapSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    rewardVoucher?: boolean
  }

  export type roadmapOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "rewardVoucher", ExtArgs["result"]["roadmap"]>
  export type roadmapInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | roadmap$paymentArgs<ExtArgs>
    roadmapcourse?: boolean | roadmap$roadmapcourseArgs<ExtArgs>
    userroadmap?: boolean | roadmap$userroadmapArgs<ExtArgs>
    _count?: boolean | RoadmapCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $roadmapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "roadmap"
    objects: {
      payment: Prisma.$paymentPayload<ExtArgs>[]
      roadmapcourse: Prisma.$roadmapcoursePayload<ExtArgs>[]
      userroadmap: Prisma.$userroadmapPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string
      rewardVoucher: string
    }, ExtArgs["result"]["roadmap"]>
    composites: {}
  }

  type roadmapGetPayload<S extends boolean | null | undefined | roadmapDefaultArgs> = $Result.GetResult<Prisma.$roadmapPayload, S>

  type roadmapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<roadmapFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoadmapCountAggregateInputType | true
    }

  export interface roadmapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['roadmap'], meta: { name: 'roadmap' } }
    /**
     * Find zero or one Roadmap that matches the filter.
     * @param {roadmapFindUniqueArgs} args - Arguments to find a Roadmap
     * @example
     * // Get one Roadmap
     * const roadmap = await prisma.roadmap.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends roadmapFindUniqueArgs>(args: SelectSubset<T, roadmapFindUniqueArgs<ExtArgs>>): Prisma__roadmapClient<$Result.GetResult<Prisma.$roadmapPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Roadmap that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {roadmapFindUniqueOrThrowArgs} args - Arguments to find a Roadmap
     * @example
     * // Get one Roadmap
     * const roadmap = await prisma.roadmap.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends roadmapFindUniqueOrThrowArgs>(args: SelectSubset<T, roadmapFindUniqueOrThrowArgs<ExtArgs>>): Prisma__roadmapClient<$Result.GetResult<Prisma.$roadmapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Roadmap that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roadmapFindFirstArgs} args - Arguments to find a Roadmap
     * @example
     * // Get one Roadmap
     * const roadmap = await prisma.roadmap.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends roadmapFindFirstArgs>(args?: SelectSubset<T, roadmapFindFirstArgs<ExtArgs>>): Prisma__roadmapClient<$Result.GetResult<Prisma.$roadmapPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Roadmap that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roadmapFindFirstOrThrowArgs} args - Arguments to find a Roadmap
     * @example
     * // Get one Roadmap
     * const roadmap = await prisma.roadmap.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends roadmapFindFirstOrThrowArgs>(args?: SelectSubset<T, roadmapFindFirstOrThrowArgs<ExtArgs>>): Prisma__roadmapClient<$Result.GetResult<Prisma.$roadmapPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roadmaps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roadmapFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roadmaps
     * const roadmaps = await prisma.roadmap.findMany()
     * 
     * // Get first 10 Roadmaps
     * const roadmaps = await prisma.roadmap.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roadmapWithIdOnly = await prisma.roadmap.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends roadmapFindManyArgs>(args?: SelectSubset<T, roadmapFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$roadmapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Roadmap.
     * @param {roadmapCreateArgs} args - Arguments to create a Roadmap.
     * @example
     * // Create one Roadmap
     * const Roadmap = await prisma.roadmap.create({
     *   data: {
     *     // ... data to create a Roadmap
     *   }
     * })
     * 
     */
    create<T extends roadmapCreateArgs>(args: SelectSubset<T, roadmapCreateArgs<ExtArgs>>): Prisma__roadmapClient<$Result.GetResult<Prisma.$roadmapPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roadmaps.
     * @param {roadmapCreateManyArgs} args - Arguments to create many Roadmaps.
     * @example
     * // Create many Roadmaps
     * const roadmap = await prisma.roadmap.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends roadmapCreateManyArgs>(args?: SelectSubset<T, roadmapCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Roadmap.
     * @param {roadmapDeleteArgs} args - Arguments to delete one Roadmap.
     * @example
     * // Delete one Roadmap
     * const Roadmap = await prisma.roadmap.delete({
     *   where: {
     *     // ... filter to delete one Roadmap
     *   }
     * })
     * 
     */
    delete<T extends roadmapDeleteArgs>(args: SelectSubset<T, roadmapDeleteArgs<ExtArgs>>): Prisma__roadmapClient<$Result.GetResult<Prisma.$roadmapPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Roadmap.
     * @param {roadmapUpdateArgs} args - Arguments to update one Roadmap.
     * @example
     * // Update one Roadmap
     * const roadmap = await prisma.roadmap.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends roadmapUpdateArgs>(args: SelectSubset<T, roadmapUpdateArgs<ExtArgs>>): Prisma__roadmapClient<$Result.GetResult<Prisma.$roadmapPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roadmaps.
     * @param {roadmapDeleteManyArgs} args - Arguments to filter Roadmaps to delete.
     * @example
     * // Delete a few Roadmaps
     * const { count } = await prisma.roadmap.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends roadmapDeleteManyArgs>(args?: SelectSubset<T, roadmapDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roadmaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roadmapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roadmaps
     * const roadmap = await prisma.roadmap.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends roadmapUpdateManyArgs>(args: SelectSubset<T, roadmapUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Roadmap.
     * @param {roadmapUpsertArgs} args - Arguments to update or create a Roadmap.
     * @example
     * // Update or create a Roadmap
     * const roadmap = await prisma.roadmap.upsert({
     *   create: {
     *     // ... data to create a Roadmap
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Roadmap we want to update
     *   }
     * })
     */
    upsert<T extends roadmapUpsertArgs>(args: SelectSubset<T, roadmapUpsertArgs<ExtArgs>>): Prisma__roadmapClient<$Result.GetResult<Prisma.$roadmapPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roadmaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roadmapCountArgs} args - Arguments to filter Roadmaps to count.
     * @example
     * // Count the number of Roadmaps
     * const count = await prisma.roadmap.count({
     *   where: {
     *     // ... the filter for the Roadmaps we want to count
     *   }
     * })
    **/
    count<T extends roadmapCountArgs>(
      args?: Subset<T, roadmapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoadmapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Roadmap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoadmapAggregateArgs>(args: Subset<T, RoadmapAggregateArgs>): Prisma.PrismaPromise<GetRoadmapAggregateType<T>>

    /**
     * Group by Roadmap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roadmapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends roadmapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: roadmapGroupByArgs['orderBy'] }
        : { orderBy?: roadmapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, roadmapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoadmapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the roadmap model
   */
  readonly fields: roadmapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for roadmap.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__roadmapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payment<T extends roadmap$paymentArgs<ExtArgs> = {}>(args?: Subset<T, roadmap$paymentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    roadmapcourse<T extends roadmap$roadmapcourseArgs<ExtArgs> = {}>(args?: Subset<T, roadmap$roadmapcourseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$roadmapcoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userroadmap<T extends roadmap$userroadmapArgs<ExtArgs> = {}>(args?: Subset<T, roadmap$userroadmapArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userroadmapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the roadmap model
   */
  interface roadmapFieldRefs {
    readonly id: FieldRef<"roadmap", 'Int'>
    readonly name: FieldRef<"roadmap", 'String'>
    readonly description: FieldRef<"roadmap", 'String'>
    readonly rewardVoucher: FieldRef<"roadmap", 'String'>
  }
    

  // Custom InputTypes
  /**
   * roadmap findUnique
   */
  export type roadmapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roadmap
     */
    select?: roadmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roadmap
     */
    omit?: roadmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roadmapInclude<ExtArgs> | null
    /**
     * Filter, which roadmap to fetch.
     */
    where: roadmapWhereUniqueInput
  }

  /**
   * roadmap findUniqueOrThrow
   */
  export type roadmapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roadmap
     */
    select?: roadmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roadmap
     */
    omit?: roadmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roadmapInclude<ExtArgs> | null
    /**
     * Filter, which roadmap to fetch.
     */
    where: roadmapWhereUniqueInput
  }

  /**
   * roadmap findFirst
   */
  export type roadmapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roadmap
     */
    select?: roadmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roadmap
     */
    omit?: roadmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roadmapInclude<ExtArgs> | null
    /**
     * Filter, which roadmap to fetch.
     */
    where?: roadmapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roadmaps to fetch.
     */
    orderBy?: roadmapOrderByWithRelationInput | roadmapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roadmaps.
     */
    cursor?: roadmapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roadmaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roadmaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roadmaps.
     */
    distinct?: RoadmapScalarFieldEnum | RoadmapScalarFieldEnum[]
  }

  /**
   * roadmap findFirstOrThrow
   */
  export type roadmapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roadmap
     */
    select?: roadmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roadmap
     */
    omit?: roadmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roadmapInclude<ExtArgs> | null
    /**
     * Filter, which roadmap to fetch.
     */
    where?: roadmapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roadmaps to fetch.
     */
    orderBy?: roadmapOrderByWithRelationInput | roadmapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roadmaps.
     */
    cursor?: roadmapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roadmaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roadmaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roadmaps.
     */
    distinct?: RoadmapScalarFieldEnum | RoadmapScalarFieldEnum[]
  }

  /**
   * roadmap findMany
   */
  export type roadmapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roadmap
     */
    select?: roadmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roadmap
     */
    omit?: roadmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roadmapInclude<ExtArgs> | null
    /**
     * Filter, which roadmaps to fetch.
     */
    where?: roadmapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roadmaps to fetch.
     */
    orderBy?: roadmapOrderByWithRelationInput | roadmapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing roadmaps.
     */
    cursor?: roadmapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roadmaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roadmaps.
     */
    skip?: number
    distinct?: RoadmapScalarFieldEnum | RoadmapScalarFieldEnum[]
  }

  /**
   * roadmap create
   */
  export type roadmapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roadmap
     */
    select?: roadmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roadmap
     */
    omit?: roadmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roadmapInclude<ExtArgs> | null
    /**
     * The data needed to create a roadmap.
     */
    data: XOR<roadmapCreateInput, roadmapUncheckedCreateInput>
  }

  /**
   * roadmap createMany
   */
  export type roadmapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many roadmaps.
     */
    data: roadmapCreateManyInput | roadmapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * roadmap update
   */
  export type roadmapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roadmap
     */
    select?: roadmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roadmap
     */
    omit?: roadmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roadmapInclude<ExtArgs> | null
    /**
     * The data needed to update a roadmap.
     */
    data: XOR<roadmapUpdateInput, roadmapUncheckedUpdateInput>
    /**
     * Choose, which roadmap to update.
     */
    where: roadmapWhereUniqueInput
  }

  /**
   * roadmap updateMany
   */
  export type roadmapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update roadmaps.
     */
    data: XOR<roadmapUpdateManyMutationInput, roadmapUncheckedUpdateManyInput>
    /**
     * Filter which roadmaps to update
     */
    where?: roadmapWhereInput
    /**
     * Limit how many roadmaps to update.
     */
    limit?: number
  }

  /**
   * roadmap upsert
   */
  export type roadmapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roadmap
     */
    select?: roadmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roadmap
     */
    omit?: roadmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roadmapInclude<ExtArgs> | null
    /**
     * The filter to search for the roadmap to update in case it exists.
     */
    where: roadmapWhereUniqueInput
    /**
     * In case the roadmap found by the `where` argument doesn't exist, create a new roadmap with this data.
     */
    create: XOR<roadmapCreateInput, roadmapUncheckedCreateInput>
    /**
     * In case the roadmap was found with the provided `where` argument, update it with this data.
     */
    update: XOR<roadmapUpdateInput, roadmapUncheckedUpdateInput>
  }

  /**
   * roadmap delete
   */
  export type roadmapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roadmap
     */
    select?: roadmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roadmap
     */
    omit?: roadmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roadmapInclude<ExtArgs> | null
    /**
     * Filter which roadmap to delete.
     */
    where: roadmapWhereUniqueInput
  }

  /**
   * roadmap deleteMany
   */
  export type roadmapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roadmaps to delete
     */
    where?: roadmapWhereInput
    /**
     * Limit how many roadmaps to delete.
     */
    limit?: number
  }

  /**
   * roadmap.payment
   */
  export type roadmap$paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment
     */
    select?: paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payment
     */
    omit?: paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentInclude<ExtArgs> | null
    where?: paymentWhereInput
    orderBy?: paymentOrderByWithRelationInput | paymentOrderByWithRelationInput[]
    cursor?: paymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * roadmap.roadmapcourse
   */
  export type roadmap$roadmapcourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roadmapcourse
     */
    select?: roadmapcourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roadmapcourse
     */
    omit?: roadmapcourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roadmapcourseInclude<ExtArgs> | null
    where?: roadmapcourseWhereInput
    orderBy?: roadmapcourseOrderByWithRelationInput | roadmapcourseOrderByWithRelationInput[]
    cursor?: roadmapcourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoadmapcourseScalarFieldEnum | RoadmapcourseScalarFieldEnum[]
  }

  /**
   * roadmap.userroadmap
   */
  export type roadmap$userroadmapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userroadmap
     */
    select?: userroadmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userroadmap
     */
    omit?: userroadmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroadmapInclude<ExtArgs> | null
    where?: userroadmapWhereInput
    orderBy?: userroadmapOrderByWithRelationInput | userroadmapOrderByWithRelationInput[]
    cursor?: userroadmapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserroadmapScalarFieldEnum | UserroadmapScalarFieldEnum[]
  }

  /**
   * roadmap without action
   */
  export type roadmapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roadmap
     */
    select?: roadmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roadmap
     */
    omit?: roadmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roadmapInclude<ExtArgs> | null
  }


  /**
   * Model roadmapcourse
   */

  export type AggregateRoadmapcourse = {
    _count: RoadmapcourseCountAggregateOutputType | null
    _avg: RoadmapcourseAvgAggregateOutputType | null
    _sum: RoadmapcourseSumAggregateOutputType | null
    _min: RoadmapcourseMinAggregateOutputType | null
    _max: RoadmapcourseMaxAggregateOutputType | null
  }

  export type RoadmapcourseAvgAggregateOutputType = {
    id: number | null
    roadmapId: number | null
    courseId: number | null
    order: number | null
  }

  export type RoadmapcourseSumAggregateOutputType = {
    id: number | null
    roadmapId: number | null
    courseId: number | null
    order: number | null
  }

  export type RoadmapcourseMinAggregateOutputType = {
    id: number | null
    roadmapId: number | null
    courseId: number | null
    order: number | null
  }

  export type RoadmapcourseMaxAggregateOutputType = {
    id: number | null
    roadmapId: number | null
    courseId: number | null
    order: number | null
  }

  export type RoadmapcourseCountAggregateOutputType = {
    id: number
    roadmapId: number
    courseId: number
    order: number
    _all: number
  }


  export type RoadmapcourseAvgAggregateInputType = {
    id?: true
    roadmapId?: true
    courseId?: true
    order?: true
  }

  export type RoadmapcourseSumAggregateInputType = {
    id?: true
    roadmapId?: true
    courseId?: true
    order?: true
  }

  export type RoadmapcourseMinAggregateInputType = {
    id?: true
    roadmapId?: true
    courseId?: true
    order?: true
  }

  export type RoadmapcourseMaxAggregateInputType = {
    id?: true
    roadmapId?: true
    courseId?: true
    order?: true
  }

  export type RoadmapcourseCountAggregateInputType = {
    id?: true
    roadmapId?: true
    courseId?: true
    order?: true
    _all?: true
  }

  export type RoadmapcourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roadmapcourse to aggregate.
     */
    where?: roadmapcourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roadmapcourses to fetch.
     */
    orderBy?: roadmapcourseOrderByWithRelationInput | roadmapcourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: roadmapcourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roadmapcourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roadmapcourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned roadmapcourses
    **/
    _count?: true | RoadmapcourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoadmapcourseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoadmapcourseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoadmapcourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoadmapcourseMaxAggregateInputType
  }

  export type GetRoadmapcourseAggregateType<T extends RoadmapcourseAggregateArgs> = {
        [P in keyof T & keyof AggregateRoadmapcourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoadmapcourse[P]>
      : GetScalarType<T[P], AggregateRoadmapcourse[P]>
  }




  export type roadmapcourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: roadmapcourseWhereInput
    orderBy?: roadmapcourseOrderByWithAggregationInput | roadmapcourseOrderByWithAggregationInput[]
    by: RoadmapcourseScalarFieldEnum[] | RoadmapcourseScalarFieldEnum
    having?: roadmapcourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoadmapcourseCountAggregateInputType | true
    _avg?: RoadmapcourseAvgAggregateInputType
    _sum?: RoadmapcourseSumAggregateInputType
    _min?: RoadmapcourseMinAggregateInputType
    _max?: RoadmapcourseMaxAggregateInputType
  }

  export type RoadmapcourseGroupByOutputType = {
    id: number
    roadmapId: number
    courseId: number
    order: number
    _count: RoadmapcourseCountAggregateOutputType | null
    _avg: RoadmapcourseAvgAggregateOutputType | null
    _sum: RoadmapcourseSumAggregateOutputType | null
    _min: RoadmapcourseMinAggregateOutputType | null
    _max: RoadmapcourseMaxAggregateOutputType | null
  }

  type GetRoadmapcourseGroupByPayload<T extends roadmapcourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoadmapcourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoadmapcourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoadmapcourseGroupByOutputType[P]>
            : GetScalarType<T[P], RoadmapcourseGroupByOutputType[P]>
        }
      >
    >


  export type roadmapcourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roadmapId?: boolean
    courseId?: boolean
    order?: boolean
    course?: boolean | courseDefaultArgs<ExtArgs>
    roadmap?: boolean | roadmapDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roadmapcourse"]>



  export type roadmapcourseSelectScalar = {
    id?: boolean
    roadmapId?: boolean
    courseId?: boolean
    order?: boolean
  }

  export type roadmapcourseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roadmapId" | "courseId" | "order", ExtArgs["result"]["roadmapcourse"]>
  export type roadmapcourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | courseDefaultArgs<ExtArgs>
    roadmap?: boolean | roadmapDefaultArgs<ExtArgs>
  }

  export type $roadmapcoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "roadmapcourse"
    objects: {
      course: Prisma.$coursePayload<ExtArgs>
      roadmap: Prisma.$roadmapPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      roadmapId: number
      courseId: number
      order: number
    }, ExtArgs["result"]["roadmapcourse"]>
    composites: {}
  }

  type roadmapcourseGetPayload<S extends boolean | null | undefined | roadmapcourseDefaultArgs> = $Result.GetResult<Prisma.$roadmapcoursePayload, S>

  type roadmapcourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<roadmapcourseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoadmapcourseCountAggregateInputType | true
    }

  export interface roadmapcourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['roadmapcourse'], meta: { name: 'roadmapcourse' } }
    /**
     * Find zero or one Roadmapcourse that matches the filter.
     * @param {roadmapcourseFindUniqueArgs} args - Arguments to find a Roadmapcourse
     * @example
     * // Get one Roadmapcourse
     * const roadmapcourse = await prisma.roadmapcourse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends roadmapcourseFindUniqueArgs>(args: SelectSubset<T, roadmapcourseFindUniqueArgs<ExtArgs>>): Prisma__roadmapcourseClient<$Result.GetResult<Prisma.$roadmapcoursePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Roadmapcourse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {roadmapcourseFindUniqueOrThrowArgs} args - Arguments to find a Roadmapcourse
     * @example
     * // Get one Roadmapcourse
     * const roadmapcourse = await prisma.roadmapcourse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends roadmapcourseFindUniqueOrThrowArgs>(args: SelectSubset<T, roadmapcourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__roadmapcourseClient<$Result.GetResult<Prisma.$roadmapcoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Roadmapcourse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roadmapcourseFindFirstArgs} args - Arguments to find a Roadmapcourse
     * @example
     * // Get one Roadmapcourse
     * const roadmapcourse = await prisma.roadmapcourse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends roadmapcourseFindFirstArgs>(args?: SelectSubset<T, roadmapcourseFindFirstArgs<ExtArgs>>): Prisma__roadmapcourseClient<$Result.GetResult<Prisma.$roadmapcoursePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Roadmapcourse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roadmapcourseFindFirstOrThrowArgs} args - Arguments to find a Roadmapcourse
     * @example
     * // Get one Roadmapcourse
     * const roadmapcourse = await prisma.roadmapcourse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends roadmapcourseFindFirstOrThrowArgs>(args?: SelectSubset<T, roadmapcourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__roadmapcourseClient<$Result.GetResult<Prisma.$roadmapcoursePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roadmapcourses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roadmapcourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roadmapcourses
     * const roadmapcourses = await prisma.roadmapcourse.findMany()
     * 
     * // Get first 10 Roadmapcourses
     * const roadmapcourses = await prisma.roadmapcourse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roadmapcourseWithIdOnly = await prisma.roadmapcourse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends roadmapcourseFindManyArgs>(args?: SelectSubset<T, roadmapcourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$roadmapcoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Roadmapcourse.
     * @param {roadmapcourseCreateArgs} args - Arguments to create a Roadmapcourse.
     * @example
     * // Create one Roadmapcourse
     * const Roadmapcourse = await prisma.roadmapcourse.create({
     *   data: {
     *     // ... data to create a Roadmapcourse
     *   }
     * })
     * 
     */
    create<T extends roadmapcourseCreateArgs>(args: SelectSubset<T, roadmapcourseCreateArgs<ExtArgs>>): Prisma__roadmapcourseClient<$Result.GetResult<Prisma.$roadmapcoursePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roadmapcourses.
     * @param {roadmapcourseCreateManyArgs} args - Arguments to create many Roadmapcourses.
     * @example
     * // Create many Roadmapcourses
     * const roadmapcourse = await prisma.roadmapcourse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends roadmapcourseCreateManyArgs>(args?: SelectSubset<T, roadmapcourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Roadmapcourse.
     * @param {roadmapcourseDeleteArgs} args - Arguments to delete one Roadmapcourse.
     * @example
     * // Delete one Roadmapcourse
     * const Roadmapcourse = await prisma.roadmapcourse.delete({
     *   where: {
     *     // ... filter to delete one Roadmapcourse
     *   }
     * })
     * 
     */
    delete<T extends roadmapcourseDeleteArgs>(args: SelectSubset<T, roadmapcourseDeleteArgs<ExtArgs>>): Prisma__roadmapcourseClient<$Result.GetResult<Prisma.$roadmapcoursePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Roadmapcourse.
     * @param {roadmapcourseUpdateArgs} args - Arguments to update one Roadmapcourse.
     * @example
     * // Update one Roadmapcourse
     * const roadmapcourse = await prisma.roadmapcourse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends roadmapcourseUpdateArgs>(args: SelectSubset<T, roadmapcourseUpdateArgs<ExtArgs>>): Prisma__roadmapcourseClient<$Result.GetResult<Prisma.$roadmapcoursePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roadmapcourses.
     * @param {roadmapcourseDeleteManyArgs} args - Arguments to filter Roadmapcourses to delete.
     * @example
     * // Delete a few Roadmapcourses
     * const { count } = await prisma.roadmapcourse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends roadmapcourseDeleteManyArgs>(args?: SelectSubset<T, roadmapcourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roadmapcourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roadmapcourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roadmapcourses
     * const roadmapcourse = await prisma.roadmapcourse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends roadmapcourseUpdateManyArgs>(args: SelectSubset<T, roadmapcourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Roadmapcourse.
     * @param {roadmapcourseUpsertArgs} args - Arguments to update or create a Roadmapcourse.
     * @example
     * // Update or create a Roadmapcourse
     * const roadmapcourse = await prisma.roadmapcourse.upsert({
     *   create: {
     *     // ... data to create a Roadmapcourse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Roadmapcourse we want to update
     *   }
     * })
     */
    upsert<T extends roadmapcourseUpsertArgs>(args: SelectSubset<T, roadmapcourseUpsertArgs<ExtArgs>>): Prisma__roadmapcourseClient<$Result.GetResult<Prisma.$roadmapcoursePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roadmapcourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roadmapcourseCountArgs} args - Arguments to filter Roadmapcourses to count.
     * @example
     * // Count the number of Roadmapcourses
     * const count = await prisma.roadmapcourse.count({
     *   where: {
     *     // ... the filter for the Roadmapcourses we want to count
     *   }
     * })
    **/
    count<T extends roadmapcourseCountArgs>(
      args?: Subset<T, roadmapcourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoadmapcourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Roadmapcourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapcourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoadmapcourseAggregateArgs>(args: Subset<T, RoadmapcourseAggregateArgs>): Prisma.PrismaPromise<GetRoadmapcourseAggregateType<T>>

    /**
     * Group by Roadmapcourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roadmapcourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends roadmapcourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: roadmapcourseGroupByArgs['orderBy'] }
        : { orderBy?: roadmapcourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, roadmapcourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoadmapcourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the roadmapcourse model
   */
  readonly fields: roadmapcourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for roadmapcourse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__roadmapcourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends courseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, courseDefaultArgs<ExtArgs>>): Prisma__courseClient<$Result.GetResult<Prisma.$coursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    roadmap<T extends roadmapDefaultArgs<ExtArgs> = {}>(args?: Subset<T, roadmapDefaultArgs<ExtArgs>>): Prisma__roadmapClient<$Result.GetResult<Prisma.$roadmapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the roadmapcourse model
   */
  interface roadmapcourseFieldRefs {
    readonly id: FieldRef<"roadmapcourse", 'Int'>
    readonly roadmapId: FieldRef<"roadmapcourse", 'Int'>
    readonly courseId: FieldRef<"roadmapcourse", 'Int'>
    readonly order: FieldRef<"roadmapcourse", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * roadmapcourse findUnique
   */
  export type roadmapcourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roadmapcourse
     */
    select?: roadmapcourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roadmapcourse
     */
    omit?: roadmapcourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roadmapcourseInclude<ExtArgs> | null
    /**
     * Filter, which roadmapcourse to fetch.
     */
    where: roadmapcourseWhereUniqueInput
  }

  /**
   * roadmapcourse findUniqueOrThrow
   */
  export type roadmapcourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roadmapcourse
     */
    select?: roadmapcourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roadmapcourse
     */
    omit?: roadmapcourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roadmapcourseInclude<ExtArgs> | null
    /**
     * Filter, which roadmapcourse to fetch.
     */
    where: roadmapcourseWhereUniqueInput
  }

  /**
   * roadmapcourse findFirst
   */
  export type roadmapcourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roadmapcourse
     */
    select?: roadmapcourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roadmapcourse
     */
    omit?: roadmapcourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roadmapcourseInclude<ExtArgs> | null
    /**
     * Filter, which roadmapcourse to fetch.
     */
    where?: roadmapcourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roadmapcourses to fetch.
     */
    orderBy?: roadmapcourseOrderByWithRelationInput | roadmapcourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roadmapcourses.
     */
    cursor?: roadmapcourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roadmapcourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roadmapcourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roadmapcourses.
     */
    distinct?: RoadmapcourseScalarFieldEnum | RoadmapcourseScalarFieldEnum[]
  }

  /**
   * roadmapcourse findFirstOrThrow
   */
  export type roadmapcourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roadmapcourse
     */
    select?: roadmapcourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roadmapcourse
     */
    omit?: roadmapcourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roadmapcourseInclude<ExtArgs> | null
    /**
     * Filter, which roadmapcourse to fetch.
     */
    where?: roadmapcourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roadmapcourses to fetch.
     */
    orderBy?: roadmapcourseOrderByWithRelationInput | roadmapcourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roadmapcourses.
     */
    cursor?: roadmapcourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roadmapcourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roadmapcourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roadmapcourses.
     */
    distinct?: RoadmapcourseScalarFieldEnum | RoadmapcourseScalarFieldEnum[]
  }

  /**
   * roadmapcourse findMany
   */
  export type roadmapcourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roadmapcourse
     */
    select?: roadmapcourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roadmapcourse
     */
    omit?: roadmapcourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roadmapcourseInclude<ExtArgs> | null
    /**
     * Filter, which roadmapcourses to fetch.
     */
    where?: roadmapcourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roadmapcourses to fetch.
     */
    orderBy?: roadmapcourseOrderByWithRelationInput | roadmapcourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing roadmapcourses.
     */
    cursor?: roadmapcourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roadmapcourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roadmapcourses.
     */
    skip?: number
    distinct?: RoadmapcourseScalarFieldEnum | RoadmapcourseScalarFieldEnum[]
  }

  /**
   * roadmapcourse create
   */
  export type roadmapcourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roadmapcourse
     */
    select?: roadmapcourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roadmapcourse
     */
    omit?: roadmapcourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roadmapcourseInclude<ExtArgs> | null
    /**
     * The data needed to create a roadmapcourse.
     */
    data: XOR<roadmapcourseCreateInput, roadmapcourseUncheckedCreateInput>
  }

  /**
   * roadmapcourse createMany
   */
  export type roadmapcourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many roadmapcourses.
     */
    data: roadmapcourseCreateManyInput | roadmapcourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * roadmapcourse update
   */
  export type roadmapcourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roadmapcourse
     */
    select?: roadmapcourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roadmapcourse
     */
    omit?: roadmapcourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roadmapcourseInclude<ExtArgs> | null
    /**
     * The data needed to update a roadmapcourse.
     */
    data: XOR<roadmapcourseUpdateInput, roadmapcourseUncheckedUpdateInput>
    /**
     * Choose, which roadmapcourse to update.
     */
    where: roadmapcourseWhereUniqueInput
  }

  /**
   * roadmapcourse updateMany
   */
  export type roadmapcourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update roadmapcourses.
     */
    data: XOR<roadmapcourseUpdateManyMutationInput, roadmapcourseUncheckedUpdateManyInput>
    /**
     * Filter which roadmapcourses to update
     */
    where?: roadmapcourseWhereInput
    /**
     * Limit how many roadmapcourses to update.
     */
    limit?: number
  }

  /**
   * roadmapcourse upsert
   */
  export type roadmapcourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roadmapcourse
     */
    select?: roadmapcourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roadmapcourse
     */
    omit?: roadmapcourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roadmapcourseInclude<ExtArgs> | null
    /**
     * The filter to search for the roadmapcourse to update in case it exists.
     */
    where: roadmapcourseWhereUniqueInput
    /**
     * In case the roadmapcourse found by the `where` argument doesn't exist, create a new roadmapcourse with this data.
     */
    create: XOR<roadmapcourseCreateInput, roadmapcourseUncheckedCreateInput>
    /**
     * In case the roadmapcourse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<roadmapcourseUpdateInput, roadmapcourseUncheckedUpdateInput>
  }

  /**
   * roadmapcourse delete
   */
  export type roadmapcourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roadmapcourse
     */
    select?: roadmapcourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roadmapcourse
     */
    omit?: roadmapcourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roadmapcourseInclude<ExtArgs> | null
    /**
     * Filter which roadmapcourse to delete.
     */
    where: roadmapcourseWhereUniqueInput
  }

  /**
   * roadmapcourse deleteMany
   */
  export type roadmapcourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roadmapcourses to delete
     */
    where?: roadmapcourseWhereInput
    /**
     * Limit how many roadmapcourses to delete.
     */
    limit?: number
  }

  /**
   * roadmapcourse without action
   */
  export type roadmapcourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roadmapcourse
     */
    select?: roadmapcourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roadmapcourse
     */
    omit?: roadmapcourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roadmapcourseInclude<ExtArgs> | null
  }


  /**
   * Model userroadmap
   */

  export type AggregateUserroadmap = {
    _count: UserroadmapCountAggregateOutputType | null
    _avg: UserroadmapAvgAggregateOutputType | null
    _sum: UserroadmapSumAggregateOutputType | null
    _min: UserroadmapMinAggregateOutputType | null
    _max: UserroadmapMaxAggregateOutputType | null
  }

  export type UserroadmapAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    roadmapId: number | null
  }

  export type UserroadmapSumAggregateOutputType = {
    id: number | null
    userId: number | null
    roadmapId: number | null
  }

  export type UserroadmapMinAggregateOutputType = {
    id: number | null
    userId: number | null
    roadmapId: number | null
    isUnlocked: boolean | null
    unlockedAt: Date | null
  }

  export type UserroadmapMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    roadmapId: number | null
    isUnlocked: boolean | null
    unlockedAt: Date | null
  }

  export type UserroadmapCountAggregateOutputType = {
    id: number
    userId: number
    roadmapId: number
    isUnlocked: number
    unlockedAt: number
    _all: number
  }


  export type UserroadmapAvgAggregateInputType = {
    id?: true
    userId?: true
    roadmapId?: true
  }

  export type UserroadmapSumAggregateInputType = {
    id?: true
    userId?: true
    roadmapId?: true
  }

  export type UserroadmapMinAggregateInputType = {
    id?: true
    userId?: true
    roadmapId?: true
    isUnlocked?: true
    unlockedAt?: true
  }

  export type UserroadmapMaxAggregateInputType = {
    id?: true
    userId?: true
    roadmapId?: true
    isUnlocked?: true
    unlockedAt?: true
  }

  export type UserroadmapCountAggregateInputType = {
    id?: true
    userId?: true
    roadmapId?: true
    isUnlocked?: true
    unlockedAt?: true
    _all?: true
  }

  export type UserroadmapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userroadmap to aggregate.
     */
    where?: userroadmapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userroadmaps to fetch.
     */
    orderBy?: userroadmapOrderByWithRelationInput | userroadmapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userroadmapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userroadmaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userroadmaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned userroadmaps
    **/
    _count?: true | UserroadmapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserroadmapAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserroadmapSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserroadmapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserroadmapMaxAggregateInputType
  }

  export type GetUserroadmapAggregateType<T extends UserroadmapAggregateArgs> = {
        [P in keyof T & keyof AggregateUserroadmap]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserroadmap[P]>
      : GetScalarType<T[P], AggregateUserroadmap[P]>
  }




  export type userroadmapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userroadmapWhereInput
    orderBy?: userroadmapOrderByWithAggregationInput | userroadmapOrderByWithAggregationInput[]
    by: UserroadmapScalarFieldEnum[] | UserroadmapScalarFieldEnum
    having?: userroadmapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserroadmapCountAggregateInputType | true
    _avg?: UserroadmapAvgAggregateInputType
    _sum?: UserroadmapSumAggregateInputType
    _min?: UserroadmapMinAggregateInputType
    _max?: UserroadmapMaxAggregateInputType
  }

  export type UserroadmapGroupByOutputType = {
    id: number
    userId: number
    roadmapId: number
    isUnlocked: boolean
    unlockedAt: Date | null
    _count: UserroadmapCountAggregateOutputType | null
    _avg: UserroadmapAvgAggregateOutputType | null
    _sum: UserroadmapSumAggregateOutputType | null
    _min: UserroadmapMinAggregateOutputType | null
    _max: UserroadmapMaxAggregateOutputType | null
  }

  type GetUserroadmapGroupByPayload<T extends userroadmapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserroadmapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserroadmapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserroadmapGroupByOutputType[P]>
            : GetScalarType<T[P], UserroadmapGroupByOutputType[P]>
        }
      >
    >


  export type userroadmapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roadmapId?: boolean
    isUnlocked?: boolean
    unlockedAt?: boolean
    roadmap?: boolean | roadmapDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userroadmap"]>



  export type userroadmapSelectScalar = {
    id?: boolean
    userId?: boolean
    roadmapId?: boolean
    isUnlocked?: boolean
    unlockedAt?: boolean
  }

  export type userroadmapOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "roadmapId" | "isUnlocked" | "unlockedAt", ExtArgs["result"]["userroadmap"]>
  export type userroadmapInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roadmap?: boolean | roadmapDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $userroadmapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "userroadmap"
    objects: {
      roadmap: Prisma.$roadmapPayload<ExtArgs>
      users: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      roadmapId: number
      isUnlocked: boolean
      unlockedAt: Date | null
    }, ExtArgs["result"]["userroadmap"]>
    composites: {}
  }

  type userroadmapGetPayload<S extends boolean | null | undefined | userroadmapDefaultArgs> = $Result.GetResult<Prisma.$userroadmapPayload, S>

  type userroadmapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<userroadmapFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserroadmapCountAggregateInputType | true
    }

  export interface userroadmapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['userroadmap'], meta: { name: 'userroadmap' } }
    /**
     * Find zero or one Userroadmap that matches the filter.
     * @param {userroadmapFindUniqueArgs} args - Arguments to find a Userroadmap
     * @example
     * // Get one Userroadmap
     * const userroadmap = await prisma.userroadmap.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userroadmapFindUniqueArgs>(args: SelectSubset<T, userroadmapFindUniqueArgs<ExtArgs>>): Prisma__userroadmapClient<$Result.GetResult<Prisma.$userroadmapPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Userroadmap that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {userroadmapFindUniqueOrThrowArgs} args - Arguments to find a Userroadmap
     * @example
     * // Get one Userroadmap
     * const userroadmap = await prisma.userroadmap.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userroadmapFindUniqueOrThrowArgs>(args: SelectSubset<T, userroadmapFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userroadmapClient<$Result.GetResult<Prisma.$userroadmapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Userroadmap that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userroadmapFindFirstArgs} args - Arguments to find a Userroadmap
     * @example
     * // Get one Userroadmap
     * const userroadmap = await prisma.userroadmap.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userroadmapFindFirstArgs>(args?: SelectSubset<T, userroadmapFindFirstArgs<ExtArgs>>): Prisma__userroadmapClient<$Result.GetResult<Prisma.$userroadmapPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Userroadmap that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userroadmapFindFirstOrThrowArgs} args - Arguments to find a Userroadmap
     * @example
     * // Get one Userroadmap
     * const userroadmap = await prisma.userroadmap.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userroadmapFindFirstOrThrowArgs>(args?: SelectSubset<T, userroadmapFindFirstOrThrowArgs<ExtArgs>>): Prisma__userroadmapClient<$Result.GetResult<Prisma.$userroadmapPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Userroadmaps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userroadmapFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Userroadmaps
     * const userroadmaps = await prisma.userroadmap.findMany()
     * 
     * // Get first 10 Userroadmaps
     * const userroadmaps = await prisma.userroadmap.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userroadmapWithIdOnly = await prisma.userroadmap.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends userroadmapFindManyArgs>(args?: SelectSubset<T, userroadmapFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userroadmapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Userroadmap.
     * @param {userroadmapCreateArgs} args - Arguments to create a Userroadmap.
     * @example
     * // Create one Userroadmap
     * const Userroadmap = await prisma.userroadmap.create({
     *   data: {
     *     // ... data to create a Userroadmap
     *   }
     * })
     * 
     */
    create<T extends userroadmapCreateArgs>(args: SelectSubset<T, userroadmapCreateArgs<ExtArgs>>): Prisma__userroadmapClient<$Result.GetResult<Prisma.$userroadmapPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Userroadmaps.
     * @param {userroadmapCreateManyArgs} args - Arguments to create many Userroadmaps.
     * @example
     * // Create many Userroadmaps
     * const userroadmap = await prisma.userroadmap.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userroadmapCreateManyArgs>(args?: SelectSubset<T, userroadmapCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Userroadmap.
     * @param {userroadmapDeleteArgs} args - Arguments to delete one Userroadmap.
     * @example
     * // Delete one Userroadmap
     * const Userroadmap = await prisma.userroadmap.delete({
     *   where: {
     *     // ... filter to delete one Userroadmap
     *   }
     * })
     * 
     */
    delete<T extends userroadmapDeleteArgs>(args: SelectSubset<T, userroadmapDeleteArgs<ExtArgs>>): Prisma__userroadmapClient<$Result.GetResult<Prisma.$userroadmapPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Userroadmap.
     * @param {userroadmapUpdateArgs} args - Arguments to update one Userroadmap.
     * @example
     * // Update one Userroadmap
     * const userroadmap = await prisma.userroadmap.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userroadmapUpdateArgs>(args: SelectSubset<T, userroadmapUpdateArgs<ExtArgs>>): Prisma__userroadmapClient<$Result.GetResult<Prisma.$userroadmapPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Userroadmaps.
     * @param {userroadmapDeleteManyArgs} args - Arguments to filter Userroadmaps to delete.
     * @example
     * // Delete a few Userroadmaps
     * const { count } = await prisma.userroadmap.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userroadmapDeleteManyArgs>(args?: SelectSubset<T, userroadmapDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Userroadmaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userroadmapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Userroadmaps
     * const userroadmap = await prisma.userroadmap.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userroadmapUpdateManyArgs>(args: SelectSubset<T, userroadmapUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Userroadmap.
     * @param {userroadmapUpsertArgs} args - Arguments to update or create a Userroadmap.
     * @example
     * // Update or create a Userroadmap
     * const userroadmap = await prisma.userroadmap.upsert({
     *   create: {
     *     // ... data to create a Userroadmap
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Userroadmap we want to update
     *   }
     * })
     */
    upsert<T extends userroadmapUpsertArgs>(args: SelectSubset<T, userroadmapUpsertArgs<ExtArgs>>): Prisma__userroadmapClient<$Result.GetResult<Prisma.$userroadmapPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Userroadmaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userroadmapCountArgs} args - Arguments to filter Userroadmaps to count.
     * @example
     * // Count the number of Userroadmaps
     * const count = await prisma.userroadmap.count({
     *   where: {
     *     // ... the filter for the Userroadmaps we want to count
     *   }
     * })
    **/
    count<T extends userroadmapCountArgs>(
      args?: Subset<T, userroadmapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserroadmapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Userroadmap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserroadmapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserroadmapAggregateArgs>(args: Subset<T, UserroadmapAggregateArgs>): Prisma.PrismaPromise<GetUserroadmapAggregateType<T>>

    /**
     * Group by Userroadmap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userroadmapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userroadmapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userroadmapGroupByArgs['orderBy'] }
        : { orderBy?: userroadmapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userroadmapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserroadmapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the userroadmap model
   */
  readonly fields: userroadmapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for userroadmap.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userroadmapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roadmap<T extends roadmapDefaultArgs<ExtArgs> = {}>(args?: Subset<T, roadmapDefaultArgs<ExtArgs>>): Prisma__roadmapClient<$Result.GetResult<Prisma.$roadmapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the userroadmap model
   */
  interface userroadmapFieldRefs {
    readonly id: FieldRef<"userroadmap", 'Int'>
    readonly userId: FieldRef<"userroadmap", 'Int'>
    readonly roadmapId: FieldRef<"userroadmap", 'Int'>
    readonly isUnlocked: FieldRef<"userroadmap", 'Boolean'>
    readonly unlockedAt: FieldRef<"userroadmap", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * userroadmap findUnique
   */
  export type userroadmapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userroadmap
     */
    select?: userroadmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userroadmap
     */
    omit?: userroadmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroadmapInclude<ExtArgs> | null
    /**
     * Filter, which userroadmap to fetch.
     */
    where: userroadmapWhereUniqueInput
  }

  /**
   * userroadmap findUniqueOrThrow
   */
  export type userroadmapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userroadmap
     */
    select?: userroadmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userroadmap
     */
    omit?: userroadmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroadmapInclude<ExtArgs> | null
    /**
     * Filter, which userroadmap to fetch.
     */
    where: userroadmapWhereUniqueInput
  }

  /**
   * userroadmap findFirst
   */
  export type userroadmapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userroadmap
     */
    select?: userroadmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userroadmap
     */
    omit?: userroadmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroadmapInclude<ExtArgs> | null
    /**
     * Filter, which userroadmap to fetch.
     */
    where?: userroadmapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userroadmaps to fetch.
     */
    orderBy?: userroadmapOrderByWithRelationInput | userroadmapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userroadmaps.
     */
    cursor?: userroadmapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userroadmaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userroadmaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userroadmaps.
     */
    distinct?: UserroadmapScalarFieldEnum | UserroadmapScalarFieldEnum[]
  }

  /**
   * userroadmap findFirstOrThrow
   */
  export type userroadmapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userroadmap
     */
    select?: userroadmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userroadmap
     */
    omit?: userroadmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroadmapInclude<ExtArgs> | null
    /**
     * Filter, which userroadmap to fetch.
     */
    where?: userroadmapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userroadmaps to fetch.
     */
    orderBy?: userroadmapOrderByWithRelationInput | userroadmapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userroadmaps.
     */
    cursor?: userroadmapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userroadmaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userroadmaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userroadmaps.
     */
    distinct?: UserroadmapScalarFieldEnum | UserroadmapScalarFieldEnum[]
  }

  /**
   * userroadmap findMany
   */
  export type userroadmapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userroadmap
     */
    select?: userroadmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userroadmap
     */
    omit?: userroadmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroadmapInclude<ExtArgs> | null
    /**
     * Filter, which userroadmaps to fetch.
     */
    where?: userroadmapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userroadmaps to fetch.
     */
    orderBy?: userroadmapOrderByWithRelationInput | userroadmapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing userroadmaps.
     */
    cursor?: userroadmapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userroadmaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userroadmaps.
     */
    skip?: number
    distinct?: UserroadmapScalarFieldEnum | UserroadmapScalarFieldEnum[]
  }

  /**
   * userroadmap create
   */
  export type userroadmapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userroadmap
     */
    select?: userroadmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userroadmap
     */
    omit?: userroadmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroadmapInclude<ExtArgs> | null
    /**
     * The data needed to create a userroadmap.
     */
    data: XOR<userroadmapCreateInput, userroadmapUncheckedCreateInput>
  }

  /**
   * userroadmap createMany
   */
  export type userroadmapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many userroadmaps.
     */
    data: userroadmapCreateManyInput | userroadmapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * userroadmap update
   */
  export type userroadmapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userroadmap
     */
    select?: userroadmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userroadmap
     */
    omit?: userroadmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroadmapInclude<ExtArgs> | null
    /**
     * The data needed to update a userroadmap.
     */
    data: XOR<userroadmapUpdateInput, userroadmapUncheckedUpdateInput>
    /**
     * Choose, which userroadmap to update.
     */
    where: userroadmapWhereUniqueInput
  }

  /**
   * userroadmap updateMany
   */
  export type userroadmapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update userroadmaps.
     */
    data: XOR<userroadmapUpdateManyMutationInput, userroadmapUncheckedUpdateManyInput>
    /**
     * Filter which userroadmaps to update
     */
    where?: userroadmapWhereInput
    /**
     * Limit how many userroadmaps to update.
     */
    limit?: number
  }

  /**
   * userroadmap upsert
   */
  export type userroadmapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userroadmap
     */
    select?: userroadmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userroadmap
     */
    omit?: userroadmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroadmapInclude<ExtArgs> | null
    /**
     * The filter to search for the userroadmap to update in case it exists.
     */
    where: userroadmapWhereUniqueInput
    /**
     * In case the userroadmap found by the `where` argument doesn't exist, create a new userroadmap with this data.
     */
    create: XOR<userroadmapCreateInput, userroadmapUncheckedCreateInput>
    /**
     * In case the userroadmap was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userroadmapUpdateInput, userroadmapUncheckedUpdateInput>
  }

  /**
   * userroadmap delete
   */
  export type userroadmapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userroadmap
     */
    select?: userroadmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userroadmap
     */
    omit?: userroadmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroadmapInclude<ExtArgs> | null
    /**
     * Filter which userroadmap to delete.
     */
    where: userroadmapWhereUniqueInput
  }

  /**
   * userroadmap deleteMany
   */
  export type userroadmapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userroadmaps to delete
     */
    where?: userroadmapWhereInput
    /**
     * Limit how many userroadmaps to delete.
     */
    limit?: number
  }

  /**
   * userroadmap without action
   */
  export type userroadmapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userroadmap
     */
    select?: userroadmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userroadmap
     */
    omit?: userroadmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroadmapInclude<ExtArgs> | null
  }


  /**
   * Model Voucher
   */

  export type AggregateVoucher = {
    _count: VoucherCountAggregateOutputType | null
    _avg: VoucherAvgAggregateOutputType | null
    _sum: VoucherSumAggregateOutputType | null
    _min: VoucherMinAggregateOutputType | null
    _max: VoucherMaxAggregateOutputType | null
  }

  export type VoucherAvgAggregateOutputType = {
    id: number | null
    discount: number | null
    userId: number | null
  }

  export type VoucherSumAggregateOutputType = {
    id: number | null
    discount: number | null
    userId: number | null
  }

  export type VoucherMinAggregateOutputType = {
    id: number | null
    code: string | null
    discount: number | null
    expiresAt: Date | null
    userId: number | null
    isUsed: boolean | null
  }

  export type VoucherMaxAggregateOutputType = {
    id: number | null
    code: string | null
    discount: number | null
    expiresAt: Date | null
    userId: number | null
    isUsed: boolean | null
  }

  export type VoucherCountAggregateOutputType = {
    id: number
    code: number
    discount: number
    expiresAt: number
    userId: number
    isUsed: number
    _all: number
  }


  export type VoucherAvgAggregateInputType = {
    id?: true
    discount?: true
    userId?: true
  }

  export type VoucherSumAggregateInputType = {
    id?: true
    discount?: true
    userId?: true
  }

  export type VoucherMinAggregateInputType = {
    id?: true
    code?: true
    discount?: true
    expiresAt?: true
    userId?: true
    isUsed?: true
  }

  export type VoucherMaxAggregateInputType = {
    id?: true
    code?: true
    discount?: true
    expiresAt?: true
    userId?: true
    isUsed?: true
  }

  export type VoucherCountAggregateInputType = {
    id?: true
    code?: true
    discount?: true
    expiresAt?: true
    userId?: true
    isUsed?: true
    _all?: true
  }

  export type VoucherAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Voucher to aggregate.
     */
    where?: VoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vouchers to fetch.
     */
    orderBy?: VoucherOrderByWithRelationInput | VoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vouchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vouchers
    **/
    _count?: true | VoucherCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VoucherAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VoucherSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VoucherMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VoucherMaxAggregateInputType
  }

  export type GetVoucherAggregateType<T extends VoucherAggregateArgs> = {
        [P in keyof T & keyof AggregateVoucher]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVoucher[P]>
      : GetScalarType<T[P], AggregateVoucher[P]>
  }




  export type VoucherGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoucherWhereInput
    orderBy?: VoucherOrderByWithAggregationInput | VoucherOrderByWithAggregationInput[]
    by: VoucherScalarFieldEnum[] | VoucherScalarFieldEnum
    having?: VoucherScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VoucherCountAggregateInputType | true
    _avg?: VoucherAvgAggregateInputType
    _sum?: VoucherSumAggregateInputType
    _min?: VoucherMinAggregateInputType
    _max?: VoucherMaxAggregateInputType
  }

  export type VoucherGroupByOutputType = {
    id: number
    code: string
    discount: number
    expiresAt: Date
    userId: number
    isUsed: boolean
    _count: VoucherCountAggregateOutputType | null
    _avg: VoucherAvgAggregateOutputType | null
    _sum: VoucherSumAggregateOutputType | null
    _min: VoucherMinAggregateOutputType | null
    _max: VoucherMaxAggregateOutputType | null
  }

  type GetVoucherGroupByPayload<T extends VoucherGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VoucherGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VoucherGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VoucherGroupByOutputType[P]>
            : GetScalarType<T[P], VoucherGroupByOutputType[P]>
        }
      >
    >


  export type VoucherSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    discount?: boolean
    expiresAt?: boolean
    userId?: boolean
    isUsed?: boolean
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["voucher"]>



  export type VoucherSelectScalar = {
    id?: boolean
    code?: boolean
    discount?: boolean
    expiresAt?: boolean
    userId?: boolean
    isUsed?: boolean
  }

  export type VoucherOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "discount" | "expiresAt" | "userId" | "isUsed", ExtArgs["result"]["voucher"]>
  export type VoucherInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $VoucherPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Voucher"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      discount: number
      expiresAt: Date
      userId: number
      isUsed: boolean
    }, ExtArgs["result"]["voucher"]>
    composites: {}
  }

  type VoucherGetPayload<S extends boolean | null | undefined | VoucherDefaultArgs> = $Result.GetResult<Prisma.$VoucherPayload, S>

  type VoucherCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VoucherFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VoucherCountAggregateInputType | true
    }

  export interface VoucherDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Voucher'], meta: { name: 'Voucher' } }
    /**
     * Find zero or one Voucher that matches the filter.
     * @param {VoucherFindUniqueArgs} args - Arguments to find a Voucher
     * @example
     * // Get one Voucher
     * const voucher = await prisma.voucher.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VoucherFindUniqueArgs>(args: SelectSubset<T, VoucherFindUniqueArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Voucher that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VoucherFindUniqueOrThrowArgs} args - Arguments to find a Voucher
     * @example
     * // Get one Voucher
     * const voucher = await prisma.voucher.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VoucherFindUniqueOrThrowArgs>(args: SelectSubset<T, VoucherFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Voucher that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherFindFirstArgs} args - Arguments to find a Voucher
     * @example
     * // Get one Voucher
     * const voucher = await prisma.voucher.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VoucherFindFirstArgs>(args?: SelectSubset<T, VoucherFindFirstArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Voucher that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherFindFirstOrThrowArgs} args - Arguments to find a Voucher
     * @example
     * // Get one Voucher
     * const voucher = await prisma.voucher.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VoucherFindFirstOrThrowArgs>(args?: SelectSubset<T, VoucherFindFirstOrThrowArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vouchers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vouchers
     * const vouchers = await prisma.voucher.findMany()
     * 
     * // Get first 10 Vouchers
     * const vouchers = await prisma.voucher.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const voucherWithIdOnly = await prisma.voucher.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VoucherFindManyArgs>(args?: SelectSubset<T, VoucherFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Voucher.
     * @param {VoucherCreateArgs} args - Arguments to create a Voucher.
     * @example
     * // Create one Voucher
     * const Voucher = await prisma.voucher.create({
     *   data: {
     *     // ... data to create a Voucher
     *   }
     * })
     * 
     */
    create<T extends VoucherCreateArgs>(args: SelectSubset<T, VoucherCreateArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vouchers.
     * @param {VoucherCreateManyArgs} args - Arguments to create many Vouchers.
     * @example
     * // Create many Vouchers
     * const voucher = await prisma.voucher.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VoucherCreateManyArgs>(args?: SelectSubset<T, VoucherCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Voucher.
     * @param {VoucherDeleteArgs} args - Arguments to delete one Voucher.
     * @example
     * // Delete one Voucher
     * const Voucher = await prisma.voucher.delete({
     *   where: {
     *     // ... filter to delete one Voucher
     *   }
     * })
     * 
     */
    delete<T extends VoucherDeleteArgs>(args: SelectSubset<T, VoucherDeleteArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Voucher.
     * @param {VoucherUpdateArgs} args - Arguments to update one Voucher.
     * @example
     * // Update one Voucher
     * const voucher = await prisma.voucher.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VoucherUpdateArgs>(args: SelectSubset<T, VoucherUpdateArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vouchers.
     * @param {VoucherDeleteManyArgs} args - Arguments to filter Vouchers to delete.
     * @example
     * // Delete a few Vouchers
     * const { count } = await prisma.voucher.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VoucherDeleteManyArgs>(args?: SelectSubset<T, VoucherDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vouchers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vouchers
     * const voucher = await prisma.voucher.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VoucherUpdateManyArgs>(args: SelectSubset<T, VoucherUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Voucher.
     * @param {VoucherUpsertArgs} args - Arguments to update or create a Voucher.
     * @example
     * // Update or create a Voucher
     * const voucher = await prisma.voucher.upsert({
     *   create: {
     *     // ... data to create a Voucher
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Voucher we want to update
     *   }
     * })
     */
    upsert<T extends VoucherUpsertArgs>(args: SelectSubset<T, VoucherUpsertArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Vouchers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherCountArgs} args - Arguments to filter Vouchers to count.
     * @example
     * // Count the number of Vouchers
     * const count = await prisma.voucher.count({
     *   where: {
     *     // ... the filter for the Vouchers we want to count
     *   }
     * })
    **/
    count<T extends VoucherCountArgs>(
      args?: Subset<T, VoucherCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VoucherCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Voucher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VoucherAggregateArgs>(args: Subset<T, VoucherAggregateArgs>): Prisma.PrismaPromise<GetVoucherAggregateType<T>>

    /**
     * Group by Voucher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VoucherGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VoucherGroupByArgs['orderBy'] }
        : { orderBy?: VoucherGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VoucherGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVoucherGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Voucher model
   */
  readonly fields: VoucherFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Voucher.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VoucherClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Voucher model
   */
  interface VoucherFieldRefs {
    readonly id: FieldRef<"Voucher", 'Int'>
    readonly code: FieldRef<"Voucher", 'String'>
    readonly discount: FieldRef<"Voucher", 'Int'>
    readonly expiresAt: FieldRef<"Voucher", 'DateTime'>
    readonly userId: FieldRef<"Voucher", 'Int'>
    readonly isUsed: FieldRef<"Voucher", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Voucher findUnique
   */
  export type VoucherFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter, which Voucher to fetch.
     */
    where: VoucherWhereUniqueInput
  }

  /**
   * Voucher findUniqueOrThrow
   */
  export type VoucherFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter, which Voucher to fetch.
     */
    where: VoucherWhereUniqueInput
  }

  /**
   * Voucher findFirst
   */
  export type VoucherFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter, which Voucher to fetch.
     */
    where?: VoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vouchers to fetch.
     */
    orderBy?: VoucherOrderByWithRelationInput | VoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vouchers.
     */
    cursor?: VoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vouchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vouchers.
     */
    distinct?: VoucherScalarFieldEnum | VoucherScalarFieldEnum[]
  }

  /**
   * Voucher findFirstOrThrow
   */
  export type VoucherFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter, which Voucher to fetch.
     */
    where?: VoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vouchers to fetch.
     */
    orderBy?: VoucherOrderByWithRelationInput | VoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vouchers.
     */
    cursor?: VoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vouchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vouchers.
     */
    distinct?: VoucherScalarFieldEnum | VoucherScalarFieldEnum[]
  }

  /**
   * Voucher findMany
   */
  export type VoucherFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter, which Vouchers to fetch.
     */
    where?: VoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vouchers to fetch.
     */
    orderBy?: VoucherOrderByWithRelationInput | VoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vouchers.
     */
    cursor?: VoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vouchers.
     */
    skip?: number
    distinct?: VoucherScalarFieldEnum | VoucherScalarFieldEnum[]
  }

  /**
   * Voucher create
   */
  export type VoucherCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * The data needed to create a Voucher.
     */
    data: XOR<VoucherCreateInput, VoucherUncheckedCreateInput>
  }

  /**
   * Voucher createMany
   */
  export type VoucherCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vouchers.
     */
    data: VoucherCreateManyInput | VoucherCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Voucher update
   */
  export type VoucherUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * The data needed to update a Voucher.
     */
    data: XOR<VoucherUpdateInput, VoucherUncheckedUpdateInput>
    /**
     * Choose, which Voucher to update.
     */
    where: VoucherWhereUniqueInput
  }

  /**
   * Voucher updateMany
   */
  export type VoucherUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vouchers.
     */
    data: XOR<VoucherUpdateManyMutationInput, VoucherUncheckedUpdateManyInput>
    /**
     * Filter which Vouchers to update
     */
    where?: VoucherWhereInput
    /**
     * Limit how many Vouchers to update.
     */
    limit?: number
  }

  /**
   * Voucher upsert
   */
  export type VoucherUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * The filter to search for the Voucher to update in case it exists.
     */
    where: VoucherWhereUniqueInput
    /**
     * In case the Voucher found by the `where` argument doesn't exist, create a new Voucher with this data.
     */
    create: XOR<VoucherCreateInput, VoucherUncheckedCreateInput>
    /**
     * In case the Voucher was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VoucherUpdateInput, VoucherUncheckedUpdateInput>
  }

  /**
   * Voucher delete
   */
  export type VoucherDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter which Voucher to delete.
     */
    where: VoucherWhereUniqueInput
  }

  /**
   * Voucher deleteMany
   */
  export type VoucherDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vouchers to delete
     */
    where?: VoucherWhereInput
    /**
     * Limit how many Vouchers to delete.
     */
    limit?: number
  }

  /**
   * Voucher without action
   */
  export type VoucherDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    password: 'password',
    address: 'address',
    gender: 'gender',
    birthDate: 'birthDate',
    role: 'role',
    profilePicture: 'profilePicture',
    createdAt: 'createdAt',
    resetToken: 'resetToken',
    resetTokenExpiry: 'resetTokenExpiry'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RoadmapMatcherScalarFieldEnum: {
    id: 'id',
    keyword: 'keyword',
    roadmapId: 'roadmapId',
    matchField: 'matchField'
  };

  export type RoadmapMatcherScalarFieldEnum = (typeof RoadmapMatcherScalarFieldEnum)[keyof typeof RoadmapMatcherScalarFieldEnum]


  export const AssessmentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    studentStatus: 'studentStatus',
    majorStudy: 'majorStudy',
    currentSemester: 'currentSemester',
    createdAt: 'createdAt',
    currentField: 'currentField',
    dreamJob: 'dreamJob',
    interestedField: 'interestedField',
    mainGoal: 'mainGoal'
  };

  export type AssessmentScalarFieldEnum = (typeof AssessmentScalarFieldEnum)[keyof typeof AssessmentScalarFieldEnum]


  export const BookmarkCourseScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    courseId: 'courseId',
    createdAt: 'createdAt'
  };

  export type BookmarkCourseScalarFieldEnum = (typeof BookmarkCourseScalarFieldEnum)[keyof typeof BookmarkCourseScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const CertificateScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    courseId: 'courseId',
    filePath: 'filePath',
    issuedAt: 'issuedAt'
  };

  export type CertificateScalarFieldEnum = (typeof CertificateScalarFieldEnum)[keyof typeof CertificateScalarFieldEnum]


  export const ChatmessageScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    senderId: 'senderId',
    message: 'message',
    sentAt: 'sentAt'
  };

  export type ChatmessageScalarFieldEnum = (typeof ChatmessageScalarFieldEnum)[keyof typeof ChatmessageScalarFieldEnum]


  export const CounselingsessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    counselorId: 'counselorId',
    topic: 'topic',
    question: 'question',
    response: 'response',
    status: 'status',
    createdAt: 'createdAt',
    rating: 'rating',
    feedback: 'feedback'
  };

  export type CounselingsessionScalarFieldEnum = (typeof CounselingsessionScalarFieldEnum)[keyof typeof CounselingsessionScalarFieldEnum]


  export const CounselorScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    specialization: 'specialization',
    bio: 'bio',
    verified: 'verified'
  };

  export type CounselorScalarFieldEnum = (typeof CounselorScalarFieldEnum)[keyof typeof CounselorScalarFieldEnum]


  export const CourseScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    thumbnail: 'thumbnail',
    categoryId: 'categoryId',
    isPaid: 'isPaid',
    price: 'price',
    createdById: 'createdById',
    createdAt: 'createdAt'
  };

  export type CourseScalarFieldEnum = (typeof CourseScalarFieldEnum)[keyof typeof CourseScalarFieldEnum]


  export const CourseprogressScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    courseId: 'courseId',
    completedVideoCount: 'completedVideoCount',
    completedQuizCount: 'completedQuizCount',
    isCompleted: 'isCompleted'
  };

  export type CourseprogressScalarFieldEnum = (typeof CourseprogressScalarFieldEnum)[keyof typeof CourseprogressScalarFieldEnum]


  export const CoursevideoScalarFieldEnum: {
    id: 'id',
    courseId: 'courseId',
    title: 'title',
    videoUrl: 'videoUrl',
    isLocked: 'isLocked',
    order: 'order',
    s3Key: 's3Key'
  };

  export type CoursevideoScalarFieldEnum = (typeof CoursevideoScalarFieldEnum)[keyof typeof CoursevideoScalarFieldEnum]


  export const CvreviewScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    cvFilePath: 'cvFilePath',
    cvVersion: 'cvVersion',
    reviewResult: 'reviewResult',
    relevanceScore: 'relevanceScore',
    feedback: 'feedback',
    createdAt: 'createdAt'
  };

  export type CvreviewScalarFieldEnum = (typeof CvreviewScalarFieldEnum)[keyof typeof CvreviewScalarFieldEnum]


  export const EnrollmentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    courseId: 'courseId',
    enrolledAt: 'enrolledAt',
    isPaid: 'isPaid',
    paymentId: 'paymentId'
  };

  export type EnrollmentScalarFieldEnum = (typeof EnrollmentScalarFieldEnum)[keyof typeof EnrollmentScalarFieldEnum]


  export const JobmatchScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    cvFilePath: 'cvFilePath',
    matchedJobs: 'matchedJobs',
    generatedAt: 'generatedAt'
  };

  export type JobmatchScalarFieldEnum = (typeof JobmatchScalarFieldEnum)[keyof typeof JobmatchScalarFieldEnum]


  export const LessonScalarFieldEnum: {
    id: 'id',
    title: 'title',
    courseId: 'courseId',
    content: 'content',
    order: 'order'
  };

  export type LessonScalarFieldEnum = (typeof LessonScalarFieldEnum)[keyof typeof LessonScalarFieldEnum]


  export const LessonprogressScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    lessonId: 'lessonId',
    isCompleted: 'isCompleted',
    updatedAt: 'updatedAt'
  };

  export type LessonprogressScalarFieldEnum = (typeof LessonprogressScalarFieldEnum)[keyof typeof LessonprogressScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    message: 'message',
    isRead: 'isRead',
    createdAt: 'createdAt',
    type: 'type'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    courseId: 'courseId',
    roadmapId: 'roadmapId',
    amount: 'amount',
    paymentStatus: 'paymentStatus',
    status: 'status',
    paidAt: 'paidAt',
    createdAt: 'createdAt',
    orderId: 'orderId',
    snapToken: 'snapToken'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const QuizScalarFieldEnum: {
    id: 'id',
    courseId: 'courseId',
    question: 'question',
    options: 'options',
    correctAnswer: 'correctAnswer',
    isLocked: 'isLocked'
  };

  export type QuizScalarFieldEnum = (typeof QuizScalarFieldEnum)[keyof typeof QuizScalarFieldEnum]


  export const QuizsubmissionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    courseId: 'courseId',
    quizId: 'quizId',
    answers: 'answers',
    score: 'score',
    totalQuestions: 'totalQuestions',
    isPassed: 'isPassed',
    createdAt: 'createdAt'
  };

  export type QuizsubmissionScalarFieldEnum = (typeof QuizsubmissionScalarFieldEnum)[keyof typeof QuizsubmissionScalarFieldEnum]


  export const RoadmapScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    rewardVoucher: 'rewardVoucher'
  };

  export type RoadmapScalarFieldEnum = (typeof RoadmapScalarFieldEnum)[keyof typeof RoadmapScalarFieldEnum]


  export const RoadmapcourseScalarFieldEnum: {
    id: 'id',
    roadmapId: 'roadmapId',
    courseId: 'courseId',
    order: 'order'
  };

  export type RoadmapcourseScalarFieldEnum = (typeof RoadmapcourseScalarFieldEnum)[keyof typeof RoadmapcourseScalarFieldEnum]


  export const UserroadmapScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    roadmapId: 'roadmapId',
    isUnlocked: 'isUnlocked',
    unlockedAt: 'unlockedAt'
  };

  export type UserroadmapScalarFieldEnum = (typeof UserroadmapScalarFieldEnum)[keyof typeof UserroadmapScalarFieldEnum]


  export const VoucherScalarFieldEnum: {
    id: 'id',
    code: 'code',
    discount: 'discount',
    expiresAt: 'expiresAt',
    userId: 'userId',
    isUsed: 'isUsed'
  };

  export type VoucherScalarFieldEnum = (typeof VoucherScalarFieldEnum)[keyof typeof VoucherScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const UserOrderByRelevanceFieldEnum: {
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    password: 'password',
    address: 'address',
    gender: 'gender',
    profilePicture: 'profilePicture',
    resetToken: 'resetToken'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const RoadmapMatcherOrderByRelevanceFieldEnum: {
    keyword: 'keyword',
    matchField: 'matchField'
  };

  export type RoadmapMatcherOrderByRelevanceFieldEnum = (typeof RoadmapMatcherOrderByRelevanceFieldEnum)[keyof typeof RoadmapMatcherOrderByRelevanceFieldEnum]


  export const assessmentOrderByRelevanceFieldEnum: {
    studentStatus: 'studentStatus',
    majorStudy: 'majorStudy',
    currentSemester: 'currentSemester',
    currentField: 'currentField',
    dreamJob: 'dreamJob',
    interestedField: 'interestedField',
    mainGoal: 'mainGoal'
  };

  export type assessmentOrderByRelevanceFieldEnum = (typeof assessmentOrderByRelevanceFieldEnum)[keyof typeof assessmentOrderByRelevanceFieldEnum]


  export const categoryOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type categoryOrderByRelevanceFieldEnum = (typeof categoryOrderByRelevanceFieldEnum)[keyof typeof categoryOrderByRelevanceFieldEnum]


  export const certificateOrderByRelevanceFieldEnum: {
    filePath: 'filePath'
  };

  export type certificateOrderByRelevanceFieldEnum = (typeof certificateOrderByRelevanceFieldEnum)[keyof typeof certificateOrderByRelevanceFieldEnum]


  export const chatmessageOrderByRelevanceFieldEnum: {
    message: 'message'
  };

  export type chatmessageOrderByRelevanceFieldEnum = (typeof chatmessageOrderByRelevanceFieldEnum)[keyof typeof chatmessageOrderByRelevanceFieldEnum]


  export const counselingsessionOrderByRelevanceFieldEnum: {
    topic: 'topic',
    question: 'question',
    response: 'response',
    status: 'status',
    feedback: 'feedback'
  };

  export type counselingsessionOrderByRelevanceFieldEnum = (typeof counselingsessionOrderByRelevanceFieldEnum)[keyof typeof counselingsessionOrderByRelevanceFieldEnum]


  export const counselorOrderByRelevanceFieldEnum: {
    specialization: 'specialization',
    bio: 'bio'
  };

  export type counselorOrderByRelevanceFieldEnum = (typeof counselorOrderByRelevanceFieldEnum)[keyof typeof counselorOrderByRelevanceFieldEnum]


  export const courseOrderByRelevanceFieldEnum: {
    title: 'title',
    description: 'description',
    thumbnail: 'thumbnail'
  };

  export type courseOrderByRelevanceFieldEnum = (typeof courseOrderByRelevanceFieldEnum)[keyof typeof courseOrderByRelevanceFieldEnum]


  export const coursevideoOrderByRelevanceFieldEnum: {
    title: 'title',
    videoUrl: 'videoUrl',
    s3Key: 's3Key'
  };

  export type coursevideoOrderByRelevanceFieldEnum = (typeof coursevideoOrderByRelevanceFieldEnum)[keyof typeof coursevideoOrderByRelevanceFieldEnum]


  export const cvreviewOrderByRelevanceFieldEnum: {
    cvFilePath: 'cvFilePath',
    reviewResult: 'reviewResult',
    feedback: 'feedback'
  };

  export type cvreviewOrderByRelevanceFieldEnum = (typeof cvreviewOrderByRelevanceFieldEnum)[keyof typeof cvreviewOrderByRelevanceFieldEnum]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const jobmatchOrderByRelevanceFieldEnum: {
    cvFilePath: 'cvFilePath'
  };

  export type jobmatchOrderByRelevanceFieldEnum = (typeof jobmatchOrderByRelevanceFieldEnum)[keyof typeof jobmatchOrderByRelevanceFieldEnum]


  export const lessonOrderByRelevanceFieldEnum: {
    title: 'title',
    content: 'content'
  };

  export type lessonOrderByRelevanceFieldEnum = (typeof lessonOrderByRelevanceFieldEnum)[keyof typeof lessonOrderByRelevanceFieldEnum]


  export const notificationOrderByRelevanceFieldEnum: {
    message: 'message',
    type: 'type'
  };

  export type notificationOrderByRelevanceFieldEnum = (typeof notificationOrderByRelevanceFieldEnum)[keyof typeof notificationOrderByRelevanceFieldEnum]


  export const paymentOrderByRelevanceFieldEnum: {
    paymentStatus: 'paymentStatus',
    status: 'status',
    orderId: 'orderId',
    snapToken: 'snapToken'
  };

  export type paymentOrderByRelevanceFieldEnum = (typeof paymentOrderByRelevanceFieldEnum)[keyof typeof paymentOrderByRelevanceFieldEnum]


  export const quizOrderByRelevanceFieldEnum: {
    question: 'question',
    correctAnswer: 'correctAnswer'
  };

  export type quizOrderByRelevanceFieldEnum = (typeof quizOrderByRelevanceFieldEnum)[keyof typeof quizOrderByRelevanceFieldEnum]


  export const roadmapOrderByRelevanceFieldEnum: {
    name: 'name',
    description: 'description',
    rewardVoucher: 'rewardVoucher'
  };

  export type roadmapOrderByRelevanceFieldEnum = (typeof roadmapOrderByRelevanceFieldEnum)[keyof typeof roadmapOrderByRelevanceFieldEnum]


  export const VoucherOrderByRelevanceFieldEnum: {
    code: 'code'
  };

  export type VoucherOrderByRelevanceFieldEnum = (typeof VoucherOrderByRelevanceFieldEnum)[keyof typeof VoucherOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    address?: StringNullableFilter<"User"> | string | null
    gender?: StringNullableFilter<"User"> | string | null
    birthDate?: DateTimeNullableFilter<"User"> | Date | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    profilePicture?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    resetToken?: StringNullableFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    assessment?: AssessmentListRelationFilter
    certificate?: CertificateListRelationFilter
    chatmessage?: ChatmessageListRelationFilter
    counselingsession?: CounselingsessionListRelationFilter
    counselor?: XOR<CounselorNullableScalarRelationFilter, counselorWhereInput> | null
    course?: CourseListRelationFilter
    courseprogress?: CourseprogressListRelationFilter
    cvreview?: CvreviewListRelationFilter
    enrollment?: EnrollmentListRelationFilter
    jobmatch?: JobmatchListRelationFilter
    lessonprogress?: LessonprogressListRelationFilter
    notification?: NotificationListRelationFilter
    payment?: PaymentListRelationFilter
    quizsubmission?: QuizsubmissionListRelationFilter
    userroadmap?: UserroadmapListRelationFilter
    voucher?: VoucherListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    email?: SortOrder
    password?: SortOrder
    address?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    role?: SortOrder
    profilePicture?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpiry?: SortOrderInput | SortOrder
    assessment?: assessmentOrderByRelationAggregateInput
    certificate?: certificateOrderByRelationAggregateInput
    chatmessage?: chatmessageOrderByRelationAggregateInput
    counselingsession?: counselingsessionOrderByRelationAggregateInput
    counselor?: counselorOrderByWithRelationInput
    course?: courseOrderByRelationAggregateInput
    courseprogress?: courseprogressOrderByRelationAggregateInput
    cvreview?: cvreviewOrderByRelationAggregateInput
    enrollment?: enrollmentOrderByRelationAggregateInput
    jobmatch?: jobmatchOrderByRelationAggregateInput
    lessonprogress?: lessonprogressOrderByRelationAggregateInput
    notification?: notificationOrderByRelationAggregateInput
    payment?: paymentOrderByRelationAggregateInput
    quizsubmission?: quizsubmissionOrderByRelationAggregateInput
    userroadmap?: userroadmapOrderByRelationAggregateInput
    voucher?: VoucherOrderByRelationAggregateInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    address?: StringNullableFilter<"User"> | string | null
    gender?: StringNullableFilter<"User"> | string | null
    birthDate?: DateTimeNullableFilter<"User"> | Date | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    profilePicture?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    resetToken?: StringNullableFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    assessment?: AssessmentListRelationFilter
    certificate?: CertificateListRelationFilter
    chatmessage?: ChatmessageListRelationFilter
    counselingsession?: CounselingsessionListRelationFilter
    counselor?: XOR<CounselorNullableScalarRelationFilter, counselorWhereInput> | null
    course?: CourseListRelationFilter
    courseprogress?: CourseprogressListRelationFilter
    cvreview?: CvreviewListRelationFilter
    enrollment?: EnrollmentListRelationFilter
    jobmatch?: JobmatchListRelationFilter
    lessonprogress?: LessonprogressListRelationFilter
    notification?: NotificationListRelationFilter
    payment?: PaymentListRelationFilter
    quizsubmission?: QuizsubmissionListRelationFilter
    userroadmap?: UserroadmapListRelationFilter
    voucher?: VoucherListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    email?: SortOrder
    password?: SortOrder
    address?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    role?: SortOrder
    profilePicture?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpiry?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    firstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    address?: StringNullableWithAggregatesFilter<"User"> | string | null
    gender?: StringNullableWithAggregatesFilter<"User"> | string | null
    birthDate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    profilePicture?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    resetToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type RoadmapMatcherWhereInput = {
    AND?: RoadmapMatcherWhereInput | RoadmapMatcherWhereInput[]
    OR?: RoadmapMatcherWhereInput[]
    NOT?: RoadmapMatcherWhereInput | RoadmapMatcherWhereInput[]
    id?: IntFilter<"RoadmapMatcher"> | number
    keyword?: StringFilter<"RoadmapMatcher"> | string
    roadmapId?: IntFilter<"RoadmapMatcher"> | number
    matchField?: StringFilter<"RoadmapMatcher"> | string
  }

  export type RoadmapMatcherOrderByWithRelationInput = {
    id?: SortOrder
    keyword?: SortOrder
    roadmapId?: SortOrder
    matchField?: SortOrder
    _relevance?: RoadmapMatcherOrderByRelevanceInput
  }

  export type RoadmapMatcherWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RoadmapMatcherWhereInput | RoadmapMatcherWhereInput[]
    OR?: RoadmapMatcherWhereInput[]
    NOT?: RoadmapMatcherWhereInput | RoadmapMatcherWhereInput[]
    keyword?: StringFilter<"RoadmapMatcher"> | string
    roadmapId?: IntFilter<"RoadmapMatcher"> | number
    matchField?: StringFilter<"RoadmapMatcher"> | string
  }, "id">

  export type RoadmapMatcherOrderByWithAggregationInput = {
    id?: SortOrder
    keyword?: SortOrder
    roadmapId?: SortOrder
    matchField?: SortOrder
    _count?: RoadmapMatcherCountOrderByAggregateInput
    _avg?: RoadmapMatcherAvgOrderByAggregateInput
    _max?: RoadmapMatcherMaxOrderByAggregateInput
    _min?: RoadmapMatcherMinOrderByAggregateInput
    _sum?: RoadmapMatcherSumOrderByAggregateInput
  }

  export type RoadmapMatcherScalarWhereWithAggregatesInput = {
    AND?: RoadmapMatcherScalarWhereWithAggregatesInput | RoadmapMatcherScalarWhereWithAggregatesInput[]
    OR?: RoadmapMatcherScalarWhereWithAggregatesInput[]
    NOT?: RoadmapMatcherScalarWhereWithAggregatesInput | RoadmapMatcherScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RoadmapMatcher"> | number
    keyword?: StringWithAggregatesFilter<"RoadmapMatcher"> | string
    roadmapId?: IntWithAggregatesFilter<"RoadmapMatcher"> | number
    matchField?: StringWithAggregatesFilter<"RoadmapMatcher"> | string
  }

  export type assessmentWhereInput = {
    AND?: assessmentWhereInput | assessmentWhereInput[]
    OR?: assessmentWhereInput[]
    NOT?: assessmentWhereInput | assessmentWhereInput[]
    id?: IntFilter<"assessment"> | number
    userId?: IntFilter<"assessment"> | number
    studentStatus?: StringFilter<"assessment"> | string
    majorStudy?: StringFilter<"assessment"> | string
    currentSemester?: StringFilter<"assessment"> | string
    createdAt?: DateTimeFilter<"assessment"> | Date | string
    currentField?: StringFilter<"assessment"> | string
    dreamJob?: StringFilter<"assessment"> | string
    interestedField?: StringFilter<"assessment"> | string
    mainGoal?: StringFilter<"assessment"> | string
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type assessmentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    studentStatus?: SortOrder
    majorStudy?: SortOrder
    currentSemester?: SortOrder
    createdAt?: SortOrder
    currentField?: SortOrder
    dreamJob?: SortOrder
    interestedField?: SortOrder
    mainGoal?: SortOrder
    users?: UserOrderByWithRelationInput
    _relevance?: assessmentOrderByRelevanceInput
  }

  export type assessmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: assessmentWhereInput | assessmentWhereInput[]
    OR?: assessmentWhereInput[]
    NOT?: assessmentWhereInput | assessmentWhereInput[]
    userId?: IntFilter<"assessment"> | number
    studentStatus?: StringFilter<"assessment"> | string
    majorStudy?: StringFilter<"assessment"> | string
    currentSemester?: StringFilter<"assessment"> | string
    createdAt?: DateTimeFilter<"assessment"> | Date | string
    currentField?: StringFilter<"assessment"> | string
    dreamJob?: StringFilter<"assessment"> | string
    interestedField?: StringFilter<"assessment"> | string
    mainGoal?: StringFilter<"assessment"> | string
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type assessmentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    studentStatus?: SortOrder
    majorStudy?: SortOrder
    currentSemester?: SortOrder
    createdAt?: SortOrder
    currentField?: SortOrder
    dreamJob?: SortOrder
    interestedField?: SortOrder
    mainGoal?: SortOrder
    _count?: assessmentCountOrderByAggregateInput
    _avg?: assessmentAvgOrderByAggregateInput
    _max?: assessmentMaxOrderByAggregateInput
    _min?: assessmentMinOrderByAggregateInput
    _sum?: assessmentSumOrderByAggregateInput
  }

  export type assessmentScalarWhereWithAggregatesInput = {
    AND?: assessmentScalarWhereWithAggregatesInput | assessmentScalarWhereWithAggregatesInput[]
    OR?: assessmentScalarWhereWithAggregatesInput[]
    NOT?: assessmentScalarWhereWithAggregatesInput | assessmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"assessment"> | number
    userId?: IntWithAggregatesFilter<"assessment"> | number
    studentStatus?: StringWithAggregatesFilter<"assessment"> | string
    majorStudy?: StringWithAggregatesFilter<"assessment"> | string
    currentSemester?: StringWithAggregatesFilter<"assessment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"assessment"> | Date | string
    currentField?: StringWithAggregatesFilter<"assessment"> | string
    dreamJob?: StringWithAggregatesFilter<"assessment"> | string
    interestedField?: StringWithAggregatesFilter<"assessment"> | string
    mainGoal?: StringWithAggregatesFilter<"assessment"> | string
  }

  export type BookmarkCourseWhereInput = {
    AND?: BookmarkCourseWhereInput | BookmarkCourseWhereInput[]
    OR?: BookmarkCourseWhereInput[]
    NOT?: BookmarkCourseWhereInput | BookmarkCourseWhereInput[]
    id?: IntFilter<"BookmarkCourse"> | number
    userId?: IntFilter<"BookmarkCourse"> | number
    courseId?: IntFilter<"BookmarkCourse"> | number
    createdAt?: DateTimeFilter<"BookmarkCourse"> | Date | string
  }

  export type BookmarkCourseOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    createdAt?: SortOrder
  }

  export type BookmarkCourseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_courseId?: BookmarkCourseUserIdCourseIdCompoundUniqueInput
    AND?: BookmarkCourseWhereInput | BookmarkCourseWhereInput[]
    OR?: BookmarkCourseWhereInput[]
    NOT?: BookmarkCourseWhereInput | BookmarkCourseWhereInput[]
    userId?: IntFilter<"BookmarkCourse"> | number
    courseId?: IntFilter<"BookmarkCourse"> | number
    createdAt?: DateTimeFilter<"BookmarkCourse"> | Date | string
  }, "id" | "userId_courseId">

  export type BookmarkCourseOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    createdAt?: SortOrder
    _count?: BookmarkCourseCountOrderByAggregateInput
    _avg?: BookmarkCourseAvgOrderByAggregateInput
    _max?: BookmarkCourseMaxOrderByAggregateInput
    _min?: BookmarkCourseMinOrderByAggregateInput
    _sum?: BookmarkCourseSumOrderByAggregateInput
  }

  export type BookmarkCourseScalarWhereWithAggregatesInput = {
    AND?: BookmarkCourseScalarWhereWithAggregatesInput | BookmarkCourseScalarWhereWithAggregatesInput[]
    OR?: BookmarkCourseScalarWhereWithAggregatesInput[]
    NOT?: BookmarkCourseScalarWhereWithAggregatesInput | BookmarkCourseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BookmarkCourse"> | number
    userId?: IntWithAggregatesFilter<"BookmarkCourse"> | number
    courseId?: IntWithAggregatesFilter<"BookmarkCourse"> | number
    createdAt?: DateTimeWithAggregatesFilter<"BookmarkCourse"> | Date | string
  }

  export type categoryWhereInput = {
    AND?: categoryWhereInput | categoryWhereInput[]
    OR?: categoryWhereInput[]
    NOT?: categoryWhereInput | categoryWhereInput[]
    id?: IntFilter<"category"> | number
    name?: StringFilter<"category"> | string
    course?: CourseListRelationFilter
  }

  export type categoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    course?: courseOrderByRelationAggregateInput
    _relevance?: categoryOrderByRelevanceInput
  }

  export type categoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: categoryWhereInput | categoryWhereInput[]
    OR?: categoryWhereInput[]
    NOT?: categoryWhereInput | categoryWhereInput[]
    course?: CourseListRelationFilter
  }, "id" | "name">

  export type categoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: categoryCountOrderByAggregateInput
    _avg?: categoryAvgOrderByAggregateInput
    _max?: categoryMaxOrderByAggregateInput
    _min?: categoryMinOrderByAggregateInput
    _sum?: categorySumOrderByAggregateInput
  }

  export type categoryScalarWhereWithAggregatesInput = {
    AND?: categoryScalarWhereWithAggregatesInput | categoryScalarWhereWithAggregatesInput[]
    OR?: categoryScalarWhereWithAggregatesInput[]
    NOT?: categoryScalarWhereWithAggregatesInput | categoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"category"> | number
    name?: StringWithAggregatesFilter<"category"> | string
  }

  export type certificateWhereInput = {
    AND?: certificateWhereInput | certificateWhereInput[]
    OR?: certificateWhereInput[]
    NOT?: certificateWhereInput | certificateWhereInput[]
    id?: IntFilter<"certificate"> | number
    userId?: IntFilter<"certificate"> | number
    courseId?: IntFilter<"certificate"> | number
    filePath?: StringFilter<"certificate"> | string
    issuedAt?: DateTimeFilter<"certificate"> | Date | string
    course?: XOR<CourseScalarRelationFilter, courseWhereInput>
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type certificateOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    filePath?: SortOrder
    issuedAt?: SortOrder
    course?: courseOrderByWithRelationInput
    users?: UserOrderByWithRelationInput
    _relevance?: certificateOrderByRelevanceInput
  }

  export type certificateWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: certificateWhereInput | certificateWhereInput[]
    OR?: certificateWhereInput[]
    NOT?: certificateWhereInput | certificateWhereInput[]
    userId?: IntFilter<"certificate"> | number
    courseId?: IntFilter<"certificate"> | number
    filePath?: StringFilter<"certificate"> | string
    issuedAt?: DateTimeFilter<"certificate"> | Date | string
    course?: XOR<CourseScalarRelationFilter, courseWhereInput>
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type certificateOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    filePath?: SortOrder
    issuedAt?: SortOrder
    _count?: certificateCountOrderByAggregateInput
    _avg?: certificateAvgOrderByAggregateInput
    _max?: certificateMaxOrderByAggregateInput
    _min?: certificateMinOrderByAggregateInput
    _sum?: certificateSumOrderByAggregateInput
  }

  export type certificateScalarWhereWithAggregatesInput = {
    AND?: certificateScalarWhereWithAggregatesInput | certificateScalarWhereWithAggregatesInput[]
    OR?: certificateScalarWhereWithAggregatesInput[]
    NOT?: certificateScalarWhereWithAggregatesInput | certificateScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"certificate"> | number
    userId?: IntWithAggregatesFilter<"certificate"> | number
    courseId?: IntWithAggregatesFilter<"certificate"> | number
    filePath?: StringWithAggregatesFilter<"certificate"> | string
    issuedAt?: DateTimeWithAggregatesFilter<"certificate"> | Date | string
  }

  export type chatmessageWhereInput = {
    AND?: chatmessageWhereInput | chatmessageWhereInput[]
    OR?: chatmessageWhereInput[]
    NOT?: chatmessageWhereInput | chatmessageWhereInput[]
    id?: IntFilter<"chatmessage"> | number
    sessionId?: IntFilter<"chatmessage"> | number
    senderId?: IntFilter<"chatmessage"> | number
    message?: StringFilter<"chatmessage"> | string
    sentAt?: DateTimeFilter<"chatmessage"> | Date | string
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
    counselingsession?: XOR<CounselingsessionScalarRelationFilter, counselingsessionWhereInput>
  }

  export type chatmessageOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    senderId?: SortOrder
    message?: SortOrder
    sentAt?: SortOrder
    users?: UserOrderByWithRelationInput
    counselingsession?: counselingsessionOrderByWithRelationInput
    _relevance?: chatmessageOrderByRelevanceInput
  }

  export type chatmessageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: chatmessageWhereInput | chatmessageWhereInput[]
    OR?: chatmessageWhereInput[]
    NOT?: chatmessageWhereInput | chatmessageWhereInput[]
    sessionId?: IntFilter<"chatmessage"> | number
    senderId?: IntFilter<"chatmessage"> | number
    message?: StringFilter<"chatmessage"> | string
    sentAt?: DateTimeFilter<"chatmessage"> | Date | string
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
    counselingsession?: XOR<CounselingsessionScalarRelationFilter, counselingsessionWhereInput>
  }, "id">

  export type chatmessageOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    senderId?: SortOrder
    message?: SortOrder
    sentAt?: SortOrder
    _count?: chatmessageCountOrderByAggregateInput
    _avg?: chatmessageAvgOrderByAggregateInput
    _max?: chatmessageMaxOrderByAggregateInput
    _min?: chatmessageMinOrderByAggregateInput
    _sum?: chatmessageSumOrderByAggregateInput
  }

  export type chatmessageScalarWhereWithAggregatesInput = {
    AND?: chatmessageScalarWhereWithAggregatesInput | chatmessageScalarWhereWithAggregatesInput[]
    OR?: chatmessageScalarWhereWithAggregatesInput[]
    NOT?: chatmessageScalarWhereWithAggregatesInput | chatmessageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"chatmessage"> | number
    sessionId?: IntWithAggregatesFilter<"chatmessage"> | number
    senderId?: IntWithAggregatesFilter<"chatmessage"> | number
    message?: StringWithAggregatesFilter<"chatmessage"> | string
    sentAt?: DateTimeWithAggregatesFilter<"chatmessage"> | Date | string
  }

  export type counselingsessionWhereInput = {
    AND?: counselingsessionWhereInput | counselingsessionWhereInput[]
    OR?: counselingsessionWhereInput[]
    NOT?: counselingsessionWhereInput | counselingsessionWhereInput[]
    id?: IntFilter<"counselingsession"> | number
    userId?: IntFilter<"counselingsession"> | number
    counselorId?: IntFilter<"counselingsession"> | number
    topic?: StringFilter<"counselingsession"> | string
    question?: StringFilter<"counselingsession"> | string
    response?: StringNullableFilter<"counselingsession"> | string | null
    status?: StringFilter<"counselingsession"> | string
    createdAt?: DateTimeFilter<"counselingsession"> | Date | string
    rating?: IntNullableFilter<"counselingsession"> | number | null
    feedback?: StringNullableFilter<"counselingsession"> | string | null
    chatmessage?: ChatmessageListRelationFilter
    counselor?: XOR<CounselorScalarRelationFilter, counselorWhereInput>
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type counselingsessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    counselorId?: SortOrder
    topic?: SortOrder
    question?: SortOrder
    response?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    rating?: SortOrderInput | SortOrder
    feedback?: SortOrderInput | SortOrder
    chatmessage?: chatmessageOrderByRelationAggregateInput
    counselor?: counselorOrderByWithRelationInput
    users?: UserOrderByWithRelationInput
    _relevance?: counselingsessionOrderByRelevanceInput
  }

  export type counselingsessionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: counselingsessionWhereInput | counselingsessionWhereInput[]
    OR?: counselingsessionWhereInput[]
    NOT?: counselingsessionWhereInput | counselingsessionWhereInput[]
    userId?: IntFilter<"counselingsession"> | number
    counselorId?: IntFilter<"counselingsession"> | number
    topic?: StringFilter<"counselingsession"> | string
    question?: StringFilter<"counselingsession"> | string
    response?: StringNullableFilter<"counselingsession"> | string | null
    status?: StringFilter<"counselingsession"> | string
    createdAt?: DateTimeFilter<"counselingsession"> | Date | string
    rating?: IntNullableFilter<"counselingsession"> | number | null
    feedback?: StringNullableFilter<"counselingsession"> | string | null
    chatmessage?: ChatmessageListRelationFilter
    counselor?: XOR<CounselorScalarRelationFilter, counselorWhereInput>
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type counselingsessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    counselorId?: SortOrder
    topic?: SortOrder
    question?: SortOrder
    response?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    rating?: SortOrderInput | SortOrder
    feedback?: SortOrderInput | SortOrder
    _count?: counselingsessionCountOrderByAggregateInput
    _avg?: counselingsessionAvgOrderByAggregateInput
    _max?: counselingsessionMaxOrderByAggregateInput
    _min?: counselingsessionMinOrderByAggregateInput
    _sum?: counselingsessionSumOrderByAggregateInput
  }

  export type counselingsessionScalarWhereWithAggregatesInput = {
    AND?: counselingsessionScalarWhereWithAggregatesInput | counselingsessionScalarWhereWithAggregatesInput[]
    OR?: counselingsessionScalarWhereWithAggregatesInput[]
    NOT?: counselingsessionScalarWhereWithAggregatesInput | counselingsessionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"counselingsession"> | number
    userId?: IntWithAggregatesFilter<"counselingsession"> | number
    counselorId?: IntWithAggregatesFilter<"counselingsession"> | number
    topic?: StringWithAggregatesFilter<"counselingsession"> | string
    question?: StringWithAggregatesFilter<"counselingsession"> | string
    response?: StringNullableWithAggregatesFilter<"counselingsession"> | string | null
    status?: StringWithAggregatesFilter<"counselingsession"> | string
    createdAt?: DateTimeWithAggregatesFilter<"counselingsession"> | Date | string
    rating?: IntNullableWithAggregatesFilter<"counselingsession"> | number | null
    feedback?: StringNullableWithAggregatesFilter<"counselingsession"> | string | null
  }

  export type counselorWhereInput = {
    AND?: counselorWhereInput | counselorWhereInput[]
    OR?: counselorWhereInput[]
    NOT?: counselorWhereInput | counselorWhereInput[]
    id?: IntFilter<"counselor"> | number
    userId?: IntFilter<"counselor"> | number
    specialization?: StringFilter<"counselor"> | string
    bio?: StringFilter<"counselor"> | string
    verified?: BoolFilter<"counselor"> | boolean
    counselingsession?: CounselingsessionListRelationFilter
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type counselorOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    specialization?: SortOrder
    bio?: SortOrder
    verified?: SortOrder
    counselingsession?: counselingsessionOrderByRelationAggregateInput
    users?: UserOrderByWithRelationInput
    _relevance?: counselorOrderByRelevanceInput
  }

  export type counselorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: counselorWhereInput | counselorWhereInput[]
    OR?: counselorWhereInput[]
    NOT?: counselorWhereInput | counselorWhereInput[]
    specialization?: StringFilter<"counselor"> | string
    bio?: StringFilter<"counselor"> | string
    verified?: BoolFilter<"counselor"> | boolean
    counselingsession?: CounselingsessionListRelationFilter
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type counselorOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    specialization?: SortOrder
    bio?: SortOrder
    verified?: SortOrder
    _count?: counselorCountOrderByAggregateInput
    _avg?: counselorAvgOrderByAggregateInput
    _max?: counselorMaxOrderByAggregateInput
    _min?: counselorMinOrderByAggregateInput
    _sum?: counselorSumOrderByAggregateInput
  }

  export type counselorScalarWhereWithAggregatesInput = {
    AND?: counselorScalarWhereWithAggregatesInput | counselorScalarWhereWithAggregatesInput[]
    OR?: counselorScalarWhereWithAggregatesInput[]
    NOT?: counselorScalarWhereWithAggregatesInput | counselorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"counselor"> | number
    userId?: IntWithAggregatesFilter<"counselor"> | number
    specialization?: StringWithAggregatesFilter<"counselor"> | string
    bio?: StringWithAggregatesFilter<"counselor"> | string
    verified?: BoolWithAggregatesFilter<"counselor"> | boolean
  }

  export type courseWhereInput = {
    AND?: courseWhereInput | courseWhereInput[]
    OR?: courseWhereInput[]
    NOT?: courseWhereInput | courseWhereInput[]
    id?: IntFilter<"course"> | number
    title?: StringFilter<"course"> | string
    description?: StringFilter<"course"> | string
    thumbnail?: StringFilter<"course"> | string
    categoryId?: IntFilter<"course"> | number
    isPaid?: BoolFilter<"course"> | boolean
    price?: IntFilter<"course"> | number
    createdById?: IntFilter<"course"> | number
    createdAt?: DateTimeFilter<"course"> | Date | string
    certificate?: CertificateListRelationFilter
    category?: XOR<CategoryScalarRelationFilter, categoryWhereInput>
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
    courseprogress?: CourseprogressListRelationFilter
    coursevideo?: CoursevideoListRelationFilter
    enrollment?: EnrollmentListRelationFilter
    lesson?: LessonListRelationFilter
    payment?: PaymentListRelationFilter
    quiz?: QuizListRelationFilter
    quizsubmission?: QuizsubmissionListRelationFilter
    roadmapcourse?: RoadmapcourseListRelationFilter
  }

  export type courseOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    thumbnail?: SortOrder
    categoryId?: SortOrder
    isPaid?: SortOrder
    price?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    certificate?: certificateOrderByRelationAggregateInput
    category?: categoryOrderByWithRelationInput
    users?: UserOrderByWithRelationInput
    courseprogress?: courseprogressOrderByRelationAggregateInput
    coursevideo?: coursevideoOrderByRelationAggregateInput
    enrollment?: enrollmentOrderByRelationAggregateInput
    lesson?: lessonOrderByRelationAggregateInput
    payment?: paymentOrderByRelationAggregateInput
    quiz?: quizOrderByRelationAggregateInput
    quizsubmission?: quizsubmissionOrderByRelationAggregateInput
    roadmapcourse?: roadmapcourseOrderByRelationAggregateInput
    _relevance?: courseOrderByRelevanceInput
  }

  export type courseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: courseWhereInput | courseWhereInput[]
    OR?: courseWhereInput[]
    NOT?: courseWhereInput | courseWhereInput[]
    title?: StringFilter<"course"> | string
    description?: StringFilter<"course"> | string
    thumbnail?: StringFilter<"course"> | string
    categoryId?: IntFilter<"course"> | number
    isPaid?: BoolFilter<"course"> | boolean
    price?: IntFilter<"course"> | number
    createdById?: IntFilter<"course"> | number
    createdAt?: DateTimeFilter<"course"> | Date | string
    certificate?: CertificateListRelationFilter
    category?: XOR<CategoryScalarRelationFilter, categoryWhereInput>
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
    courseprogress?: CourseprogressListRelationFilter
    coursevideo?: CoursevideoListRelationFilter
    enrollment?: EnrollmentListRelationFilter
    lesson?: LessonListRelationFilter
    payment?: PaymentListRelationFilter
    quiz?: QuizListRelationFilter
    quizsubmission?: QuizsubmissionListRelationFilter
    roadmapcourse?: RoadmapcourseListRelationFilter
  }, "id">

  export type courseOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    thumbnail?: SortOrder
    categoryId?: SortOrder
    isPaid?: SortOrder
    price?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    _count?: courseCountOrderByAggregateInput
    _avg?: courseAvgOrderByAggregateInput
    _max?: courseMaxOrderByAggregateInput
    _min?: courseMinOrderByAggregateInput
    _sum?: courseSumOrderByAggregateInput
  }

  export type courseScalarWhereWithAggregatesInput = {
    AND?: courseScalarWhereWithAggregatesInput | courseScalarWhereWithAggregatesInput[]
    OR?: courseScalarWhereWithAggregatesInput[]
    NOT?: courseScalarWhereWithAggregatesInput | courseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"course"> | number
    title?: StringWithAggregatesFilter<"course"> | string
    description?: StringWithAggregatesFilter<"course"> | string
    thumbnail?: StringWithAggregatesFilter<"course"> | string
    categoryId?: IntWithAggregatesFilter<"course"> | number
    isPaid?: BoolWithAggregatesFilter<"course"> | boolean
    price?: IntWithAggregatesFilter<"course"> | number
    createdById?: IntWithAggregatesFilter<"course"> | number
    createdAt?: DateTimeWithAggregatesFilter<"course"> | Date | string
  }

  export type courseprogressWhereInput = {
    AND?: courseprogressWhereInput | courseprogressWhereInput[]
    OR?: courseprogressWhereInput[]
    NOT?: courseprogressWhereInput | courseprogressWhereInput[]
    id?: IntFilter<"courseprogress"> | number
    userId?: IntFilter<"courseprogress"> | number
    courseId?: IntFilter<"courseprogress"> | number
    completedVideoCount?: IntFilter<"courseprogress"> | number
    completedQuizCount?: IntFilter<"courseprogress"> | number
    isCompleted?: BoolFilter<"courseprogress"> | boolean
    course?: XOR<CourseScalarRelationFilter, courseWhereInput>
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type courseprogressOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    completedVideoCount?: SortOrder
    completedQuizCount?: SortOrder
    isCompleted?: SortOrder
    course?: courseOrderByWithRelationInput
    users?: UserOrderByWithRelationInput
  }

  export type courseprogressWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: courseprogressWhereInput | courseprogressWhereInput[]
    OR?: courseprogressWhereInput[]
    NOT?: courseprogressWhereInput | courseprogressWhereInput[]
    userId?: IntFilter<"courseprogress"> | number
    courseId?: IntFilter<"courseprogress"> | number
    completedVideoCount?: IntFilter<"courseprogress"> | number
    completedQuizCount?: IntFilter<"courseprogress"> | number
    isCompleted?: BoolFilter<"courseprogress"> | boolean
    course?: XOR<CourseScalarRelationFilter, courseWhereInput>
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type courseprogressOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    completedVideoCount?: SortOrder
    completedQuizCount?: SortOrder
    isCompleted?: SortOrder
    _count?: courseprogressCountOrderByAggregateInput
    _avg?: courseprogressAvgOrderByAggregateInput
    _max?: courseprogressMaxOrderByAggregateInput
    _min?: courseprogressMinOrderByAggregateInput
    _sum?: courseprogressSumOrderByAggregateInput
  }

  export type courseprogressScalarWhereWithAggregatesInput = {
    AND?: courseprogressScalarWhereWithAggregatesInput | courseprogressScalarWhereWithAggregatesInput[]
    OR?: courseprogressScalarWhereWithAggregatesInput[]
    NOT?: courseprogressScalarWhereWithAggregatesInput | courseprogressScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"courseprogress"> | number
    userId?: IntWithAggregatesFilter<"courseprogress"> | number
    courseId?: IntWithAggregatesFilter<"courseprogress"> | number
    completedVideoCount?: IntWithAggregatesFilter<"courseprogress"> | number
    completedQuizCount?: IntWithAggregatesFilter<"courseprogress"> | number
    isCompleted?: BoolWithAggregatesFilter<"courseprogress"> | boolean
  }

  export type coursevideoWhereInput = {
    AND?: coursevideoWhereInput | coursevideoWhereInput[]
    OR?: coursevideoWhereInput[]
    NOT?: coursevideoWhereInput | coursevideoWhereInput[]
    id?: IntFilter<"coursevideo"> | number
    courseId?: IntFilter<"coursevideo"> | number
    title?: StringFilter<"coursevideo"> | string
    videoUrl?: StringFilter<"coursevideo"> | string
    isLocked?: BoolFilter<"coursevideo"> | boolean
    order?: IntFilter<"coursevideo"> | number
    s3Key?: StringNullableFilter<"coursevideo"> | string | null
    course?: XOR<CourseScalarRelationFilter, courseWhereInput>
  }

  export type coursevideoOrderByWithRelationInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    videoUrl?: SortOrder
    isLocked?: SortOrder
    order?: SortOrder
    s3Key?: SortOrderInput | SortOrder
    course?: courseOrderByWithRelationInput
    _relevance?: coursevideoOrderByRelevanceInput
  }

  export type coursevideoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: coursevideoWhereInput | coursevideoWhereInput[]
    OR?: coursevideoWhereInput[]
    NOT?: coursevideoWhereInput | coursevideoWhereInput[]
    courseId?: IntFilter<"coursevideo"> | number
    title?: StringFilter<"coursevideo"> | string
    videoUrl?: StringFilter<"coursevideo"> | string
    isLocked?: BoolFilter<"coursevideo"> | boolean
    order?: IntFilter<"coursevideo"> | number
    s3Key?: StringNullableFilter<"coursevideo"> | string | null
    course?: XOR<CourseScalarRelationFilter, courseWhereInput>
  }, "id">

  export type coursevideoOrderByWithAggregationInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    videoUrl?: SortOrder
    isLocked?: SortOrder
    order?: SortOrder
    s3Key?: SortOrderInput | SortOrder
    _count?: coursevideoCountOrderByAggregateInput
    _avg?: coursevideoAvgOrderByAggregateInput
    _max?: coursevideoMaxOrderByAggregateInput
    _min?: coursevideoMinOrderByAggregateInput
    _sum?: coursevideoSumOrderByAggregateInput
  }

  export type coursevideoScalarWhereWithAggregatesInput = {
    AND?: coursevideoScalarWhereWithAggregatesInput | coursevideoScalarWhereWithAggregatesInput[]
    OR?: coursevideoScalarWhereWithAggregatesInput[]
    NOT?: coursevideoScalarWhereWithAggregatesInput | coursevideoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"coursevideo"> | number
    courseId?: IntWithAggregatesFilter<"coursevideo"> | number
    title?: StringWithAggregatesFilter<"coursevideo"> | string
    videoUrl?: StringWithAggregatesFilter<"coursevideo"> | string
    isLocked?: BoolWithAggregatesFilter<"coursevideo"> | boolean
    order?: IntWithAggregatesFilter<"coursevideo"> | number
    s3Key?: StringNullableWithAggregatesFilter<"coursevideo"> | string | null
  }

  export type cvreviewWhereInput = {
    AND?: cvreviewWhereInput | cvreviewWhereInput[]
    OR?: cvreviewWhereInput[]
    NOT?: cvreviewWhereInput | cvreviewWhereInput[]
    id?: IntFilter<"cvreview"> | number
    userId?: IntFilter<"cvreview"> | number
    cvFilePath?: StringFilter<"cvreview"> | string
    cvVersion?: IntFilter<"cvreview"> | number
    reviewResult?: StringFilter<"cvreview"> | string
    relevanceScore?: IntFilter<"cvreview"> | number
    feedback?: StringFilter<"cvreview"> | string
    createdAt?: DateTimeFilter<"cvreview"> | Date | string
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type cvreviewOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    cvFilePath?: SortOrder
    cvVersion?: SortOrder
    reviewResult?: SortOrder
    relevanceScore?: SortOrder
    feedback?: SortOrder
    createdAt?: SortOrder
    users?: UserOrderByWithRelationInput
    _relevance?: cvreviewOrderByRelevanceInput
  }

  export type cvreviewWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: cvreviewWhereInput | cvreviewWhereInput[]
    OR?: cvreviewWhereInput[]
    NOT?: cvreviewWhereInput | cvreviewWhereInput[]
    userId?: IntFilter<"cvreview"> | number
    cvFilePath?: StringFilter<"cvreview"> | string
    cvVersion?: IntFilter<"cvreview"> | number
    reviewResult?: StringFilter<"cvreview"> | string
    relevanceScore?: IntFilter<"cvreview"> | number
    feedback?: StringFilter<"cvreview"> | string
    createdAt?: DateTimeFilter<"cvreview"> | Date | string
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type cvreviewOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    cvFilePath?: SortOrder
    cvVersion?: SortOrder
    reviewResult?: SortOrder
    relevanceScore?: SortOrder
    feedback?: SortOrder
    createdAt?: SortOrder
    _count?: cvreviewCountOrderByAggregateInput
    _avg?: cvreviewAvgOrderByAggregateInput
    _max?: cvreviewMaxOrderByAggregateInput
    _min?: cvreviewMinOrderByAggregateInput
    _sum?: cvreviewSumOrderByAggregateInput
  }

  export type cvreviewScalarWhereWithAggregatesInput = {
    AND?: cvreviewScalarWhereWithAggregatesInput | cvreviewScalarWhereWithAggregatesInput[]
    OR?: cvreviewScalarWhereWithAggregatesInput[]
    NOT?: cvreviewScalarWhereWithAggregatesInput | cvreviewScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"cvreview"> | number
    userId?: IntWithAggregatesFilter<"cvreview"> | number
    cvFilePath?: StringWithAggregatesFilter<"cvreview"> | string
    cvVersion?: IntWithAggregatesFilter<"cvreview"> | number
    reviewResult?: StringWithAggregatesFilter<"cvreview"> | string
    relevanceScore?: IntWithAggregatesFilter<"cvreview"> | number
    feedback?: StringWithAggregatesFilter<"cvreview"> | string
    createdAt?: DateTimeWithAggregatesFilter<"cvreview"> | Date | string
  }

  export type enrollmentWhereInput = {
    AND?: enrollmentWhereInput | enrollmentWhereInput[]
    OR?: enrollmentWhereInput[]
    NOT?: enrollmentWhereInput | enrollmentWhereInput[]
    id?: IntFilter<"enrollment"> | number
    userId?: IntFilter<"enrollment"> | number
    courseId?: IntFilter<"enrollment"> | number
    enrolledAt?: DateTimeFilter<"enrollment"> | Date | string
    isPaid?: BoolFilter<"enrollment"> | boolean
    paymentId?: IntNullableFilter<"enrollment"> | number | null
    course?: XOR<CourseScalarRelationFilter, courseWhereInput>
    payment?: XOR<PaymentNullableScalarRelationFilter, paymentWhereInput> | null
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type enrollmentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    enrolledAt?: SortOrder
    isPaid?: SortOrder
    paymentId?: SortOrderInput | SortOrder
    course?: courseOrderByWithRelationInput
    payment?: paymentOrderByWithRelationInput
    users?: UserOrderByWithRelationInput
  }

  export type enrollmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: enrollmentWhereInput | enrollmentWhereInput[]
    OR?: enrollmentWhereInput[]
    NOT?: enrollmentWhereInput | enrollmentWhereInput[]
    userId?: IntFilter<"enrollment"> | number
    courseId?: IntFilter<"enrollment"> | number
    enrolledAt?: DateTimeFilter<"enrollment"> | Date | string
    isPaid?: BoolFilter<"enrollment"> | boolean
    paymentId?: IntNullableFilter<"enrollment"> | number | null
    course?: XOR<CourseScalarRelationFilter, courseWhereInput>
    payment?: XOR<PaymentNullableScalarRelationFilter, paymentWhereInput> | null
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type enrollmentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    enrolledAt?: SortOrder
    isPaid?: SortOrder
    paymentId?: SortOrderInput | SortOrder
    _count?: enrollmentCountOrderByAggregateInput
    _avg?: enrollmentAvgOrderByAggregateInput
    _max?: enrollmentMaxOrderByAggregateInput
    _min?: enrollmentMinOrderByAggregateInput
    _sum?: enrollmentSumOrderByAggregateInput
  }

  export type enrollmentScalarWhereWithAggregatesInput = {
    AND?: enrollmentScalarWhereWithAggregatesInput | enrollmentScalarWhereWithAggregatesInput[]
    OR?: enrollmentScalarWhereWithAggregatesInput[]
    NOT?: enrollmentScalarWhereWithAggregatesInput | enrollmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"enrollment"> | number
    userId?: IntWithAggregatesFilter<"enrollment"> | number
    courseId?: IntWithAggregatesFilter<"enrollment"> | number
    enrolledAt?: DateTimeWithAggregatesFilter<"enrollment"> | Date | string
    isPaid?: BoolWithAggregatesFilter<"enrollment"> | boolean
    paymentId?: IntNullableWithAggregatesFilter<"enrollment"> | number | null
  }

  export type jobmatchWhereInput = {
    AND?: jobmatchWhereInput | jobmatchWhereInput[]
    OR?: jobmatchWhereInput[]
    NOT?: jobmatchWhereInput | jobmatchWhereInput[]
    id?: IntFilter<"jobmatch"> | number
    userId?: IntFilter<"jobmatch"> | number
    cvFilePath?: StringFilter<"jobmatch"> | string
    matchedJobs?: JsonFilter<"jobmatch">
    generatedAt?: DateTimeFilter<"jobmatch"> | Date | string
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type jobmatchOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    cvFilePath?: SortOrder
    matchedJobs?: SortOrder
    generatedAt?: SortOrder
    users?: UserOrderByWithRelationInput
    _relevance?: jobmatchOrderByRelevanceInput
  }

  export type jobmatchWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: jobmatchWhereInput | jobmatchWhereInput[]
    OR?: jobmatchWhereInput[]
    NOT?: jobmatchWhereInput | jobmatchWhereInput[]
    userId?: IntFilter<"jobmatch"> | number
    cvFilePath?: StringFilter<"jobmatch"> | string
    matchedJobs?: JsonFilter<"jobmatch">
    generatedAt?: DateTimeFilter<"jobmatch"> | Date | string
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type jobmatchOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    cvFilePath?: SortOrder
    matchedJobs?: SortOrder
    generatedAt?: SortOrder
    _count?: jobmatchCountOrderByAggregateInput
    _avg?: jobmatchAvgOrderByAggregateInput
    _max?: jobmatchMaxOrderByAggregateInput
    _min?: jobmatchMinOrderByAggregateInput
    _sum?: jobmatchSumOrderByAggregateInput
  }

  export type jobmatchScalarWhereWithAggregatesInput = {
    AND?: jobmatchScalarWhereWithAggregatesInput | jobmatchScalarWhereWithAggregatesInput[]
    OR?: jobmatchScalarWhereWithAggregatesInput[]
    NOT?: jobmatchScalarWhereWithAggregatesInput | jobmatchScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"jobmatch"> | number
    userId?: IntWithAggregatesFilter<"jobmatch"> | number
    cvFilePath?: StringWithAggregatesFilter<"jobmatch"> | string
    matchedJobs?: JsonWithAggregatesFilter<"jobmatch">
    generatedAt?: DateTimeWithAggregatesFilter<"jobmatch"> | Date | string
  }

  export type lessonWhereInput = {
    AND?: lessonWhereInput | lessonWhereInput[]
    OR?: lessonWhereInput[]
    NOT?: lessonWhereInput | lessonWhereInput[]
    id?: IntFilter<"lesson"> | number
    title?: StringFilter<"lesson"> | string
    courseId?: IntFilter<"lesson"> | number
    content?: StringFilter<"lesson"> | string
    order?: IntFilter<"lesson"> | number
    course?: XOR<CourseScalarRelationFilter, courseWhereInput>
    lessonprogress?: LessonprogressListRelationFilter
  }

  export type lessonOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    courseId?: SortOrder
    content?: SortOrder
    order?: SortOrder
    course?: courseOrderByWithRelationInput
    lessonprogress?: lessonprogressOrderByRelationAggregateInput
    _relevance?: lessonOrderByRelevanceInput
  }

  export type lessonWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: lessonWhereInput | lessonWhereInput[]
    OR?: lessonWhereInput[]
    NOT?: lessonWhereInput | lessonWhereInput[]
    title?: StringFilter<"lesson"> | string
    courseId?: IntFilter<"lesson"> | number
    content?: StringFilter<"lesson"> | string
    order?: IntFilter<"lesson"> | number
    course?: XOR<CourseScalarRelationFilter, courseWhereInput>
    lessonprogress?: LessonprogressListRelationFilter
  }, "id">

  export type lessonOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    courseId?: SortOrder
    content?: SortOrder
    order?: SortOrder
    _count?: lessonCountOrderByAggregateInput
    _avg?: lessonAvgOrderByAggregateInput
    _max?: lessonMaxOrderByAggregateInput
    _min?: lessonMinOrderByAggregateInput
    _sum?: lessonSumOrderByAggregateInput
  }

  export type lessonScalarWhereWithAggregatesInput = {
    AND?: lessonScalarWhereWithAggregatesInput | lessonScalarWhereWithAggregatesInput[]
    OR?: lessonScalarWhereWithAggregatesInput[]
    NOT?: lessonScalarWhereWithAggregatesInput | lessonScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"lesson"> | number
    title?: StringWithAggregatesFilter<"lesson"> | string
    courseId?: IntWithAggregatesFilter<"lesson"> | number
    content?: StringWithAggregatesFilter<"lesson"> | string
    order?: IntWithAggregatesFilter<"lesson"> | number
  }

  export type lessonprogressWhereInput = {
    AND?: lessonprogressWhereInput | lessonprogressWhereInput[]
    OR?: lessonprogressWhereInput[]
    NOT?: lessonprogressWhereInput | lessonprogressWhereInput[]
    id?: IntFilter<"lessonprogress"> | number
    userId?: IntFilter<"lessonprogress"> | number
    lessonId?: IntFilter<"lessonprogress"> | number
    isCompleted?: BoolFilter<"lessonprogress"> | boolean
    updatedAt?: DateTimeFilter<"lessonprogress"> | Date | string
    lesson?: XOR<LessonScalarRelationFilter, lessonWhereInput>
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type lessonprogressOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    lessonId?: SortOrder
    isCompleted?: SortOrder
    updatedAt?: SortOrder
    lesson?: lessonOrderByWithRelationInput
    users?: UserOrderByWithRelationInput
  }

  export type lessonprogressWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_lessonId?: lessonprogressUserIdLessonIdCompoundUniqueInput
    AND?: lessonprogressWhereInput | lessonprogressWhereInput[]
    OR?: lessonprogressWhereInput[]
    NOT?: lessonprogressWhereInput | lessonprogressWhereInput[]
    userId?: IntFilter<"lessonprogress"> | number
    lessonId?: IntFilter<"lessonprogress"> | number
    isCompleted?: BoolFilter<"lessonprogress"> | boolean
    updatedAt?: DateTimeFilter<"lessonprogress"> | Date | string
    lesson?: XOR<LessonScalarRelationFilter, lessonWhereInput>
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_lessonId">

  export type lessonprogressOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    lessonId?: SortOrder
    isCompleted?: SortOrder
    updatedAt?: SortOrder
    _count?: lessonprogressCountOrderByAggregateInput
    _avg?: lessonprogressAvgOrderByAggregateInput
    _max?: lessonprogressMaxOrderByAggregateInput
    _min?: lessonprogressMinOrderByAggregateInput
    _sum?: lessonprogressSumOrderByAggregateInput
  }

  export type lessonprogressScalarWhereWithAggregatesInput = {
    AND?: lessonprogressScalarWhereWithAggregatesInput | lessonprogressScalarWhereWithAggregatesInput[]
    OR?: lessonprogressScalarWhereWithAggregatesInput[]
    NOT?: lessonprogressScalarWhereWithAggregatesInput | lessonprogressScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"lessonprogress"> | number
    userId?: IntWithAggregatesFilter<"lessonprogress"> | number
    lessonId?: IntWithAggregatesFilter<"lessonprogress"> | number
    isCompleted?: BoolWithAggregatesFilter<"lessonprogress"> | boolean
    updatedAt?: DateTimeWithAggregatesFilter<"lessonprogress"> | Date | string
  }

  export type notificationWhereInput = {
    AND?: notificationWhereInput | notificationWhereInput[]
    OR?: notificationWhereInput[]
    NOT?: notificationWhereInput | notificationWhereInput[]
    id?: IntFilter<"notification"> | number
    userId?: IntFilter<"notification"> | number
    message?: StringFilter<"notification"> | string
    isRead?: BoolFilter<"notification"> | boolean
    createdAt?: DateTimeFilter<"notification"> | Date | string
    type?: StringFilter<"notification"> | string
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type notificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    users?: UserOrderByWithRelationInput
    _relevance?: notificationOrderByRelevanceInput
  }

  export type notificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: notificationWhereInput | notificationWhereInput[]
    OR?: notificationWhereInput[]
    NOT?: notificationWhereInput | notificationWhereInput[]
    userId?: IntFilter<"notification"> | number
    message?: StringFilter<"notification"> | string
    isRead?: BoolFilter<"notification"> | boolean
    createdAt?: DateTimeFilter<"notification"> | Date | string
    type?: StringFilter<"notification"> | string
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type notificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    _count?: notificationCountOrderByAggregateInput
    _avg?: notificationAvgOrderByAggregateInput
    _max?: notificationMaxOrderByAggregateInput
    _min?: notificationMinOrderByAggregateInput
    _sum?: notificationSumOrderByAggregateInput
  }

  export type notificationScalarWhereWithAggregatesInput = {
    AND?: notificationScalarWhereWithAggregatesInput | notificationScalarWhereWithAggregatesInput[]
    OR?: notificationScalarWhereWithAggregatesInput[]
    NOT?: notificationScalarWhereWithAggregatesInput | notificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"notification"> | number
    userId?: IntWithAggregatesFilter<"notification"> | number
    message?: StringWithAggregatesFilter<"notification"> | string
    isRead?: BoolWithAggregatesFilter<"notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"notification"> | Date | string
    type?: StringWithAggregatesFilter<"notification"> | string
  }

  export type paymentWhereInput = {
    AND?: paymentWhereInput | paymentWhereInput[]
    OR?: paymentWhereInput[]
    NOT?: paymentWhereInput | paymentWhereInput[]
    id?: IntFilter<"payment"> | number
    userId?: IntFilter<"payment"> | number
    courseId?: IntNullableFilter<"payment"> | number | null
    roadmapId?: IntNullableFilter<"payment"> | number | null
    amount?: IntFilter<"payment"> | number
    paymentStatus?: StringFilter<"payment"> | string
    status?: StringFilter<"payment"> | string
    paidAt?: DateTimeFilter<"payment"> | Date | string
    createdAt?: DateTimeFilter<"payment"> | Date | string
    orderId?: StringNullableFilter<"payment"> | string | null
    snapToken?: StringNullableFilter<"payment"> | string | null
    enrollment?: EnrollmentListRelationFilter
    course?: XOR<CourseNullableScalarRelationFilter, courseWhereInput> | null
    roadmap?: XOR<RoadmapNullableScalarRelationFilter, roadmapWhereInput> | null
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type paymentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrderInput | SortOrder
    roadmapId?: SortOrderInput | SortOrder
    amount?: SortOrder
    paymentStatus?: SortOrder
    status?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
    orderId?: SortOrderInput | SortOrder
    snapToken?: SortOrderInput | SortOrder
    enrollment?: enrollmentOrderByRelationAggregateInput
    course?: courseOrderByWithRelationInput
    roadmap?: roadmapOrderByWithRelationInput
    users?: UserOrderByWithRelationInput
    _relevance?: paymentOrderByRelevanceInput
  }

  export type paymentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    orderId?: string
    AND?: paymentWhereInput | paymentWhereInput[]
    OR?: paymentWhereInput[]
    NOT?: paymentWhereInput | paymentWhereInput[]
    userId?: IntFilter<"payment"> | number
    courseId?: IntNullableFilter<"payment"> | number | null
    roadmapId?: IntNullableFilter<"payment"> | number | null
    amount?: IntFilter<"payment"> | number
    paymentStatus?: StringFilter<"payment"> | string
    status?: StringFilter<"payment"> | string
    paidAt?: DateTimeFilter<"payment"> | Date | string
    createdAt?: DateTimeFilter<"payment"> | Date | string
    snapToken?: StringNullableFilter<"payment"> | string | null
    enrollment?: EnrollmentListRelationFilter
    course?: XOR<CourseNullableScalarRelationFilter, courseWhereInput> | null
    roadmap?: XOR<RoadmapNullableScalarRelationFilter, roadmapWhereInput> | null
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "orderId">

  export type paymentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrderInput | SortOrder
    roadmapId?: SortOrderInput | SortOrder
    amount?: SortOrder
    paymentStatus?: SortOrder
    status?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
    orderId?: SortOrderInput | SortOrder
    snapToken?: SortOrderInput | SortOrder
    _count?: paymentCountOrderByAggregateInput
    _avg?: paymentAvgOrderByAggregateInput
    _max?: paymentMaxOrderByAggregateInput
    _min?: paymentMinOrderByAggregateInput
    _sum?: paymentSumOrderByAggregateInput
  }

  export type paymentScalarWhereWithAggregatesInput = {
    AND?: paymentScalarWhereWithAggregatesInput | paymentScalarWhereWithAggregatesInput[]
    OR?: paymentScalarWhereWithAggregatesInput[]
    NOT?: paymentScalarWhereWithAggregatesInput | paymentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"payment"> | number
    userId?: IntWithAggregatesFilter<"payment"> | number
    courseId?: IntNullableWithAggregatesFilter<"payment"> | number | null
    roadmapId?: IntNullableWithAggregatesFilter<"payment"> | number | null
    amount?: IntWithAggregatesFilter<"payment"> | number
    paymentStatus?: StringWithAggregatesFilter<"payment"> | string
    status?: StringWithAggregatesFilter<"payment"> | string
    paidAt?: DateTimeWithAggregatesFilter<"payment"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"payment"> | Date | string
    orderId?: StringNullableWithAggregatesFilter<"payment"> | string | null
    snapToken?: StringNullableWithAggregatesFilter<"payment"> | string | null
  }

  export type quizWhereInput = {
    AND?: quizWhereInput | quizWhereInput[]
    OR?: quizWhereInput[]
    NOT?: quizWhereInput | quizWhereInput[]
    id?: IntFilter<"quiz"> | number
    courseId?: IntFilter<"quiz"> | number
    question?: StringFilter<"quiz"> | string
    options?: JsonFilter<"quiz">
    correctAnswer?: StringFilter<"quiz"> | string
    isLocked?: BoolFilter<"quiz"> | boolean
    course?: XOR<CourseScalarRelationFilter, courseWhereInput>
    quizsubmission?: QuizsubmissionListRelationFilter
  }

  export type quizOrderByWithRelationInput = {
    id?: SortOrder
    courseId?: SortOrder
    question?: SortOrder
    options?: SortOrder
    correctAnswer?: SortOrder
    isLocked?: SortOrder
    course?: courseOrderByWithRelationInput
    quizsubmission?: quizsubmissionOrderByRelationAggregateInput
    _relevance?: quizOrderByRelevanceInput
  }

  export type quizWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: quizWhereInput | quizWhereInput[]
    OR?: quizWhereInput[]
    NOT?: quizWhereInput | quizWhereInput[]
    courseId?: IntFilter<"quiz"> | number
    question?: StringFilter<"quiz"> | string
    options?: JsonFilter<"quiz">
    correctAnswer?: StringFilter<"quiz"> | string
    isLocked?: BoolFilter<"quiz"> | boolean
    course?: XOR<CourseScalarRelationFilter, courseWhereInput>
    quizsubmission?: QuizsubmissionListRelationFilter
  }, "id">

  export type quizOrderByWithAggregationInput = {
    id?: SortOrder
    courseId?: SortOrder
    question?: SortOrder
    options?: SortOrder
    correctAnswer?: SortOrder
    isLocked?: SortOrder
    _count?: quizCountOrderByAggregateInput
    _avg?: quizAvgOrderByAggregateInput
    _max?: quizMaxOrderByAggregateInput
    _min?: quizMinOrderByAggregateInput
    _sum?: quizSumOrderByAggregateInput
  }

  export type quizScalarWhereWithAggregatesInput = {
    AND?: quizScalarWhereWithAggregatesInput | quizScalarWhereWithAggregatesInput[]
    OR?: quizScalarWhereWithAggregatesInput[]
    NOT?: quizScalarWhereWithAggregatesInput | quizScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"quiz"> | number
    courseId?: IntWithAggregatesFilter<"quiz"> | number
    question?: StringWithAggregatesFilter<"quiz"> | string
    options?: JsonWithAggregatesFilter<"quiz">
    correctAnswer?: StringWithAggregatesFilter<"quiz"> | string
    isLocked?: BoolWithAggregatesFilter<"quiz"> | boolean
  }

  export type quizsubmissionWhereInput = {
    AND?: quizsubmissionWhereInput | quizsubmissionWhereInput[]
    OR?: quizsubmissionWhereInput[]
    NOT?: quizsubmissionWhereInput | quizsubmissionWhereInput[]
    id?: IntFilter<"quizsubmission"> | number
    userId?: IntFilter<"quizsubmission"> | number
    courseId?: IntFilter<"quizsubmission"> | number
    quizId?: IntFilter<"quizsubmission"> | number
    answers?: JsonFilter<"quizsubmission">
    score?: IntFilter<"quizsubmission"> | number
    totalQuestions?: IntFilter<"quizsubmission"> | number
    isPassed?: BoolFilter<"quizsubmission"> | boolean
    createdAt?: DateTimeFilter<"quizsubmission"> | Date | string
    course?: XOR<CourseScalarRelationFilter, courseWhereInput>
    quiz?: XOR<QuizScalarRelationFilter, quizWhereInput>
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type quizsubmissionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    quizId?: SortOrder
    answers?: SortOrder
    score?: SortOrder
    totalQuestions?: SortOrder
    isPassed?: SortOrder
    createdAt?: SortOrder
    course?: courseOrderByWithRelationInput
    quiz?: quizOrderByWithRelationInput
    users?: UserOrderByWithRelationInput
  }

  export type quizsubmissionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: quizsubmissionWhereInput | quizsubmissionWhereInput[]
    OR?: quizsubmissionWhereInput[]
    NOT?: quizsubmissionWhereInput | quizsubmissionWhereInput[]
    userId?: IntFilter<"quizsubmission"> | number
    courseId?: IntFilter<"quizsubmission"> | number
    quizId?: IntFilter<"quizsubmission"> | number
    answers?: JsonFilter<"quizsubmission">
    score?: IntFilter<"quizsubmission"> | number
    totalQuestions?: IntFilter<"quizsubmission"> | number
    isPassed?: BoolFilter<"quizsubmission"> | boolean
    createdAt?: DateTimeFilter<"quizsubmission"> | Date | string
    course?: XOR<CourseScalarRelationFilter, courseWhereInput>
    quiz?: XOR<QuizScalarRelationFilter, quizWhereInput>
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type quizsubmissionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    quizId?: SortOrder
    answers?: SortOrder
    score?: SortOrder
    totalQuestions?: SortOrder
    isPassed?: SortOrder
    createdAt?: SortOrder
    _count?: quizsubmissionCountOrderByAggregateInput
    _avg?: quizsubmissionAvgOrderByAggregateInput
    _max?: quizsubmissionMaxOrderByAggregateInput
    _min?: quizsubmissionMinOrderByAggregateInput
    _sum?: quizsubmissionSumOrderByAggregateInput
  }

  export type quizsubmissionScalarWhereWithAggregatesInput = {
    AND?: quizsubmissionScalarWhereWithAggregatesInput | quizsubmissionScalarWhereWithAggregatesInput[]
    OR?: quizsubmissionScalarWhereWithAggregatesInput[]
    NOT?: quizsubmissionScalarWhereWithAggregatesInput | quizsubmissionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"quizsubmission"> | number
    userId?: IntWithAggregatesFilter<"quizsubmission"> | number
    courseId?: IntWithAggregatesFilter<"quizsubmission"> | number
    quizId?: IntWithAggregatesFilter<"quizsubmission"> | number
    answers?: JsonWithAggregatesFilter<"quizsubmission">
    score?: IntWithAggregatesFilter<"quizsubmission"> | number
    totalQuestions?: IntWithAggregatesFilter<"quizsubmission"> | number
    isPassed?: BoolWithAggregatesFilter<"quizsubmission"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"quizsubmission"> | Date | string
  }

  export type roadmapWhereInput = {
    AND?: roadmapWhereInput | roadmapWhereInput[]
    OR?: roadmapWhereInput[]
    NOT?: roadmapWhereInput | roadmapWhereInput[]
    id?: IntFilter<"roadmap"> | number
    name?: StringFilter<"roadmap"> | string
    description?: StringFilter<"roadmap"> | string
    rewardVoucher?: StringFilter<"roadmap"> | string
    payment?: PaymentListRelationFilter
    roadmapcourse?: RoadmapcourseListRelationFilter
    userroadmap?: UserroadmapListRelationFilter
  }

  export type roadmapOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    rewardVoucher?: SortOrder
    payment?: paymentOrderByRelationAggregateInput
    roadmapcourse?: roadmapcourseOrderByRelationAggregateInput
    userroadmap?: userroadmapOrderByRelationAggregateInput
    _relevance?: roadmapOrderByRelevanceInput
  }

  export type roadmapWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: roadmapWhereInput | roadmapWhereInput[]
    OR?: roadmapWhereInput[]
    NOT?: roadmapWhereInput | roadmapWhereInput[]
    name?: StringFilter<"roadmap"> | string
    description?: StringFilter<"roadmap"> | string
    rewardVoucher?: StringFilter<"roadmap"> | string
    payment?: PaymentListRelationFilter
    roadmapcourse?: RoadmapcourseListRelationFilter
    userroadmap?: UserroadmapListRelationFilter
  }, "id">

  export type roadmapOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    rewardVoucher?: SortOrder
    _count?: roadmapCountOrderByAggregateInput
    _avg?: roadmapAvgOrderByAggregateInput
    _max?: roadmapMaxOrderByAggregateInput
    _min?: roadmapMinOrderByAggregateInput
    _sum?: roadmapSumOrderByAggregateInput
  }

  export type roadmapScalarWhereWithAggregatesInput = {
    AND?: roadmapScalarWhereWithAggregatesInput | roadmapScalarWhereWithAggregatesInput[]
    OR?: roadmapScalarWhereWithAggregatesInput[]
    NOT?: roadmapScalarWhereWithAggregatesInput | roadmapScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"roadmap"> | number
    name?: StringWithAggregatesFilter<"roadmap"> | string
    description?: StringWithAggregatesFilter<"roadmap"> | string
    rewardVoucher?: StringWithAggregatesFilter<"roadmap"> | string
  }

  export type roadmapcourseWhereInput = {
    AND?: roadmapcourseWhereInput | roadmapcourseWhereInput[]
    OR?: roadmapcourseWhereInput[]
    NOT?: roadmapcourseWhereInput | roadmapcourseWhereInput[]
    id?: IntFilter<"roadmapcourse"> | number
    roadmapId?: IntFilter<"roadmapcourse"> | number
    courseId?: IntFilter<"roadmapcourse"> | number
    order?: IntFilter<"roadmapcourse"> | number
    course?: XOR<CourseScalarRelationFilter, courseWhereInput>
    roadmap?: XOR<RoadmapScalarRelationFilter, roadmapWhereInput>
  }

  export type roadmapcourseOrderByWithRelationInput = {
    id?: SortOrder
    roadmapId?: SortOrder
    courseId?: SortOrder
    order?: SortOrder
    course?: courseOrderByWithRelationInput
    roadmap?: roadmapOrderByWithRelationInput
  }

  export type roadmapcourseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: roadmapcourseWhereInput | roadmapcourseWhereInput[]
    OR?: roadmapcourseWhereInput[]
    NOT?: roadmapcourseWhereInput | roadmapcourseWhereInput[]
    roadmapId?: IntFilter<"roadmapcourse"> | number
    courseId?: IntFilter<"roadmapcourse"> | number
    order?: IntFilter<"roadmapcourse"> | number
    course?: XOR<CourseScalarRelationFilter, courseWhereInput>
    roadmap?: XOR<RoadmapScalarRelationFilter, roadmapWhereInput>
  }, "id">

  export type roadmapcourseOrderByWithAggregationInput = {
    id?: SortOrder
    roadmapId?: SortOrder
    courseId?: SortOrder
    order?: SortOrder
    _count?: roadmapcourseCountOrderByAggregateInput
    _avg?: roadmapcourseAvgOrderByAggregateInput
    _max?: roadmapcourseMaxOrderByAggregateInput
    _min?: roadmapcourseMinOrderByAggregateInput
    _sum?: roadmapcourseSumOrderByAggregateInput
  }

  export type roadmapcourseScalarWhereWithAggregatesInput = {
    AND?: roadmapcourseScalarWhereWithAggregatesInput | roadmapcourseScalarWhereWithAggregatesInput[]
    OR?: roadmapcourseScalarWhereWithAggregatesInput[]
    NOT?: roadmapcourseScalarWhereWithAggregatesInput | roadmapcourseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"roadmapcourse"> | number
    roadmapId?: IntWithAggregatesFilter<"roadmapcourse"> | number
    courseId?: IntWithAggregatesFilter<"roadmapcourse"> | number
    order?: IntWithAggregatesFilter<"roadmapcourse"> | number
  }

  export type userroadmapWhereInput = {
    AND?: userroadmapWhereInput | userroadmapWhereInput[]
    OR?: userroadmapWhereInput[]
    NOT?: userroadmapWhereInput | userroadmapWhereInput[]
    id?: IntFilter<"userroadmap"> | number
    userId?: IntFilter<"userroadmap"> | number
    roadmapId?: IntFilter<"userroadmap"> | number
    isUnlocked?: BoolFilter<"userroadmap"> | boolean
    unlockedAt?: DateTimeNullableFilter<"userroadmap"> | Date | string | null
    roadmap?: XOR<RoadmapScalarRelationFilter, roadmapWhereInput>
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type userroadmapOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    roadmapId?: SortOrder
    isUnlocked?: SortOrder
    unlockedAt?: SortOrderInput | SortOrder
    roadmap?: roadmapOrderByWithRelationInput
    users?: UserOrderByWithRelationInput
  }

  export type userroadmapWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: userroadmapWhereInput | userroadmapWhereInput[]
    OR?: userroadmapWhereInput[]
    NOT?: userroadmapWhereInput | userroadmapWhereInput[]
    userId?: IntFilter<"userroadmap"> | number
    roadmapId?: IntFilter<"userroadmap"> | number
    isUnlocked?: BoolFilter<"userroadmap"> | boolean
    unlockedAt?: DateTimeNullableFilter<"userroadmap"> | Date | string | null
    roadmap?: XOR<RoadmapScalarRelationFilter, roadmapWhereInput>
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type userroadmapOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    roadmapId?: SortOrder
    isUnlocked?: SortOrder
    unlockedAt?: SortOrderInput | SortOrder
    _count?: userroadmapCountOrderByAggregateInput
    _avg?: userroadmapAvgOrderByAggregateInput
    _max?: userroadmapMaxOrderByAggregateInput
    _min?: userroadmapMinOrderByAggregateInput
    _sum?: userroadmapSumOrderByAggregateInput
  }

  export type userroadmapScalarWhereWithAggregatesInput = {
    AND?: userroadmapScalarWhereWithAggregatesInput | userroadmapScalarWhereWithAggregatesInput[]
    OR?: userroadmapScalarWhereWithAggregatesInput[]
    NOT?: userroadmapScalarWhereWithAggregatesInput | userroadmapScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"userroadmap"> | number
    userId?: IntWithAggregatesFilter<"userroadmap"> | number
    roadmapId?: IntWithAggregatesFilter<"userroadmap"> | number
    isUnlocked?: BoolWithAggregatesFilter<"userroadmap"> | boolean
    unlockedAt?: DateTimeNullableWithAggregatesFilter<"userroadmap"> | Date | string | null
  }

  export type VoucherWhereInput = {
    AND?: VoucherWhereInput | VoucherWhereInput[]
    OR?: VoucherWhereInput[]
    NOT?: VoucherWhereInput | VoucherWhereInput[]
    id?: IntFilter<"Voucher"> | number
    code?: StringFilter<"Voucher"> | string
    discount?: IntFilter<"Voucher"> | number
    expiresAt?: DateTimeFilter<"Voucher"> | Date | string
    userId?: IntFilter<"Voucher"> | number
    isUsed?: BoolFilter<"Voucher"> | boolean
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type VoucherOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    discount?: SortOrder
    expiresAt?: SortOrder
    userId?: SortOrder
    isUsed?: SortOrder
    users?: UserOrderByWithRelationInput
    _relevance?: VoucherOrderByRelevanceInput
  }

  export type VoucherWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: VoucherWhereInput | VoucherWhereInput[]
    OR?: VoucherWhereInput[]
    NOT?: VoucherWhereInput | VoucherWhereInput[]
    discount?: IntFilter<"Voucher"> | number
    expiresAt?: DateTimeFilter<"Voucher"> | Date | string
    userId?: IntFilter<"Voucher"> | number
    isUsed?: BoolFilter<"Voucher"> | boolean
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "code">

  export type VoucherOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    discount?: SortOrder
    expiresAt?: SortOrder
    userId?: SortOrder
    isUsed?: SortOrder
    _count?: VoucherCountOrderByAggregateInput
    _avg?: VoucherAvgOrderByAggregateInput
    _max?: VoucherMaxOrderByAggregateInput
    _min?: VoucherMinOrderByAggregateInput
    _sum?: VoucherSumOrderByAggregateInput
  }

  export type VoucherScalarWhereWithAggregatesInput = {
    AND?: VoucherScalarWhereWithAggregatesInput | VoucherScalarWhereWithAggregatesInput[]
    OR?: VoucherScalarWhereWithAggregatesInput[]
    NOT?: VoucherScalarWhereWithAggregatesInput | VoucherScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Voucher"> | number
    code?: StringWithAggregatesFilter<"Voucher"> | string
    discount?: IntWithAggregatesFilter<"Voucher"> | number
    expiresAt?: DateTimeWithAggregatesFilter<"Voucher"> | Date | string
    userId?: IntWithAggregatesFilter<"Voucher"> | number
    isUsed?: BoolWithAggregatesFilter<"Voucher"> | boolean
  }

  export type UserCreateInput = {
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    address?: string | null
    gender?: string | null
    birthDate?: Date | string | null
    role?: $Enums.Role
    profilePicture?: string | null
    createdAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    assessment?: assessmentCreateNestedManyWithoutUsersInput
    certificate?: certificateCreateNestedManyWithoutUsersInput
    chatmessage?: chatmessageCreateNestedManyWithoutUsersInput
    counselingsession?: counselingsessionCreateNestedManyWithoutUsersInput
    counselor?: counselorCreateNestedOneWithoutUsersInput
    course?: courseCreateNestedManyWithoutUsersInput
    courseprogress?: courseprogressCreateNestedManyWithoutUsersInput
    cvreview?: cvreviewCreateNestedManyWithoutUsersInput
    enrollment?: enrollmentCreateNestedManyWithoutUsersInput
    jobmatch?: jobmatchCreateNestedManyWithoutUsersInput
    lessonprogress?: lessonprogressCreateNestedManyWithoutUsersInput
    notification?: notificationCreateNestedManyWithoutUsersInput
    payment?: paymentCreateNestedManyWithoutUsersInput
    quizsubmission?: quizsubmissionCreateNestedManyWithoutUsersInput
    userroadmap?: userroadmapCreateNestedManyWithoutUsersInput
    voucher?: VoucherCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    address?: string | null
    gender?: string | null
    birthDate?: Date | string | null
    role?: $Enums.Role
    profilePicture?: string | null
    createdAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    assessment?: assessmentUncheckedCreateNestedManyWithoutUsersInput
    certificate?: certificateUncheckedCreateNestedManyWithoutUsersInput
    chatmessage?: chatmessageUncheckedCreateNestedManyWithoutUsersInput
    counselingsession?: counselingsessionUncheckedCreateNestedManyWithoutUsersInput
    counselor?: counselorUncheckedCreateNestedOneWithoutUsersInput
    course?: courseUncheckedCreateNestedManyWithoutUsersInput
    courseprogress?: courseprogressUncheckedCreateNestedManyWithoutUsersInput
    cvreview?: cvreviewUncheckedCreateNestedManyWithoutUsersInput
    enrollment?: enrollmentUncheckedCreateNestedManyWithoutUsersInput
    jobmatch?: jobmatchUncheckedCreateNestedManyWithoutUsersInput
    lessonprogress?: lessonprogressUncheckedCreateNestedManyWithoutUsersInput
    notification?: notificationUncheckedCreateNestedManyWithoutUsersInput
    payment?: paymentUncheckedCreateNestedManyWithoutUsersInput
    quizsubmission?: quizsubmissionUncheckedCreateNestedManyWithoutUsersInput
    userroadmap?: userroadmapUncheckedCreateNestedManyWithoutUsersInput
    voucher?: VoucherUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserUpdateInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assessment?: assessmentUpdateManyWithoutUsersNestedInput
    certificate?: certificateUpdateManyWithoutUsersNestedInput
    chatmessage?: chatmessageUpdateManyWithoutUsersNestedInput
    counselingsession?: counselingsessionUpdateManyWithoutUsersNestedInput
    counselor?: counselorUpdateOneWithoutUsersNestedInput
    course?: courseUpdateManyWithoutUsersNestedInput
    courseprogress?: courseprogressUpdateManyWithoutUsersNestedInput
    cvreview?: cvreviewUpdateManyWithoutUsersNestedInput
    enrollment?: enrollmentUpdateManyWithoutUsersNestedInput
    jobmatch?: jobmatchUpdateManyWithoutUsersNestedInput
    lessonprogress?: lessonprogressUpdateManyWithoutUsersNestedInput
    notification?: notificationUpdateManyWithoutUsersNestedInput
    payment?: paymentUpdateManyWithoutUsersNestedInput
    quizsubmission?: quizsubmissionUpdateManyWithoutUsersNestedInput
    userroadmap?: userroadmapUpdateManyWithoutUsersNestedInput
    voucher?: VoucherUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assessment?: assessmentUncheckedUpdateManyWithoutUsersNestedInput
    certificate?: certificateUncheckedUpdateManyWithoutUsersNestedInput
    chatmessage?: chatmessageUncheckedUpdateManyWithoutUsersNestedInput
    counselingsession?: counselingsessionUncheckedUpdateManyWithoutUsersNestedInput
    counselor?: counselorUncheckedUpdateOneWithoutUsersNestedInput
    course?: courseUncheckedUpdateManyWithoutUsersNestedInput
    courseprogress?: courseprogressUncheckedUpdateManyWithoutUsersNestedInput
    cvreview?: cvreviewUncheckedUpdateManyWithoutUsersNestedInput
    enrollment?: enrollmentUncheckedUpdateManyWithoutUsersNestedInput
    jobmatch?: jobmatchUncheckedUpdateManyWithoutUsersNestedInput
    lessonprogress?: lessonprogressUncheckedUpdateManyWithoutUsersNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUsersNestedInput
    payment?: paymentUncheckedUpdateManyWithoutUsersNestedInput
    quizsubmission?: quizsubmissionUncheckedUpdateManyWithoutUsersNestedInput
    userroadmap?: userroadmapUncheckedUpdateManyWithoutUsersNestedInput
    voucher?: VoucherUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    address?: string | null
    gender?: string | null
    birthDate?: Date | string | null
    role?: $Enums.Role
    profilePicture?: string | null
    createdAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RoadmapMatcherCreateInput = {
    keyword: string
    roadmapId: number
    matchField: string
  }

  export type RoadmapMatcherUncheckedCreateInput = {
    id?: number
    keyword: string
    roadmapId: number
    matchField: string
  }

  export type RoadmapMatcherUpdateInput = {
    keyword?: StringFieldUpdateOperationsInput | string
    roadmapId?: IntFieldUpdateOperationsInput | number
    matchField?: StringFieldUpdateOperationsInput | string
  }

  export type RoadmapMatcherUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    keyword?: StringFieldUpdateOperationsInput | string
    roadmapId?: IntFieldUpdateOperationsInput | number
    matchField?: StringFieldUpdateOperationsInput | string
  }

  export type RoadmapMatcherCreateManyInput = {
    id?: number
    keyword: string
    roadmapId: number
    matchField: string
  }

  export type RoadmapMatcherUpdateManyMutationInput = {
    keyword?: StringFieldUpdateOperationsInput | string
    roadmapId?: IntFieldUpdateOperationsInput | number
    matchField?: StringFieldUpdateOperationsInput | string
  }

  export type RoadmapMatcherUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    keyword?: StringFieldUpdateOperationsInput | string
    roadmapId?: IntFieldUpdateOperationsInput | number
    matchField?: StringFieldUpdateOperationsInput | string
  }

  export type assessmentCreateInput = {
    studentStatus: string
    majorStudy: string
    currentSemester: string
    createdAt?: Date | string
    currentField: string
    dreamJob: string
    interestedField: string
    mainGoal: string
    users: UserCreateNestedOneWithoutAssessmentInput
  }

  export type assessmentUncheckedCreateInput = {
    id?: number
    userId: number
    studentStatus: string
    majorStudy: string
    currentSemester: string
    createdAt?: Date | string
    currentField: string
    dreamJob: string
    interestedField: string
    mainGoal: string
  }

  export type assessmentUpdateInput = {
    studentStatus?: StringFieldUpdateOperationsInput | string
    majorStudy?: StringFieldUpdateOperationsInput | string
    currentSemester?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentField?: StringFieldUpdateOperationsInput | string
    dreamJob?: StringFieldUpdateOperationsInput | string
    interestedField?: StringFieldUpdateOperationsInput | string
    mainGoal?: StringFieldUpdateOperationsInput | string
    users?: UserUpdateOneRequiredWithoutAssessmentNestedInput
  }

  export type assessmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    studentStatus?: StringFieldUpdateOperationsInput | string
    majorStudy?: StringFieldUpdateOperationsInput | string
    currentSemester?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentField?: StringFieldUpdateOperationsInput | string
    dreamJob?: StringFieldUpdateOperationsInput | string
    interestedField?: StringFieldUpdateOperationsInput | string
    mainGoal?: StringFieldUpdateOperationsInput | string
  }

  export type assessmentCreateManyInput = {
    id?: number
    userId: number
    studentStatus: string
    majorStudy: string
    currentSemester: string
    createdAt?: Date | string
    currentField: string
    dreamJob: string
    interestedField: string
    mainGoal: string
  }

  export type assessmentUpdateManyMutationInput = {
    studentStatus?: StringFieldUpdateOperationsInput | string
    majorStudy?: StringFieldUpdateOperationsInput | string
    currentSemester?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentField?: StringFieldUpdateOperationsInput | string
    dreamJob?: StringFieldUpdateOperationsInput | string
    interestedField?: StringFieldUpdateOperationsInput | string
    mainGoal?: StringFieldUpdateOperationsInput | string
  }

  export type assessmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    studentStatus?: StringFieldUpdateOperationsInput | string
    majorStudy?: StringFieldUpdateOperationsInput | string
    currentSemester?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentField?: StringFieldUpdateOperationsInput | string
    dreamJob?: StringFieldUpdateOperationsInput | string
    interestedField?: StringFieldUpdateOperationsInput | string
    mainGoal?: StringFieldUpdateOperationsInput | string
  }

  export type BookmarkCourseCreateInput = {
    userId: number
    courseId: number
    createdAt?: Date | string
  }

  export type BookmarkCourseUncheckedCreateInput = {
    id?: number
    userId: number
    courseId: number
    createdAt?: Date | string
  }

  export type BookmarkCourseUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookmarkCourseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookmarkCourseCreateManyInput = {
    id?: number
    userId: number
    courseId: number
    createdAt?: Date | string
  }

  export type BookmarkCourseUpdateManyMutationInput = {
    userId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookmarkCourseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type categoryCreateInput = {
    name: string
    course?: courseCreateNestedManyWithoutCategoryInput
  }

  export type categoryUncheckedCreateInput = {
    id?: number
    name: string
    course?: courseUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type categoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    course?: courseUpdateManyWithoutCategoryNestedInput
  }

  export type categoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    course?: courseUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type categoryCreateManyInput = {
    id?: number
    name: string
  }

  export type categoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type categoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type certificateCreateInput = {
    filePath: string
    issuedAt: Date | string
    course: courseCreateNestedOneWithoutCertificateInput
    users: UserCreateNestedOneWithoutCertificateInput
  }

  export type certificateUncheckedCreateInput = {
    id?: number
    userId: number
    courseId: number
    filePath: string
    issuedAt: Date | string
  }

  export type certificateUpdateInput = {
    filePath?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: courseUpdateOneRequiredWithoutCertificateNestedInput
    users?: UserUpdateOneRequiredWithoutCertificateNestedInput
  }

  export type certificateUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    filePath?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type certificateCreateManyInput = {
    id?: number
    userId: number
    courseId: number
    filePath: string
    issuedAt: Date | string
  }

  export type certificateUpdateManyMutationInput = {
    filePath?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type certificateUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    filePath?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type chatmessageCreateInput = {
    message: string
    sentAt?: Date | string
    users: UserCreateNestedOneWithoutChatmessageInput
    counselingsession: counselingsessionCreateNestedOneWithoutChatmessageInput
  }

  export type chatmessageUncheckedCreateInput = {
    id?: number
    sessionId: number
    senderId: number
    message: string
    sentAt?: Date | string
  }

  export type chatmessageUpdateInput = {
    message?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateOneRequiredWithoutChatmessageNestedInput
    counselingsession?: counselingsessionUpdateOneRequiredWithoutChatmessageNestedInput
  }

  export type chatmessageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionId?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type chatmessageCreateManyInput = {
    id?: number
    sessionId: number
    senderId: number
    message: string
    sentAt?: Date | string
  }

  export type chatmessageUpdateManyMutationInput = {
    message?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type chatmessageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionId?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type counselingsessionCreateInput = {
    topic: string
    question: string
    response?: string | null
    status: string
    createdAt?: Date | string
    rating?: number | null
    feedback?: string | null
    chatmessage?: chatmessageCreateNestedManyWithoutCounselingsessionInput
    counselor: counselorCreateNestedOneWithoutCounselingsessionInput
    users: UserCreateNestedOneWithoutCounselingsessionInput
  }

  export type counselingsessionUncheckedCreateInput = {
    id?: number
    userId: number
    counselorId: number
    topic: string
    question: string
    response?: string | null
    status: string
    createdAt?: Date | string
    rating?: number | null
    feedback?: string | null
    chatmessage?: chatmessageUncheckedCreateNestedManyWithoutCounselingsessionInput
  }

  export type counselingsessionUpdateInput = {
    topic?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    chatmessage?: chatmessageUpdateManyWithoutCounselingsessionNestedInput
    counselor?: counselorUpdateOneRequiredWithoutCounselingsessionNestedInput
    users?: UserUpdateOneRequiredWithoutCounselingsessionNestedInput
  }

  export type counselingsessionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    counselorId?: IntFieldUpdateOperationsInput | number
    topic?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    chatmessage?: chatmessageUncheckedUpdateManyWithoutCounselingsessionNestedInput
  }

  export type counselingsessionCreateManyInput = {
    id?: number
    userId: number
    counselorId: number
    topic: string
    question: string
    response?: string | null
    status: string
    createdAt?: Date | string
    rating?: number | null
    feedback?: string | null
  }

  export type counselingsessionUpdateManyMutationInput = {
    topic?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type counselingsessionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    counselorId?: IntFieldUpdateOperationsInput | number
    topic?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type counselorCreateInput = {
    specialization: string
    bio: string
    verified: boolean
    counselingsession?: counselingsessionCreateNestedManyWithoutCounselorInput
    users: UserCreateNestedOneWithoutCounselorInput
  }

  export type counselorUncheckedCreateInput = {
    id?: number
    userId: number
    specialization: string
    bio: string
    verified: boolean
    counselingsession?: counselingsessionUncheckedCreateNestedManyWithoutCounselorInput
  }

  export type counselorUpdateInput = {
    specialization?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    counselingsession?: counselingsessionUpdateManyWithoutCounselorNestedInput
    users?: UserUpdateOneRequiredWithoutCounselorNestedInput
  }

  export type counselorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    specialization?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    counselingsession?: counselingsessionUncheckedUpdateManyWithoutCounselorNestedInput
  }

  export type counselorCreateManyInput = {
    id?: number
    userId: number
    specialization: string
    bio: string
    verified: boolean
  }

  export type counselorUpdateManyMutationInput = {
    specialization?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type counselorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    specialization?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type courseCreateInput = {
    title: string
    description: string
    thumbnail: string
    isPaid: boolean
    price: number
    createdAt?: Date | string
    certificate?: certificateCreateNestedManyWithoutCourseInput
    category: categoryCreateNestedOneWithoutCourseInput
    users: UserCreateNestedOneWithoutCourseInput
    courseprogress?: courseprogressCreateNestedManyWithoutCourseInput
    coursevideo?: coursevideoCreateNestedManyWithoutCourseInput
    enrollment?: enrollmentCreateNestedManyWithoutCourseInput
    lesson?: lessonCreateNestedManyWithoutCourseInput
    payment?: paymentCreateNestedManyWithoutCourseInput
    quiz?: quizCreateNestedManyWithoutCourseInput
    quizsubmission?: quizsubmissionCreateNestedManyWithoutCourseInput
    roadmapcourse?: roadmapcourseCreateNestedManyWithoutCourseInput
  }

  export type courseUncheckedCreateInput = {
    id?: number
    title: string
    description: string
    thumbnail: string
    categoryId: number
    isPaid: boolean
    price: number
    createdById: number
    createdAt?: Date | string
    certificate?: certificateUncheckedCreateNestedManyWithoutCourseInput
    courseprogress?: courseprogressUncheckedCreateNestedManyWithoutCourseInput
    coursevideo?: coursevideoUncheckedCreateNestedManyWithoutCourseInput
    enrollment?: enrollmentUncheckedCreateNestedManyWithoutCourseInput
    lesson?: lessonUncheckedCreateNestedManyWithoutCourseInput
    payment?: paymentUncheckedCreateNestedManyWithoutCourseInput
    quiz?: quizUncheckedCreateNestedManyWithoutCourseInput
    quizsubmission?: quizsubmissionUncheckedCreateNestedManyWithoutCourseInput
    roadmapcourse?: roadmapcourseUncheckedCreateNestedManyWithoutCourseInput
  }

  export type courseUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificate?: certificateUpdateManyWithoutCourseNestedInput
    category?: categoryUpdateOneRequiredWithoutCourseNestedInput
    users?: UserUpdateOneRequiredWithoutCourseNestedInput
    courseprogress?: courseprogressUpdateManyWithoutCourseNestedInput
    coursevideo?: coursevideoUpdateManyWithoutCourseNestedInput
    enrollment?: enrollmentUpdateManyWithoutCourseNestedInput
    lesson?: lessonUpdateManyWithoutCourseNestedInput
    payment?: paymentUpdateManyWithoutCourseNestedInput
    quiz?: quizUpdateManyWithoutCourseNestedInput
    quizsubmission?: quizsubmissionUpdateManyWithoutCourseNestedInput
    roadmapcourse?: roadmapcourseUpdateManyWithoutCourseNestedInput
  }

  export type courseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificate?: certificateUncheckedUpdateManyWithoutCourseNestedInput
    courseprogress?: courseprogressUncheckedUpdateManyWithoutCourseNestedInput
    coursevideo?: coursevideoUncheckedUpdateManyWithoutCourseNestedInput
    enrollment?: enrollmentUncheckedUpdateManyWithoutCourseNestedInput
    lesson?: lessonUncheckedUpdateManyWithoutCourseNestedInput
    payment?: paymentUncheckedUpdateManyWithoutCourseNestedInput
    quiz?: quizUncheckedUpdateManyWithoutCourseNestedInput
    quizsubmission?: quizsubmissionUncheckedUpdateManyWithoutCourseNestedInput
    roadmapcourse?: roadmapcourseUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type courseCreateManyInput = {
    id?: number
    title: string
    description: string
    thumbnail: string
    categoryId: number
    isPaid: boolean
    price: number
    createdById: number
    createdAt?: Date | string
  }

  export type courseUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type courseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type courseprogressCreateInput = {
    completedVideoCount: number
    completedQuizCount: number
    isCompleted: boolean
    course: courseCreateNestedOneWithoutCourseprogressInput
    users: UserCreateNestedOneWithoutCourseprogressInput
  }

  export type courseprogressUncheckedCreateInput = {
    id?: number
    userId: number
    courseId: number
    completedVideoCount: number
    completedQuizCount: number
    isCompleted: boolean
  }

  export type courseprogressUpdateInput = {
    completedVideoCount?: IntFieldUpdateOperationsInput | number
    completedQuizCount?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    course?: courseUpdateOneRequiredWithoutCourseprogressNestedInput
    users?: UserUpdateOneRequiredWithoutCourseprogressNestedInput
  }

  export type courseprogressUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    completedVideoCount?: IntFieldUpdateOperationsInput | number
    completedQuizCount?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type courseprogressCreateManyInput = {
    id?: number
    userId: number
    courseId: number
    completedVideoCount: number
    completedQuizCount: number
    isCompleted: boolean
  }

  export type courseprogressUpdateManyMutationInput = {
    completedVideoCount?: IntFieldUpdateOperationsInput | number
    completedQuizCount?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type courseprogressUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    completedVideoCount?: IntFieldUpdateOperationsInput | number
    completedQuizCount?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type coursevideoCreateInput = {
    title: string
    videoUrl: string
    isLocked: boolean
    order: number
    s3Key?: string | null
    course: courseCreateNestedOneWithoutCoursevideoInput
  }

  export type coursevideoUncheckedCreateInput = {
    id?: number
    courseId: number
    title: string
    videoUrl: string
    isLocked: boolean
    order: number
    s3Key?: string | null
  }

  export type coursevideoUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    s3Key?: NullableStringFieldUpdateOperationsInput | string | null
    course?: courseUpdateOneRequiredWithoutCoursevideoNestedInput
  }

  export type coursevideoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    s3Key?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type coursevideoCreateManyInput = {
    id?: number
    courseId: number
    title: string
    videoUrl: string
    isLocked: boolean
    order: number
    s3Key?: string | null
  }

  export type coursevideoUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    s3Key?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type coursevideoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    s3Key?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type cvreviewCreateInput = {
    cvFilePath: string
    cvVersion: number
    reviewResult: string
    relevanceScore: number
    feedback: string
    createdAt?: Date | string
    users: UserCreateNestedOneWithoutCvreviewInput
  }

  export type cvreviewUncheckedCreateInput = {
    id?: number
    userId: number
    cvFilePath: string
    cvVersion: number
    reviewResult: string
    relevanceScore: number
    feedback: string
    createdAt?: Date | string
  }

  export type cvreviewUpdateInput = {
    cvFilePath?: StringFieldUpdateOperationsInput | string
    cvVersion?: IntFieldUpdateOperationsInput | number
    reviewResult?: StringFieldUpdateOperationsInput | string
    relevanceScore?: IntFieldUpdateOperationsInput | number
    feedback?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateOneRequiredWithoutCvreviewNestedInput
  }

  export type cvreviewUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    cvFilePath?: StringFieldUpdateOperationsInput | string
    cvVersion?: IntFieldUpdateOperationsInput | number
    reviewResult?: StringFieldUpdateOperationsInput | string
    relevanceScore?: IntFieldUpdateOperationsInput | number
    feedback?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cvreviewCreateManyInput = {
    id?: number
    userId: number
    cvFilePath: string
    cvVersion: number
    reviewResult: string
    relevanceScore: number
    feedback: string
    createdAt?: Date | string
  }

  export type cvreviewUpdateManyMutationInput = {
    cvFilePath?: StringFieldUpdateOperationsInput | string
    cvVersion?: IntFieldUpdateOperationsInput | number
    reviewResult?: StringFieldUpdateOperationsInput | string
    relevanceScore?: IntFieldUpdateOperationsInput | number
    feedback?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cvreviewUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    cvFilePath?: StringFieldUpdateOperationsInput | string
    cvVersion?: IntFieldUpdateOperationsInput | number
    reviewResult?: StringFieldUpdateOperationsInput | string
    relevanceScore?: IntFieldUpdateOperationsInput | number
    feedback?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type enrollmentCreateInput = {
    enrolledAt?: Date | string
    isPaid: boolean
    course: courseCreateNestedOneWithoutEnrollmentInput
    payment?: paymentCreateNestedOneWithoutEnrollmentInput
    users: UserCreateNestedOneWithoutEnrollmentInput
  }

  export type enrollmentUncheckedCreateInput = {
    id?: number
    userId: number
    courseId: number
    enrolledAt?: Date | string
    isPaid: boolean
    paymentId?: number | null
  }

  export type enrollmentUpdateInput = {
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    course?: courseUpdateOneRequiredWithoutEnrollmentNestedInput
    payment?: paymentUpdateOneWithoutEnrollmentNestedInput
    users?: UserUpdateOneRequiredWithoutEnrollmentNestedInput
  }

  export type enrollmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paymentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type enrollmentCreateManyInput = {
    id?: number
    userId: number
    courseId: number
    enrolledAt?: Date | string
    isPaid: boolean
    paymentId?: number | null
  }

  export type enrollmentUpdateManyMutationInput = {
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
  }

  export type enrollmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paymentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type jobmatchCreateInput = {
    cvFilePath: string
    matchedJobs: JsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
    users: UserCreateNestedOneWithoutJobmatchInput
  }

  export type jobmatchUncheckedCreateInput = {
    id?: number
    userId: number
    cvFilePath: string
    matchedJobs: JsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
  }

  export type jobmatchUpdateInput = {
    cvFilePath?: StringFieldUpdateOperationsInput | string
    matchedJobs?: JsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateOneRequiredWithoutJobmatchNestedInput
  }

  export type jobmatchUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    cvFilePath?: StringFieldUpdateOperationsInput | string
    matchedJobs?: JsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type jobmatchCreateManyInput = {
    id?: number
    userId: number
    cvFilePath: string
    matchedJobs: JsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
  }

  export type jobmatchUpdateManyMutationInput = {
    cvFilePath?: StringFieldUpdateOperationsInput | string
    matchedJobs?: JsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type jobmatchUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    cvFilePath?: StringFieldUpdateOperationsInput | string
    matchedJobs?: JsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type lessonCreateInput = {
    title: string
    content: string
    order: number
    course: courseCreateNestedOneWithoutLessonInput
    lessonprogress?: lessonprogressCreateNestedManyWithoutLessonInput
  }

  export type lessonUncheckedCreateInput = {
    id?: number
    title: string
    courseId: number
    content: string
    order: number
    lessonprogress?: lessonprogressUncheckedCreateNestedManyWithoutLessonInput
  }

  export type lessonUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    course?: courseUpdateOneRequiredWithoutLessonNestedInput
    lessonprogress?: lessonprogressUpdateManyWithoutLessonNestedInput
  }

  export type lessonUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    courseId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    lessonprogress?: lessonprogressUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type lessonCreateManyInput = {
    id?: number
    title: string
    courseId: number
    content: string
    order: number
  }

  export type lessonUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type lessonUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    courseId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type lessonprogressCreateInput = {
    isCompleted?: boolean
    updatedAt: Date | string
    lesson: lessonCreateNestedOneWithoutLessonprogressInput
    users: UserCreateNestedOneWithoutLessonprogressInput
  }

  export type lessonprogressUncheckedCreateInput = {
    id?: number
    userId: number
    lessonId: number
    isCompleted?: boolean
    updatedAt: Date | string
  }

  export type lessonprogressUpdateInput = {
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lesson?: lessonUpdateOneRequiredWithoutLessonprogressNestedInput
    users?: UserUpdateOneRequiredWithoutLessonprogressNestedInput
  }

  export type lessonprogressUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    lessonId?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type lessonprogressCreateManyInput = {
    id?: number
    userId: number
    lessonId: number
    isCompleted?: boolean
    updatedAt: Date | string
  }

  export type lessonprogressUpdateManyMutationInput = {
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type lessonprogressUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    lessonId?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationCreateInput = {
    message: string
    isRead?: boolean
    createdAt?: Date | string
    type: string
    users: UserCreateNestedOneWithoutNotificationInput
  }

  export type notificationUncheckedCreateInput = {
    id?: number
    userId: number
    message: string
    isRead?: boolean
    createdAt?: Date | string
    type: string
  }

  export type notificationUpdateInput = {
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    users?: UserUpdateOneRequiredWithoutNotificationNestedInput
  }

  export type notificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type notificationCreateManyInput = {
    id?: number
    userId: number
    message: string
    isRead?: boolean
    createdAt?: Date | string
    type: string
  }

  export type notificationUpdateManyMutationInput = {
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type notificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type paymentCreateInput = {
    amount: number
    paymentStatus: string
    status: string
    paidAt: Date | string
    createdAt?: Date | string
    orderId?: string | null
    snapToken?: string | null
    enrollment?: enrollmentCreateNestedManyWithoutPaymentInput
    course?: courseCreateNestedOneWithoutPaymentInput
    roadmap?: roadmapCreateNestedOneWithoutPaymentInput
    users: UserCreateNestedOneWithoutPaymentInput
  }

  export type paymentUncheckedCreateInput = {
    id?: number
    userId: number
    courseId?: number | null
    roadmapId?: number | null
    amount: number
    paymentStatus: string
    status: string
    paidAt: Date | string
    createdAt?: Date | string
    orderId?: string | null
    snapToken?: string | null
    enrollment?: enrollmentUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type paymentUpdateInput = {
    amount?: IntFieldUpdateOperationsInput | number
    paymentStatus?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    snapToken?: NullableStringFieldUpdateOperationsInput | string | null
    enrollment?: enrollmentUpdateManyWithoutPaymentNestedInput
    course?: courseUpdateOneWithoutPaymentNestedInput
    roadmap?: roadmapUpdateOneWithoutPaymentNestedInput
    users?: UserUpdateOneRequiredWithoutPaymentNestedInput
  }

  export type paymentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    roadmapId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: IntFieldUpdateOperationsInput | number
    paymentStatus?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    snapToken?: NullableStringFieldUpdateOperationsInput | string | null
    enrollment?: enrollmentUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type paymentCreateManyInput = {
    id?: number
    userId: number
    courseId?: number | null
    roadmapId?: number | null
    amount: number
    paymentStatus: string
    status: string
    paidAt: Date | string
    createdAt?: Date | string
    orderId?: string | null
    snapToken?: string | null
  }

  export type paymentUpdateManyMutationInput = {
    amount?: IntFieldUpdateOperationsInput | number
    paymentStatus?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    snapToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type paymentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    roadmapId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: IntFieldUpdateOperationsInput | number
    paymentStatus?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    snapToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type quizCreateInput = {
    question: string
    options: JsonNullValueInput | InputJsonValue
    correctAnswer: string
    isLocked: boolean
    course: courseCreateNestedOneWithoutQuizInput
    quizsubmission?: quizsubmissionCreateNestedManyWithoutQuizInput
  }

  export type quizUncheckedCreateInput = {
    id?: number
    courseId: number
    question: string
    options: JsonNullValueInput | InputJsonValue
    correctAnswer: string
    isLocked: boolean
    quizsubmission?: quizsubmissionUncheckedCreateNestedManyWithoutQuizInput
  }

  export type quizUpdateInput = {
    question?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    correctAnswer?: StringFieldUpdateOperationsInput | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    course?: courseUpdateOneRequiredWithoutQuizNestedInput
    quizsubmission?: quizsubmissionUpdateManyWithoutQuizNestedInput
  }

  export type quizUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    correctAnswer?: StringFieldUpdateOperationsInput | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    quizsubmission?: quizsubmissionUncheckedUpdateManyWithoutQuizNestedInput
  }

  export type quizCreateManyInput = {
    id?: number
    courseId: number
    question: string
    options: JsonNullValueInput | InputJsonValue
    correctAnswer: string
    isLocked: boolean
  }

  export type quizUpdateManyMutationInput = {
    question?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    correctAnswer?: StringFieldUpdateOperationsInput | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type quizUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    correctAnswer?: StringFieldUpdateOperationsInput | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type quizsubmissionCreateInput = {
    answers: JsonNullValueInput | InputJsonValue
    score: number
    totalQuestions: number
    isPassed: boolean
    createdAt?: Date | string
    course: courseCreateNestedOneWithoutQuizsubmissionInput
    quiz: quizCreateNestedOneWithoutQuizsubmissionInput
    users: UserCreateNestedOneWithoutQuizsubmissionInput
  }

  export type quizsubmissionUncheckedCreateInput = {
    id?: number
    userId: number
    courseId: number
    quizId: number
    answers: JsonNullValueInput | InputJsonValue
    score: number
    totalQuestions: number
    isPassed: boolean
    createdAt?: Date | string
  }

  export type quizsubmissionUpdateInput = {
    answers?: JsonNullValueInput | InputJsonValue
    score?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    isPassed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: courseUpdateOneRequiredWithoutQuizsubmissionNestedInput
    quiz?: quizUpdateOneRequiredWithoutQuizsubmissionNestedInput
    users?: UserUpdateOneRequiredWithoutQuizsubmissionNestedInput
  }

  export type quizsubmissionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    quizId?: IntFieldUpdateOperationsInput | number
    answers?: JsonNullValueInput | InputJsonValue
    score?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    isPassed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type quizsubmissionCreateManyInput = {
    id?: number
    userId: number
    courseId: number
    quizId: number
    answers: JsonNullValueInput | InputJsonValue
    score: number
    totalQuestions: number
    isPassed: boolean
    createdAt?: Date | string
  }

  export type quizsubmissionUpdateManyMutationInput = {
    answers?: JsonNullValueInput | InputJsonValue
    score?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    isPassed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type quizsubmissionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    quizId?: IntFieldUpdateOperationsInput | number
    answers?: JsonNullValueInput | InputJsonValue
    score?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    isPassed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type roadmapCreateInput = {
    name: string
    description: string
    rewardVoucher: string
    payment?: paymentCreateNestedManyWithoutRoadmapInput
    roadmapcourse?: roadmapcourseCreateNestedManyWithoutRoadmapInput
    userroadmap?: userroadmapCreateNestedManyWithoutRoadmapInput
  }

  export type roadmapUncheckedCreateInput = {
    id?: number
    name: string
    description: string
    rewardVoucher: string
    payment?: paymentUncheckedCreateNestedManyWithoutRoadmapInput
    roadmapcourse?: roadmapcourseUncheckedCreateNestedManyWithoutRoadmapInput
    userroadmap?: userroadmapUncheckedCreateNestedManyWithoutRoadmapInput
  }

  export type roadmapUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rewardVoucher?: StringFieldUpdateOperationsInput | string
    payment?: paymentUpdateManyWithoutRoadmapNestedInput
    roadmapcourse?: roadmapcourseUpdateManyWithoutRoadmapNestedInput
    userroadmap?: userroadmapUpdateManyWithoutRoadmapNestedInput
  }

  export type roadmapUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rewardVoucher?: StringFieldUpdateOperationsInput | string
    payment?: paymentUncheckedUpdateManyWithoutRoadmapNestedInput
    roadmapcourse?: roadmapcourseUncheckedUpdateManyWithoutRoadmapNestedInput
    userroadmap?: userroadmapUncheckedUpdateManyWithoutRoadmapNestedInput
  }

  export type roadmapCreateManyInput = {
    id?: number
    name: string
    description: string
    rewardVoucher: string
  }

  export type roadmapUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rewardVoucher?: StringFieldUpdateOperationsInput | string
  }

  export type roadmapUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rewardVoucher?: StringFieldUpdateOperationsInput | string
  }

  export type roadmapcourseCreateInput = {
    order: number
    course: courseCreateNestedOneWithoutRoadmapcourseInput
    roadmap: roadmapCreateNestedOneWithoutRoadmapcourseInput
  }

  export type roadmapcourseUncheckedCreateInput = {
    id?: number
    roadmapId: number
    courseId: number
    order: number
  }

  export type roadmapcourseUpdateInput = {
    order?: IntFieldUpdateOperationsInput | number
    course?: courseUpdateOneRequiredWithoutRoadmapcourseNestedInput
    roadmap?: roadmapUpdateOneRequiredWithoutRoadmapcourseNestedInput
  }

  export type roadmapcourseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    roadmapId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
  }

  export type roadmapcourseCreateManyInput = {
    id?: number
    roadmapId: number
    courseId: number
    order: number
  }

  export type roadmapcourseUpdateManyMutationInput = {
    order?: IntFieldUpdateOperationsInput | number
  }

  export type roadmapcourseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    roadmapId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
  }

  export type userroadmapCreateInput = {
    isUnlocked: boolean
    unlockedAt?: Date | string | null
    roadmap: roadmapCreateNestedOneWithoutUserroadmapInput
    users: UserCreateNestedOneWithoutUserroadmapInput
  }

  export type userroadmapUncheckedCreateInput = {
    id?: number
    userId: number
    roadmapId: number
    isUnlocked: boolean
    unlockedAt?: Date | string | null
  }

  export type userroadmapUpdateInput = {
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roadmap?: roadmapUpdateOneRequiredWithoutUserroadmapNestedInput
    users?: UserUpdateOneRequiredWithoutUserroadmapNestedInput
  }

  export type userroadmapUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    roadmapId?: IntFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userroadmapCreateManyInput = {
    id?: number
    userId: number
    roadmapId: number
    isUnlocked: boolean
    unlockedAt?: Date | string | null
  }

  export type userroadmapUpdateManyMutationInput = {
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userroadmapUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    roadmapId?: IntFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VoucherCreateInput = {
    code: string
    discount: number
    expiresAt: Date | string
    isUsed?: boolean
    users: UserCreateNestedOneWithoutVoucherInput
  }

  export type VoucherUncheckedCreateInput = {
    id?: number
    code: string
    discount: number
    expiresAt: Date | string
    userId: number
    isUsed?: boolean
  }

  export type VoucherUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    discount?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    users?: UserUpdateOneRequiredWithoutVoucherNestedInput
  }

  export type VoucherUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    discount?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    isUsed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VoucherCreateManyInput = {
    id?: number
    code: string
    discount: number
    expiresAt: Date | string
    userId: number
    isUsed?: boolean
  }

  export type VoucherUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    discount?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VoucherUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    discount?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    isUsed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AssessmentListRelationFilter = {
    every?: assessmentWhereInput
    some?: assessmentWhereInput
    none?: assessmentWhereInput
  }

  export type CertificateListRelationFilter = {
    every?: certificateWhereInput
    some?: certificateWhereInput
    none?: certificateWhereInput
  }

  export type ChatmessageListRelationFilter = {
    every?: chatmessageWhereInput
    some?: chatmessageWhereInput
    none?: chatmessageWhereInput
  }

  export type CounselingsessionListRelationFilter = {
    every?: counselingsessionWhereInput
    some?: counselingsessionWhereInput
    none?: counselingsessionWhereInput
  }

  export type CounselorNullableScalarRelationFilter = {
    is?: counselorWhereInput | null
    isNot?: counselorWhereInput | null
  }

  export type CourseListRelationFilter = {
    every?: courseWhereInput
    some?: courseWhereInput
    none?: courseWhereInput
  }

  export type CourseprogressListRelationFilter = {
    every?: courseprogressWhereInput
    some?: courseprogressWhereInput
    none?: courseprogressWhereInput
  }

  export type CvreviewListRelationFilter = {
    every?: cvreviewWhereInput
    some?: cvreviewWhereInput
    none?: cvreviewWhereInput
  }

  export type EnrollmentListRelationFilter = {
    every?: enrollmentWhereInput
    some?: enrollmentWhereInput
    none?: enrollmentWhereInput
  }

  export type JobmatchListRelationFilter = {
    every?: jobmatchWhereInput
    some?: jobmatchWhereInput
    none?: jobmatchWhereInput
  }

  export type LessonprogressListRelationFilter = {
    every?: lessonprogressWhereInput
    some?: lessonprogressWhereInput
    none?: lessonprogressWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: notificationWhereInput
    some?: notificationWhereInput
    none?: notificationWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: paymentWhereInput
    some?: paymentWhereInput
    none?: paymentWhereInput
  }

  export type QuizsubmissionListRelationFilter = {
    every?: quizsubmissionWhereInput
    some?: quizsubmissionWhereInput
    none?: quizsubmissionWhereInput
  }

  export type UserroadmapListRelationFilter = {
    every?: userroadmapWhereInput
    some?: userroadmapWhereInput
    none?: userroadmapWhereInput
  }

  export type VoucherListRelationFilter = {
    every?: VoucherWhereInput
    some?: VoucherWhereInput
    none?: VoucherWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type assessmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type certificateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type chatmessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type counselingsessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type courseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type courseprogressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type cvreviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type enrollmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type jobmatchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type lessonprogressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type notificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type paymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type quizsubmissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userroadmapOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VoucherOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    address?: SortOrder
    gender?: SortOrder
    birthDate?: SortOrder
    role?: SortOrder
    profilePicture?: SortOrder
    createdAt?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    address?: SortOrder
    gender?: SortOrder
    birthDate?: SortOrder
    role?: SortOrder
    profilePicture?: SortOrder
    createdAt?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    password?: SortOrder
    address?: SortOrder
    gender?: SortOrder
    birthDate?: SortOrder
    role?: SortOrder
    profilePicture?: SortOrder
    createdAt?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type RoadmapMatcherOrderByRelevanceInput = {
    fields: RoadmapMatcherOrderByRelevanceFieldEnum | RoadmapMatcherOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RoadmapMatcherCountOrderByAggregateInput = {
    id?: SortOrder
    keyword?: SortOrder
    roadmapId?: SortOrder
    matchField?: SortOrder
  }

  export type RoadmapMatcherAvgOrderByAggregateInput = {
    id?: SortOrder
    roadmapId?: SortOrder
  }

  export type RoadmapMatcherMaxOrderByAggregateInput = {
    id?: SortOrder
    keyword?: SortOrder
    roadmapId?: SortOrder
    matchField?: SortOrder
  }

  export type RoadmapMatcherMinOrderByAggregateInput = {
    id?: SortOrder
    keyword?: SortOrder
    roadmapId?: SortOrder
    matchField?: SortOrder
  }

  export type RoadmapMatcherSumOrderByAggregateInput = {
    id?: SortOrder
    roadmapId?: SortOrder
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type assessmentOrderByRelevanceInput = {
    fields: assessmentOrderByRelevanceFieldEnum | assessmentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type assessmentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    studentStatus?: SortOrder
    majorStudy?: SortOrder
    currentSemester?: SortOrder
    createdAt?: SortOrder
    currentField?: SortOrder
    dreamJob?: SortOrder
    interestedField?: SortOrder
    mainGoal?: SortOrder
  }

  export type assessmentAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type assessmentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    studentStatus?: SortOrder
    majorStudy?: SortOrder
    currentSemester?: SortOrder
    createdAt?: SortOrder
    currentField?: SortOrder
    dreamJob?: SortOrder
    interestedField?: SortOrder
    mainGoal?: SortOrder
  }

  export type assessmentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    studentStatus?: SortOrder
    majorStudy?: SortOrder
    currentSemester?: SortOrder
    createdAt?: SortOrder
    currentField?: SortOrder
    dreamJob?: SortOrder
    interestedField?: SortOrder
    mainGoal?: SortOrder
  }

  export type assessmentSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type BookmarkCourseUserIdCourseIdCompoundUniqueInput = {
    userId: number
    courseId: number
  }

  export type BookmarkCourseCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    createdAt?: SortOrder
  }

  export type BookmarkCourseAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
  }

  export type BookmarkCourseMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    createdAt?: SortOrder
  }

  export type BookmarkCourseMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    createdAt?: SortOrder
  }

  export type BookmarkCourseSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
  }

  export type categoryOrderByRelevanceInput = {
    fields: categoryOrderByRelevanceFieldEnum | categoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type categoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type categoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type categoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type categoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type categorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CourseScalarRelationFilter = {
    is?: courseWhereInput
    isNot?: courseWhereInput
  }

  export type certificateOrderByRelevanceInput = {
    fields: certificateOrderByRelevanceFieldEnum | certificateOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type certificateCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    filePath?: SortOrder
    issuedAt?: SortOrder
  }

  export type certificateAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
  }

  export type certificateMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    filePath?: SortOrder
    issuedAt?: SortOrder
  }

  export type certificateMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    filePath?: SortOrder
    issuedAt?: SortOrder
  }

  export type certificateSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
  }

  export type CounselingsessionScalarRelationFilter = {
    is?: counselingsessionWhereInput
    isNot?: counselingsessionWhereInput
  }

  export type chatmessageOrderByRelevanceInput = {
    fields: chatmessageOrderByRelevanceFieldEnum | chatmessageOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type chatmessageCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    senderId?: SortOrder
    message?: SortOrder
    sentAt?: SortOrder
  }

  export type chatmessageAvgOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    senderId?: SortOrder
  }

  export type chatmessageMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    senderId?: SortOrder
    message?: SortOrder
    sentAt?: SortOrder
  }

  export type chatmessageMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    senderId?: SortOrder
    message?: SortOrder
    sentAt?: SortOrder
  }

  export type chatmessageSumOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    senderId?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type CounselorScalarRelationFilter = {
    is?: counselorWhereInput
    isNot?: counselorWhereInput
  }

  export type counselingsessionOrderByRelevanceInput = {
    fields: counselingsessionOrderByRelevanceFieldEnum | counselingsessionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type counselingsessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    counselorId?: SortOrder
    topic?: SortOrder
    question?: SortOrder
    response?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    rating?: SortOrder
    feedback?: SortOrder
  }

  export type counselingsessionAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    counselorId?: SortOrder
    rating?: SortOrder
  }

  export type counselingsessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    counselorId?: SortOrder
    topic?: SortOrder
    question?: SortOrder
    response?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    rating?: SortOrder
    feedback?: SortOrder
  }

  export type counselingsessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    counselorId?: SortOrder
    topic?: SortOrder
    question?: SortOrder
    response?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    rating?: SortOrder
    feedback?: SortOrder
  }

  export type counselingsessionSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    counselorId?: SortOrder
    rating?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type counselorOrderByRelevanceInput = {
    fields: counselorOrderByRelevanceFieldEnum | counselorOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type counselorCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    specialization?: SortOrder
    bio?: SortOrder
    verified?: SortOrder
  }

  export type counselorAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type counselorMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    specialization?: SortOrder
    bio?: SortOrder
    verified?: SortOrder
  }

  export type counselorMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    specialization?: SortOrder
    bio?: SortOrder
    verified?: SortOrder
  }

  export type counselorSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type CategoryScalarRelationFilter = {
    is?: categoryWhereInput
    isNot?: categoryWhereInput
  }

  export type CoursevideoListRelationFilter = {
    every?: coursevideoWhereInput
    some?: coursevideoWhereInput
    none?: coursevideoWhereInput
  }

  export type LessonListRelationFilter = {
    every?: lessonWhereInput
    some?: lessonWhereInput
    none?: lessonWhereInput
  }

  export type QuizListRelationFilter = {
    every?: quizWhereInput
    some?: quizWhereInput
    none?: quizWhereInput
  }

  export type RoadmapcourseListRelationFilter = {
    every?: roadmapcourseWhereInput
    some?: roadmapcourseWhereInput
    none?: roadmapcourseWhereInput
  }

  export type coursevideoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type lessonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type quizOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type roadmapcourseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type courseOrderByRelevanceInput = {
    fields: courseOrderByRelevanceFieldEnum | courseOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type courseCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    thumbnail?: SortOrder
    categoryId?: SortOrder
    isPaid?: SortOrder
    price?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type courseAvgOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    price?: SortOrder
    createdById?: SortOrder
  }

  export type courseMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    thumbnail?: SortOrder
    categoryId?: SortOrder
    isPaid?: SortOrder
    price?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type courseMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    thumbnail?: SortOrder
    categoryId?: SortOrder
    isPaid?: SortOrder
    price?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type courseSumOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    price?: SortOrder
    createdById?: SortOrder
  }

  export type courseprogressCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    completedVideoCount?: SortOrder
    completedQuizCount?: SortOrder
    isCompleted?: SortOrder
  }

  export type courseprogressAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    completedVideoCount?: SortOrder
    completedQuizCount?: SortOrder
  }

  export type courseprogressMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    completedVideoCount?: SortOrder
    completedQuizCount?: SortOrder
    isCompleted?: SortOrder
  }

  export type courseprogressMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    completedVideoCount?: SortOrder
    completedQuizCount?: SortOrder
    isCompleted?: SortOrder
  }

  export type courseprogressSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    completedVideoCount?: SortOrder
    completedQuizCount?: SortOrder
  }

  export type coursevideoOrderByRelevanceInput = {
    fields: coursevideoOrderByRelevanceFieldEnum | coursevideoOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type coursevideoCountOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    videoUrl?: SortOrder
    isLocked?: SortOrder
    order?: SortOrder
    s3Key?: SortOrder
  }

  export type coursevideoAvgOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    order?: SortOrder
  }

  export type coursevideoMaxOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    videoUrl?: SortOrder
    isLocked?: SortOrder
    order?: SortOrder
    s3Key?: SortOrder
  }

  export type coursevideoMinOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    videoUrl?: SortOrder
    isLocked?: SortOrder
    order?: SortOrder
    s3Key?: SortOrder
  }

  export type coursevideoSumOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    order?: SortOrder
  }

  export type cvreviewOrderByRelevanceInput = {
    fields: cvreviewOrderByRelevanceFieldEnum | cvreviewOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type cvreviewCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    cvFilePath?: SortOrder
    cvVersion?: SortOrder
    reviewResult?: SortOrder
    relevanceScore?: SortOrder
    feedback?: SortOrder
    createdAt?: SortOrder
  }

  export type cvreviewAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    cvVersion?: SortOrder
    relevanceScore?: SortOrder
  }

  export type cvreviewMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    cvFilePath?: SortOrder
    cvVersion?: SortOrder
    reviewResult?: SortOrder
    relevanceScore?: SortOrder
    feedback?: SortOrder
    createdAt?: SortOrder
  }

  export type cvreviewMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    cvFilePath?: SortOrder
    cvVersion?: SortOrder
    reviewResult?: SortOrder
    relevanceScore?: SortOrder
    feedback?: SortOrder
    createdAt?: SortOrder
  }

  export type cvreviewSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    cvVersion?: SortOrder
    relevanceScore?: SortOrder
  }

  export type PaymentNullableScalarRelationFilter = {
    is?: paymentWhereInput | null
    isNot?: paymentWhereInput | null
  }

  export type enrollmentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    enrolledAt?: SortOrder
    isPaid?: SortOrder
    paymentId?: SortOrder
  }

  export type enrollmentAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    paymentId?: SortOrder
  }

  export type enrollmentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    enrolledAt?: SortOrder
    isPaid?: SortOrder
    paymentId?: SortOrder
  }

  export type enrollmentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    enrolledAt?: SortOrder
    isPaid?: SortOrder
    paymentId?: SortOrder
  }

  export type enrollmentSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    paymentId?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type jobmatchOrderByRelevanceInput = {
    fields: jobmatchOrderByRelevanceFieldEnum | jobmatchOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type jobmatchCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    cvFilePath?: SortOrder
    matchedJobs?: SortOrder
    generatedAt?: SortOrder
  }

  export type jobmatchAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type jobmatchMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    cvFilePath?: SortOrder
    generatedAt?: SortOrder
  }

  export type jobmatchMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    cvFilePath?: SortOrder
    generatedAt?: SortOrder
  }

  export type jobmatchSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type lessonOrderByRelevanceInput = {
    fields: lessonOrderByRelevanceFieldEnum | lessonOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type lessonCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    courseId?: SortOrder
    content?: SortOrder
    order?: SortOrder
  }

  export type lessonAvgOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    order?: SortOrder
  }

  export type lessonMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    courseId?: SortOrder
    content?: SortOrder
    order?: SortOrder
  }

  export type lessonMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    courseId?: SortOrder
    content?: SortOrder
    order?: SortOrder
  }

  export type lessonSumOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    order?: SortOrder
  }

  export type LessonScalarRelationFilter = {
    is?: lessonWhereInput
    isNot?: lessonWhereInput
  }

  export type lessonprogressUserIdLessonIdCompoundUniqueInput = {
    userId: number
    lessonId: number
  }

  export type lessonprogressCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    lessonId?: SortOrder
    isCompleted?: SortOrder
    updatedAt?: SortOrder
  }

  export type lessonprogressAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    lessonId?: SortOrder
  }

  export type lessonprogressMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    lessonId?: SortOrder
    isCompleted?: SortOrder
    updatedAt?: SortOrder
  }

  export type lessonprogressMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    lessonId?: SortOrder
    isCompleted?: SortOrder
    updatedAt?: SortOrder
  }

  export type lessonprogressSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    lessonId?: SortOrder
  }

  export type notificationOrderByRelevanceInput = {
    fields: notificationOrderByRelevanceFieldEnum | notificationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type notificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
  }

  export type notificationAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type notificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
  }

  export type notificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
  }

  export type notificationSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type CourseNullableScalarRelationFilter = {
    is?: courseWhereInput | null
    isNot?: courseWhereInput | null
  }

  export type RoadmapNullableScalarRelationFilter = {
    is?: roadmapWhereInput | null
    isNot?: roadmapWhereInput | null
  }

  export type paymentOrderByRelevanceInput = {
    fields: paymentOrderByRelevanceFieldEnum | paymentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type paymentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    roadmapId?: SortOrder
    amount?: SortOrder
    paymentStatus?: SortOrder
    status?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
    orderId?: SortOrder
    snapToken?: SortOrder
  }

  export type paymentAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    roadmapId?: SortOrder
    amount?: SortOrder
  }

  export type paymentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    roadmapId?: SortOrder
    amount?: SortOrder
    paymentStatus?: SortOrder
    status?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
    orderId?: SortOrder
    snapToken?: SortOrder
  }

  export type paymentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    roadmapId?: SortOrder
    amount?: SortOrder
    paymentStatus?: SortOrder
    status?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
    orderId?: SortOrder
    snapToken?: SortOrder
  }

  export type paymentSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    roadmapId?: SortOrder
    amount?: SortOrder
  }

  export type quizOrderByRelevanceInput = {
    fields: quizOrderByRelevanceFieldEnum | quizOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type quizCountOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    question?: SortOrder
    options?: SortOrder
    correctAnswer?: SortOrder
    isLocked?: SortOrder
  }

  export type quizAvgOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
  }

  export type quizMaxOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    question?: SortOrder
    correctAnswer?: SortOrder
    isLocked?: SortOrder
  }

  export type quizMinOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    question?: SortOrder
    correctAnswer?: SortOrder
    isLocked?: SortOrder
  }

  export type quizSumOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
  }

  export type QuizScalarRelationFilter = {
    is?: quizWhereInput
    isNot?: quizWhereInput
  }

  export type quizsubmissionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    quizId?: SortOrder
    answers?: SortOrder
    score?: SortOrder
    totalQuestions?: SortOrder
    isPassed?: SortOrder
    createdAt?: SortOrder
  }

  export type quizsubmissionAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    quizId?: SortOrder
    score?: SortOrder
    totalQuestions?: SortOrder
  }

  export type quizsubmissionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    quizId?: SortOrder
    score?: SortOrder
    totalQuestions?: SortOrder
    isPassed?: SortOrder
    createdAt?: SortOrder
  }

  export type quizsubmissionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    quizId?: SortOrder
    score?: SortOrder
    totalQuestions?: SortOrder
    isPassed?: SortOrder
    createdAt?: SortOrder
  }

  export type quizsubmissionSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    quizId?: SortOrder
    score?: SortOrder
    totalQuestions?: SortOrder
  }

  export type roadmapOrderByRelevanceInput = {
    fields: roadmapOrderByRelevanceFieldEnum | roadmapOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type roadmapCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    rewardVoucher?: SortOrder
  }

  export type roadmapAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type roadmapMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    rewardVoucher?: SortOrder
  }

  export type roadmapMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    rewardVoucher?: SortOrder
  }

  export type roadmapSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RoadmapScalarRelationFilter = {
    is?: roadmapWhereInput
    isNot?: roadmapWhereInput
  }

  export type roadmapcourseCountOrderByAggregateInput = {
    id?: SortOrder
    roadmapId?: SortOrder
    courseId?: SortOrder
    order?: SortOrder
  }

  export type roadmapcourseAvgOrderByAggregateInput = {
    id?: SortOrder
    roadmapId?: SortOrder
    courseId?: SortOrder
    order?: SortOrder
  }

  export type roadmapcourseMaxOrderByAggregateInput = {
    id?: SortOrder
    roadmapId?: SortOrder
    courseId?: SortOrder
    order?: SortOrder
  }

  export type roadmapcourseMinOrderByAggregateInput = {
    id?: SortOrder
    roadmapId?: SortOrder
    courseId?: SortOrder
    order?: SortOrder
  }

  export type roadmapcourseSumOrderByAggregateInput = {
    id?: SortOrder
    roadmapId?: SortOrder
    courseId?: SortOrder
    order?: SortOrder
  }

  export type userroadmapCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roadmapId?: SortOrder
    isUnlocked?: SortOrder
    unlockedAt?: SortOrder
  }

  export type userroadmapAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roadmapId?: SortOrder
  }

  export type userroadmapMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roadmapId?: SortOrder
    isUnlocked?: SortOrder
    unlockedAt?: SortOrder
  }

  export type userroadmapMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roadmapId?: SortOrder
    isUnlocked?: SortOrder
    unlockedAt?: SortOrder
  }

  export type userroadmapSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roadmapId?: SortOrder
  }

  export type VoucherOrderByRelevanceInput = {
    fields: VoucherOrderByRelevanceFieldEnum | VoucherOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type VoucherCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    discount?: SortOrder
    expiresAt?: SortOrder
    userId?: SortOrder
    isUsed?: SortOrder
  }

  export type VoucherAvgOrderByAggregateInput = {
    id?: SortOrder
    discount?: SortOrder
    userId?: SortOrder
  }

  export type VoucherMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    discount?: SortOrder
    expiresAt?: SortOrder
    userId?: SortOrder
    isUsed?: SortOrder
  }

  export type VoucherMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    discount?: SortOrder
    expiresAt?: SortOrder
    userId?: SortOrder
    isUsed?: SortOrder
  }

  export type VoucherSumOrderByAggregateInput = {
    id?: SortOrder
    discount?: SortOrder
    userId?: SortOrder
  }

  export type assessmentCreateNestedManyWithoutUsersInput = {
    create?: XOR<assessmentCreateWithoutUsersInput, assessmentUncheckedCreateWithoutUsersInput> | assessmentCreateWithoutUsersInput[] | assessmentUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: assessmentCreateOrConnectWithoutUsersInput | assessmentCreateOrConnectWithoutUsersInput[]
    createMany?: assessmentCreateManyUsersInputEnvelope
    connect?: assessmentWhereUniqueInput | assessmentWhereUniqueInput[]
  }

  export type certificateCreateNestedManyWithoutUsersInput = {
    create?: XOR<certificateCreateWithoutUsersInput, certificateUncheckedCreateWithoutUsersInput> | certificateCreateWithoutUsersInput[] | certificateUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: certificateCreateOrConnectWithoutUsersInput | certificateCreateOrConnectWithoutUsersInput[]
    createMany?: certificateCreateManyUsersInputEnvelope
    connect?: certificateWhereUniqueInput | certificateWhereUniqueInput[]
  }

  export type chatmessageCreateNestedManyWithoutUsersInput = {
    create?: XOR<chatmessageCreateWithoutUsersInput, chatmessageUncheckedCreateWithoutUsersInput> | chatmessageCreateWithoutUsersInput[] | chatmessageUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: chatmessageCreateOrConnectWithoutUsersInput | chatmessageCreateOrConnectWithoutUsersInput[]
    createMany?: chatmessageCreateManyUsersInputEnvelope
    connect?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
  }

  export type counselingsessionCreateNestedManyWithoutUsersInput = {
    create?: XOR<counselingsessionCreateWithoutUsersInput, counselingsessionUncheckedCreateWithoutUsersInput> | counselingsessionCreateWithoutUsersInput[] | counselingsessionUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: counselingsessionCreateOrConnectWithoutUsersInput | counselingsessionCreateOrConnectWithoutUsersInput[]
    createMany?: counselingsessionCreateManyUsersInputEnvelope
    connect?: counselingsessionWhereUniqueInput | counselingsessionWhereUniqueInput[]
  }

  export type counselorCreateNestedOneWithoutUsersInput = {
    create?: XOR<counselorCreateWithoutUsersInput, counselorUncheckedCreateWithoutUsersInput>
    connectOrCreate?: counselorCreateOrConnectWithoutUsersInput
    connect?: counselorWhereUniqueInput
  }

  export type courseCreateNestedManyWithoutUsersInput = {
    create?: XOR<courseCreateWithoutUsersInput, courseUncheckedCreateWithoutUsersInput> | courseCreateWithoutUsersInput[] | courseUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: courseCreateOrConnectWithoutUsersInput | courseCreateOrConnectWithoutUsersInput[]
    createMany?: courseCreateManyUsersInputEnvelope
    connect?: courseWhereUniqueInput | courseWhereUniqueInput[]
  }

  export type courseprogressCreateNestedManyWithoutUsersInput = {
    create?: XOR<courseprogressCreateWithoutUsersInput, courseprogressUncheckedCreateWithoutUsersInput> | courseprogressCreateWithoutUsersInput[] | courseprogressUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: courseprogressCreateOrConnectWithoutUsersInput | courseprogressCreateOrConnectWithoutUsersInput[]
    createMany?: courseprogressCreateManyUsersInputEnvelope
    connect?: courseprogressWhereUniqueInput | courseprogressWhereUniqueInput[]
  }

  export type cvreviewCreateNestedManyWithoutUsersInput = {
    create?: XOR<cvreviewCreateWithoutUsersInput, cvreviewUncheckedCreateWithoutUsersInput> | cvreviewCreateWithoutUsersInput[] | cvreviewUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: cvreviewCreateOrConnectWithoutUsersInput | cvreviewCreateOrConnectWithoutUsersInput[]
    createMany?: cvreviewCreateManyUsersInputEnvelope
    connect?: cvreviewWhereUniqueInput | cvreviewWhereUniqueInput[]
  }

  export type enrollmentCreateNestedManyWithoutUsersInput = {
    create?: XOR<enrollmentCreateWithoutUsersInput, enrollmentUncheckedCreateWithoutUsersInput> | enrollmentCreateWithoutUsersInput[] | enrollmentUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: enrollmentCreateOrConnectWithoutUsersInput | enrollmentCreateOrConnectWithoutUsersInput[]
    createMany?: enrollmentCreateManyUsersInputEnvelope
    connect?: enrollmentWhereUniqueInput | enrollmentWhereUniqueInput[]
  }

  export type jobmatchCreateNestedManyWithoutUsersInput = {
    create?: XOR<jobmatchCreateWithoutUsersInput, jobmatchUncheckedCreateWithoutUsersInput> | jobmatchCreateWithoutUsersInput[] | jobmatchUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: jobmatchCreateOrConnectWithoutUsersInput | jobmatchCreateOrConnectWithoutUsersInput[]
    createMany?: jobmatchCreateManyUsersInputEnvelope
    connect?: jobmatchWhereUniqueInput | jobmatchWhereUniqueInput[]
  }

  export type lessonprogressCreateNestedManyWithoutUsersInput = {
    create?: XOR<lessonprogressCreateWithoutUsersInput, lessonprogressUncheckedCreateWithoutUsersInput> | lessonprogressCreateWithoutUsersInput[] | lessonprogressUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: lessonprogressCreateOrConnectWithoutUsersInput | lessonprogressCreateOrConnectWithoutUsersInput[]
    createMany?: lessonprogressCreateManyUsersInputEnvelope
    connect?: lessonprogressWhereUniqueInput | lessonprogressWhereUniqueInput[]
  }

  export type notificationCreateNestedManyWithoutUsersInput = {
    create?: XOR<notificationCreateWithoutUsersInput, notificationUncheckedCreateWithoutUsersInput> | notificationCreateWithoutUsersInput[] | notificationUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: notificationCreateOrConnectWithoutUsersInput | notificationCreateOrConnectWithoutUsersInput[]
    createMany?: notificationCreateManyUsersInputEnvelope
    connect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
  }

  export type paymentCreateNestedManyWithoutUsersInput = {
    create?: XOR<paymentCreateWithoutUsersInput, paymentUncheckedCreateWithoutUsersInput> | paymentCreateWithoutUsersInput[] | paymentUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: paymentCreateOrConnectWithoutUsersInput | paymentCreateOrConnectWithoutUsersInput[]
    createMany?: paymentCreateManyUsersInputEnvelope
    connect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
  }

  export type quizsubmissionCreateNestedManyWithoutUsersInput = {
    create?: XOR<quizsubmissionCreateWithoutUsersInput, quizsubmissionUncheckedCreateWithoutUsersInput> | quizsubmissionCreateWithoutUsersInput[] | quizsubmissionUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: quizsubmissionCreateOrConnectWithoutUsersInput | quizsubmissionCreateOrConnectWithoutUsersInput[]
    createMany?: quizsubmissionCreateManyUsersInputEnvelope
    connect?: quizsubmissionWhereUniqueInput | quizsubmissionWhereUniqueInput[]
  }

  export type userroadmapCreateNestedManyWithoutUsersInput = {
    create?: XOR<userroadmapCreateWithoutUsersInput, userroadmapUncheckedCreateWithoutUsersInput> | userroadmapCreateWithoutUsersInput[] | userroadmapUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: userroadmapCreateOrConnectWithoutUsersInput | userroadmapCreateOrConnectWithoutUsersInput[]
    createMany?: userroadmapCreateManyUsersInputEnvelope
    connect?: userroadmapWhereUniqueInput | userroadmapWhereUniqueInput[]
  }

  export type VoucherCreateNestedManyWithoutUsersInput = {
    create?: XOR<VoucherCreateWithoutUsersInput, VoucherUncheckedCreateWithoutUsersInput> | VoucherCreateWithoutUsersInput[] | VoucherUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: VoucherCreateOrConnectWithoutUsersInput | VoucherCreateOrConnectWithoutUsersInput[]
    createMany?: VoucherCreateManyUsersInputEnvelope
    connect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
  }

  export type assessmentUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<assessmentCreateWithoutUsersInput, assessmentUncheckedCreateWithoutUsersInput> | assessmentCreateWithoutUsersInput[] | assessmentUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: assessmentCreateOrConnectWithoutUsersInput | assessmentCreateOrConnectWithoutUsersInput[]
    createMany?: assessmentCreateManyUsersInputEnvelope
    connect?: assessmentWhereUniqueInput | assessmentWhereUniqueInput[]
  }

  export type certificateUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<certificateCreateWithoutUsersInput, certificateUncheckedCreateWithoutUsersInput> | certificateCreateWithoutUsersInput[] | certificateUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: certificateCreateOrConnectWithoutUsersInput | certificateCreateOrConnectWithoutUsersInput[]
    createMany?: certificateCreateManyUsersInputEnvelope
    connect?: certificateWhereUniqueInput | certificateWhereUniqueInput[]
  }

  export type chatmessageUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<chatmessageCreateWithoutUsersInput, chatmessageUncheckedCreateWithoutUsersInput> | chatmessageCreateWithoutUsersInput[] | chatmessageUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: chatmessageCreateOrConnectWithoutUsersInput | chatmessageCreateOrConnectWithoutUsersInput[]
    createMany?: chatmessageCreateManyUsersInputEnvelope
    connect?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
  }

  export type counselingsessionUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<counselingsessionCreateWithoutUsersInput, counselingsessionUncheckedCreateWithoutUsersInput> | counselingsessionCreateWithoutUsersInput[] | counselingsessionUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: counselingsessionCreateOrConnectWithoutUsersInput | counselingsessionCreateOrConnectWithoutUsersInput[]
    createMany?: counselingsessionCreateManyUsersInputEnvelope
    connect?: counselingsessionWhereUniqueInput | counselingsessionWhereUniqueInput[]
  }

  export type counselorUncheckedCreateNestedOneWithoutUsersInput = {
    create?: XOR<counselorCreateWithoutUsersInput, counselorUncheckedCreateWithoutUsersInput>
    connectOrCreate?: counselorCreateOrConnectWithoutUsersInput
    connect?: counselorWhereUniqueInput
  }

  export type courseUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<courseCreateWithoutUsersInput, courseUncheckedCreateWithoutUsersInput> | courseCreateWithoutUsersInput[] | courseUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: courseCreateOrConnectWithoutUsersInput | courseCreateOrConnectWithoutUsersInput[]
    createMany?: courseCreateManyUsersInputEnvelope
    connect?: courseWhereUniqueInput | courseWhereUniqueInput[]
  }

  export type courseprogressUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<courseprogressCreateWithoutUsersInput, courseprogressUncheckedCreateWithoutUsersInput> | courseprogressCreateWithoutUsersInput[] | courseprogressUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: courseprogressCreateOrConnectWithoutUsersInput | courseprogressCreateOrConnectWithoutUsersInput[]
    createMany?: courseprogressCreateManyUsersInputEnvelope
    connect?: courseprogressWhereUniqueInput | courseprogressWhereUniqueInput[]
  }

  export type cvreviewUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<cvreviewCreateWithoutUsersInput, cvreviewUncheckedCreateWithoutUsersInput> | cvreviewCreateWithoutUsersInput[] | cvreviewUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: cvreviewCreateOrConnectWithoutUsersInput | cvreviewCreateOrConnectWithoutUsersInput[]
    createMany?: cvreviewCreateManyUsersInputEnvelope
    connect?: cvreviewWhereUniqueInput | cvreviewWhereUniqueInput[]
  }

  export type enrollmentUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<enrollmentCreateWithoutUsersInput, enrollmentUncheckedCreateWithoutUsersInput> | enrollmentCreateWithoutUsersInput[] | enrollmentUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: enrollmentCreateOrConnectWithoutUsersInput | enrollmentCreateOrConnectWithoutUsersInput[]
    createMany?: enrollmentCreateManyUsersInputEnvelope
    connect?: enrollmentWhereUniqueInput | enrollmentWhereUniqueInput[]
  }

  export type jobmatchUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<jobmatchCreateWithoutUsersInput, jobmatchUncheckedCreateWithoutUsersInput> | jobmatchCreateWithoutUsersInput[] | jobmatchUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: jobmatchCreateOrConnectWithoutUsersInput | jobmatchCreateOrConnectWithoutUsersInput[]
    createMany?: jobmatchCreateManyUsersInputEnvelope
    connect?: jobmatchWhereUniqueInput | jobmatchWhereUniqueInput[]
  }

  export type lessonprogressUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<lessonprogressCreateWithoutUsersInput, lessonprogressUncheckedCreateWithoutUsersInput> | lessonprogressCreateWithoutUsersInput[] | lessonprogressUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: lessonprogressCreateOrConnectWithoutUsersInput | lessonprogressCreateOrConnectWithoutUsersInput[]
    createMany?: lessonprogressCreateManyUsersInputEnvelope
    connect?: lessonprogressWhereUniqueInput | lessonprogressWhereUniqueInput[]
  }

  export type notificationUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<notificationCreateWithoutUsersInput, notificationUncheckedCreateWithoutUsersInput> | notificationCreateWithoutUsersInput[] | notificationUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: notificationCreateOrConnectWithoutUsersInput | notificationCreateOrConnectWithoutUsersInput[]
    createMany?: notificationCreateManyUsersInputEnvelope
    connect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
  }

  export type paymentUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<paymentCreateWithoutUsersInput, paymentUncheckedCreateWithoutUsersInput> | paymentCreateWithoutUsersInput[] | paymentUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: paymentCreateOrConnectWithoutUsersInput | paymentCreateOrConnectWithoutUsersInput[]
    createMany?: paymentCreateManyUsersInputEnvelope
    connect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
  }

  export type quizsubmissionUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<quizsubmissionCreateWithoutUsersInput, quizsubmissionUncheckedCreateWithoutUsersInput> | quizsubmissionCreateWithoutUsersInput[] | quizsubmissionUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: quizsubmissionCreateOrConnectWithoutUsersInput | quizsubmissionCreateOrConnectWithoutUsersInput[]
    createMany?: quizsubmissionCreateManyUsersInputEnvelope
    connect?: quizsubmissionWhereUniqueInput | quizsubmissionWhereUniqueInput[]
  }

  export type userroadmapUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<userroadmapCreateWithoutUsersInput, userroadmapUncheckedCreateWithoutUsersInput> | userroadmapCreateWithoutUsersInput[] | userroadmapUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: userroadmapCreateOrConnectWithoutUsersInput | userroadmapCreateOrConnectWithoutUsersInput[]
    createMany?: userroadmapCreateManyUsersInputEnvelope
    connect?: userroadmapWhereUniqueInput | userroadmapWhereUniqueInput[]
  }

  export type VoucherUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<VoucherCreateWithoutUsersInput, VoucherUncheckedCreateWithoutUsersInput> | VoucherCreateWithoutUsersInput[] | VoucherUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: VoucherCreateOrConnectWithoutUsersInput | VoucherCreateOrConnectWithoutUsersInput[]
    createMany?: VoucherCreateManyUsersInputEnvelope
    connect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type assessmentUpdateManyWithoutUsersNestedInput = {
    create?: XOR<assessmentCreateWithoutUsersInput, assessmentUncheckedCreateWithoutUsersInput> | assessmentCreateWithoutUsersInput[] | assessmentUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: assessmentCreateOrConnectWithoutUsersInput | assessmentCreateOrConnectWithoutUsersInput[]
    upsert?: assessmentUpsertWithWhereUniqueWithoutUsersInput | assessmentUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: assessmentCreateManyUsersInputEnvelope
    set?: assessmentWhereUniqueInput | assessmentWhereUniqueInput[]
    disconnect?: assessmentWhereUniqueInput | assessmentWhereUniqueInput[]
    delete?: assessmentWhereUniqueInput | assessmentWhereUniqueInput[]
    connect?: assessmentWhereUniqueInput | assessmentWhereUniqueInput[]
    update?: assessmentUpdateWithWhereUniqueWithoutUsersInput | assessmentUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: assessmentUpdateManyWithWhereWithoutUsersInput | assessmentUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: assessmentScalarWhereInput | assessmentScalarWhereInput[]
  }

  export type certificateUpdateManyWithoutUsersNestedInput = {
    create?: XOR<certificateCreateWithoutUsersInput, certificateUncheckedCreateWithoutUsersInput> | certificateCreateWithoutUsersInput[] | certificateUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: certificateCreateOrConnectWithoutUsersInput | certificateCreateOrConnectWithoutUsersInput[]
    upsert?: certificateUpsertWithWhereUniqueWithoutUsersInput | certificateUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: certificateCreateManyUsersInputEnvelope
    set?: certificateWhereUniqueInput | certificateWhereUniqueInput[]
    disconnect?: certificateWhereUniqueInput | certificateWhereUniqueInput[]
    delete?: certificateWhereUniqueInput | certificateWhereUniqueInput[]
    connect?: certificateWhereUniqueInput | certificateWhereUniqueInput[]
    update?: certificateUpdateWithWhereUniqueWithoutUsersInput | certificateUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: certificateUpdateManyWithWhereWithoutUsersInput | certificateUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: certificateScalarWhereInput | certificateScalarWhereInput[]
  }

  export type chatmessageUpdateManyWithoutUsersNestedInput = {
    create?: XOR<chatmessageCreateWithoutUsersInput, chatmessageUncheckedCreateWithoutUsersInput> | chatmessageCreateWithoutUsersInput[] | chatmessageUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: chatmessageCreateOrConnectWithoutUsersInput | chatmessageCreateOrConnectWithoutUsersInput[]
    upsert?: chatmessageUpsertWithWhereUniqueWithoutUsersInput | chatmessageUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: chatmessageCreateManyUsersInputEnvelope
    set?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
    disconnect?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
    delete?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
    connect?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
    update?: chatmessageUpdateWithWhereUniqueWithoutUsersInput | chatmessageUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: chatmessageUpdateManyWithWhereWithoutUsersInput | chatmessageUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: chatmessageScalarWhereInput | chatmessageScalarWhereInput[]
  }

  export type counselingsessionUpdateManyWithoutUsersNestedInput = {
    create?: XOR<counselingsessionCreateWithoutUsersInput, counselingsessionUncheckedCreateWithoutUsersInput> | counselingsessionCreateWithoutUsersInput[] | counselingsessionUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: counselingsessionCreateOrConnectWithoutUsersInput | counselingsessionCreateOrConnectWithoutUsersInput[]
    upsert?: counselingsessionUpsertWithWhereUniqueWithoutUsersInput | counselingsessionUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: counselingsessionCreateManyUsersInputEnvelope
    set?: counselingsessionWhereUniqueInput | counselingsessionWhereUniqueInput[]
    disconnect?: counselingsessionWhereUniqueInput | counselingsessionWhereUniqueInput[]
    delete?: counselingsessionWhereUniqueInput | counselingsessionWhereUniqueInput[]
    connect?: counselingsessionWhereUniqueInput | counselingsessionWhereUniqueInput[]
    update?: counselingsessionUpdateWithWhereUniqueWithoutUsersInput | counselingsessionUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: counselingsessionUpdateManyWithWhereWithoutUsersInput | counselingsessionUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: counselingsessionScalarWhereInput | counselingsessionScalarWhereInput[]
  }

  export type counselorUpdateOneWithoutUsersNestedInput = {
    create?: XOR<counselorCreateWithoutUsersInput, counselorUncheckedCreateWithoutUsersInput>
    connectOrCreate?: counselorCreateOrConnectWithoutUsersInput
    upsert?: counselorUpsertWithoutUsersInput
    disconnect?: counselorWhereInput | boolean
    delete?: counselorWhereInput | boolean
    connect?: counselorWhereUniqueInput
    update?: XOR<XOR<counselorUpdateToOneWithWhereWithoutUsersInput, counselorUpdateWithoutUsersInput>, counselorUncheckedUpdateWithoutUsersInput>
  }

  export type courseUpdateManyWithoutUsersNestedInput = {
    create?: XOR<courseCreateWithoutUsersInput, courseUncheckedCreateWithoutUsersInput> | courseCreateWithoutUsersInput[] | courseUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: courseCreateOrConnectWithoutUsersInput | courseCreateOrConnectWithoutUsersInput[]
    upsert?: courseUpsertWithWhereUniqueWithoutUsersInput | courseUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: courseCreateManyUsersInputEnvelope
    set?: courseWhereUniqueInput | courseWhereUniqueInput[]
    disconnect?: courseWhereUniqueInput | courseWhereUniqueInput[]
    delete?: courseWhereUniqueInput | courseWhereUniqueInput[]
    connect?: courseWhereUniqueInput | courseWhereUniqueInput[]
    update?: courseUpdateWithWhereUniqueWithoutUsersInput | courseUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: courseUpdateManyWithWhereWithoutUsersInput | courseUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: courseScalarWhereInput | courseScalarWhereInput[]
  }

  export type courseprogressUpdateManyWithoutUsersNestedInput = {
    create?: XOR<courseprogressCreateWithoutUsersInput, courseprogressUncheckedCreateWithoutUsersInput> | courseprogressCreateWithoutUsersInput[] | courseprogressUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: courseprogressCreateOrConnectWithoutUsersInput | courseprogressCreateOrConnectWithoutUsersInput[]
    upsert?: courseprogressUpsertWithWhereUniqueWithoutUsersInput | courseprogressUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: courseprogressCreateManyUsersInputEnvelope
    set?: courseprogressWhereUniqueInput | courseprogressWhereUniqueInput[]
    disconnect?: courseprogressWhereUniqueInput | courseprogressWhereUniqueInput[]
    delete?: courseprogressWhereUniqueInput | courseprogressWhereUniqueInput[]
    connect?: courseprogressWhereUniqueInput | courseprogressWhereUniqueInput[]
    update?: courseprogressUpdateWithWhereUniqueWithoutUsersInput | courseprogressUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: courseprogressUpdateManyWithWhereWithoutUsersInput | courseprogressUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: courseprogressScalarWhereInput | courseprogressScalarWhereInput[]
  }

  export type cvreviewUpdateManyWithoutUsersNestedInput = {
    create?: XOR<cvreviewCreateWithoutUsersInput, cvreviewUncheckedCreateWithoutUsersInput> | cvreviewCreateWithoutUsersInput[] | cvreviewUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: cvreviewCreateOrConnectWithoutUsersInput | cvreviewCreateOrConnectWithoutUsersInput[]
    upsert?: cvreviewUpsertWithWhereUniqueWithoutUsersInput | cvreviewUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: cvreviewCreateManyUsersInputEnvelope
    set?: cvreviewWhereUniqueInput | cvreviewWhereUniqueInput[]
    disconnect?: cvreviewWhereUniqueInput | cvreviewWhereUniqueInput[]
    delete?: cvreviewWhereUniqueInput | cvreviewWhereUniqueInput[]
    connect?: cvreviewWhereUniqueInput | cvreviewWhereUniqueInput[]
    update?: cvreviewUpdateWithWhereUniqueWithoutUsersInput | cvreviewUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: cvreviewUpdateManyWithWhereWithoutUsersInput | cvreviewUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: cvreviewScalarWhereInput | cvreviewScalarWhereInput[]
  }

  export type enrollmentUpdateManyWithoutUsersNestedInput = {
    create?: XOR<enrollmentCreateWithoutUsersInput, enrollmentUncheckedCreateWithoutUsersInput> | enrollmentCreateWithoutUsersInput[] | enrollmentUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: enrollmentCreateOrConnectWithoutUsersInput | enrollmentCreateOrConnectWithoutUsersInput[]
    upsert?: enrollmentUpsertWithWhereUniqueWithoutUsersInput | enrollmentUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: enrollmentCreateManyUsersInputEnvelope
    set?: enrollmentWhereUniqueInput | enrollmentWhereUniqueInput[]
    disconnect?: enrollmentWhereUniqueInput | enrollmentWhereUniqueInput[]
    delete?: enrollmentWhereUniqueInput | enrollmentWhereUniqueInput[]
    connect?: enrollmentWhereUniqueInput | enrollmentWhereUniqueInput[]
    update?: enrollmentUpdateWithWhereUniqueWithoutUsersInput | enrollmentUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: enrollmentUpdateManyWithWhereWithoutUsersInput | enrollmentUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: enrollmentScalarWhereInput | enrollmentScalarWhereInput[]
  }

  export type jobmatchUpdateManyWithoutUsersNestedInput = {
    create?: XOR<jobmatchCreateWithoutUsersInput, jobmatchUncheckedCreateWithoutUsersInput> | jobmatchCreateWithoutUsersInput[] | jobmatchUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: jobmatchCreateOrConnectWithoutUsersInput | jobmatchCreateOrConnectWithoutUsersInput[]
    upsert?: jobmatchUpsertWithWhereUniqueWithoutUsersInput | jobmatchUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: jobmatchCreateManyUsersInputEnvelope
    set?: jobmatchWhereUniqueInput | jobmatchWhereUniqueInput[]
    disconnect?: jobmatchWhereUniqueInput | jobmatchWhereUniqueInput[]
    delete?: jobmatchWhereUniqueInput | jobmatchWhereUniqueInput[]
    connect?: jobmatchWhereUniqueInput | jobmatchWhereUniqueInput[]
    update?: jobmatchUpdateWithWhereUniqueWithoutUsersInput | jobmatchUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: jobmatchUpdateManyWithWhereWithoutUsersInput | jobmatchUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: jobmatchScalarWhereInput | jobmatchScalarWhereInput[]
  }

  export type lessonprogressUpdateManyWithoutUsersNestedInput = {
    create?: XOR<lessonprogressCreateWithoutUsersInput, lessonprogressUncheckedCreateWithoutUsersInput> | lessonprogressCreateWithoutUsersInput[] | lessonprogressUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: lessonprogressCreateOrConnectWithoutUsersInput | lessonprogressCreateOrConnectWithoutUsersInput[]
    upsert?: lessonprogressUpsertWithWhereUniqueWithoutUsersInput | lessonprogressUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: lessonprogressCreateManyUsersInputEnvelope
    set?: lessonprogressWhereUniqueInput | lessonprogressWhereUniqueInput[]
    disconnect?: lessonprogressWhereUniqueInput | lessonprogressWhereUniqueInput[]
    delete?: lessonprogressWhereUniqueInput | lessonprogressWhereUniqueInput[]
    connect?: lessonprogressWhereUniqueInput | lessonprogressWhereUniqueInput[]
    update?: lessonprogressUpdateWithWhereUniqueWithoutUsersInput | lessonprogressUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: lessonprogressUpdateManyWithWhereWithoutUsersInput | lessonprogressUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: lessonprogressScalarWhereInput | lessonprogressScalarWhereInput[]
  }

  export type notificationUpdateManyWithoutUsersNestedInput = {
    create?: XOR<notificationCreateWithoutUsersInput, notificationUncheckedCreateWithoutUsersInput> | notificationCreateWithoutUsersInput[] | notificationUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: notificationCreateOrConnectWithoutUsersInput | notificationCreateOrConnectWithoutUsersInput[]
    upsert?: notificationUpsertWithWhereUniqueWithoutUsersInput | notificationUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: notificationCreateManyUsersInputEnvelope
    set?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    disconnect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    delete?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    connect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    update?: notificationUpdateWithWhereUniqueWithoutUsersInput | notificationUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: notificationUpdateManyWithWhereWithoutUsersInput | notificationUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: notificationScalarWhereInput | notificationScalarWhereInput[]
  }

  export type paymentUpdateManyWithoutUsersNestedInput = {
    create?: XOR<paymentCreateWithoutUsersInput, paymentUncheckedCreateWithoutUsersInput> | paymentCreateWithoutUsersInput[] | paymentUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: paymentCreateOrConnectWithoutUsersInput | paymentCreateOrConnectWithoutUsersInput[]
    upsert?: paymentUpsertWithWhereUniqueWithoutUsersInput | paymentUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: paymentCreateManyUsersInputEnvelope
    set?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    disconnect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    delete?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    connect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    update?: paymentUpdateWithWhereUniqueWithoutUsersInput | paymentUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: paymentUpdateManyWithWhereWithoutUsersInput | paymentUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: paymentScalarWhereInput | paymentScalarWhereInput[]
  }

  export type quizsubmissionUpdateManyWithoutUsersNestedInput = {
    create?: XOR<quizsubmissionCreateWithoutUsersInput, quizsubmissionUncheckedCreateWithoutUsersInput> | quizsubmissionCreateWithoutUsersInput[] | quizsubmissionUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: quizsubmissionCreateOrConnectWithoutUsersInput | quizsubmissionCreateOrConnectWithoutUsersInput[]
    upsert?: quizsubmissionUpsertWithWhereUniqueWithoutUsersInput | quizsubmissionUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: quizsubmissionCreateManyUsersInputEnvelope
    set?: quizsubmissionWhereUniqueInput | quizsubmissionWhereUniqueInput[]
    disconnect?: quizsubmissionWhereUniqueInput | quizsubmissionWhereUniqueInput[]
    delete?: quizsubmissionWhereUniqueInput | quizsubmissionWhereUniqueInput[]
    connect?: quizsubmissionWhereUniqueInput | quizsubmissionWhereUniqueInput[]
    update?: quizsubmissionUpdateWithWhereUniqueWithoutUsersInput | quizsubmissionUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: quizsubmissionUpdateManyWithWhereWithoutUsersInput | quizsubmissionUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: quizsubmissionScalarWhereInput | quizsubmissionScalarWhereInput[]
  }

  export type userroadmapUpdateManyWithoutUsersNestedInput = {
    create?: XOR<userroadmapCreateWithoutUsersInput, userroadmapUncheckedCreateWithoutUsersInput> | userroadmapCreateWithoutUsersInput[] | userroadmapUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: userroadmapCreateOrConnectWithoutUsersInput | userroadmapCreateOrConnectWithoutUsersInput[]
    upsert?: userroadmapUpsertWithWhereUniqueWithoutUsersInput | userroadmapUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: userroadmapCreateManyUsersInputEnvelope
    set?: userroadmapWhereUniqueInput | userroadmapWhereUniqueInput[]
    disconnect?: userroadmapWhereUniqueInput | userroadmapWhereUniqueInput[]
    delete?: userroadmapWhereUniqueInput | userroadmapWhereUniqueInput[]
    connect?: userroadmapWhereUniqueInput | userroadmapWhereUniqueInput[]
    update?: userroadmapUpdateWithWhereUniqueWithoutUsersInput | userroadmapUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: userroadmapUpdateManyWithWhereWithoutUsersInput | userroadmapUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: userroadmapScalarWhereInput | userroadmapScalarWhereInput[]
  }

  export type VoucherUpdateManyWithoutUsersNestedInput = {
    create?: XOR<VoucherCreateWithoutUsersInput, VoucherUncheckedCreateWithoutUsersInput> | VoucherCreateWithoutUsersInput[] | VoucherUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: VoucherCreateOrConnectWithoutUsersInput | VoucherCreateOrConnectWithoutUsersInput[]
    upsert?: VoucherUpsertWithWhereUniqueWithoutUsersInput | VoucherUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: VoucherCreateManyUsersInputEnvelope
    set?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    disconnect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    delete?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    connect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    update?: VoucherUpdateWithWhereUniqueWithoutUsersInput | VoucherUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: VoucherUpdateManyWithWhereWithoutUsersInput | VoucherUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: VoucherScalarWhereInput | VoucherScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type assessmentUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<assessmentCreateWithoutUsersInput, assessmentUncheckedCreateWithoutUsersInput> | assessmentCreateWithoutUsersInput[] | assessmentUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: assessmentCreateOrConnectWithoutUsersInput | assessmentCreateOrConnectWithoutUsersInput[]
    upsert?: assessmentUpsertWithWhereUniqueWithoutUsersInput | assessmentUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: assessmentCreateManyUsersInputEnvelope
    set?: assessmentWhereUniqueInput | assessmentWhereUniqueInput[]
    disconnect?: assessmentWhereUniqueInput | assessmentWhereUniqueInput[]
    delete?: assessmentWhereUniqueInput | assessmentWhereUniqueInput[]
    connect?: assessmentWhereUniqueInput | assessmentWhereUniqueInput[]
    update?: assessmentUpdateWithWhereUniqueWithoutUsersInput | assessmentUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: assessmentUpdateManyWithWhereWithoutUsersInput | assessmentUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: assessmentScalarWhereInput | assessmentScalarWhereInput[]
  }

  export type certificateUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<certificateCreateWithoutUsersInput, certificateUncheckedCreateWithoutUsersInput> | certificateCreateWithoutUsersInput[] | certificateUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: certificateCreateOrConnectWithoutUsersInput | certificateCreateOrConnectWithoutUsersInput[]
    upsert?: certificateUpsertWithWhereUniqueWithoutUsersInput | certificateUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: certificateCreateManyUsersInputEnvelope
    set?: certificateWhereUniqueInput | certificateWhereUniqueInput[]
    disconnect?: certificateWhereUniqueInput | certificateWhereUniqueInput[]
    delete?: certificateWhereUniqueInput | certificateWhereUniqueInput[]
    connect?: certificateWhereUniqueInput | certificateWhereUniqueInput[]
    update?: certificateUpdateWithWhereUniqueWithoutUsersInput | certificateUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: certificateUpdateManyWithWhereWithoutUsersInput | certificateUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: certificateScalarWhereInput | certificateScalarWhereInput[]
  }

  export type chatmessageUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<chatmessageCreateWithoutUsersInput, chatmessageUncheckedCreateWithoutUsersInput> | chatmessageCreateWithoutUsersInput[] | chatmessageUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: chatmessageCreateOrConnectWithoutUsersInput | chatmessageCreateOrConnectWithoutUsersInput[]
    upsert?: chatmessageUpsertWithWhereUniqueWithoutUsersInput | chatmessageUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: chatmessageCreateManyUsersInputEnvelope
    set?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
    disconnect?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
    delete?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
    connect?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
    update?: chatmessageUpdateWithWhereUniqueWithoutUsersInput | chatmessageUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: chatmessageUpdateManyWithWhereWithoutUsersInput | chatmessageUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: chatmessageScalarWhereInput | chatmessageScalarWhereInput[]
  }

  export type counselingsessionUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<counselingsessionCreateWithoutUsersInput, counselingsessionUncheckedCreateWithoutUsersInput> | counselingsessionCreateWithoutUsersInput[] | counselingsessionUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: counselingsessionCreateOrConnectWithoutUsersInput | counselingsessionCreateOrConnectWithoutUsersInput[]
    upsert?: counselingsessionUpsertWithWhereUniqueWithoutUsersInput | counselingsessionUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: counselingsessionCreateManyUsersInputEnvelope
    set?: counselingsessionWhereUniqueInput | counselingsessionWhereUniqueInput[]
    disconnect?: counselingsessionWhereUniqueInput | counselingsessionWhereUniqueInput[]
    delete?: counselingsessionWhereUniqueInput | counselingsessionWhereUniqueInput[]
    connect?: counselingsessionWhereUniqueInput | counselingsessionWhereUniqueInput[]
    update?: counselingsessionUpdateWithWhereUniqueWithoutUsersInput | counselingsessionUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: counselingsessionUpdateManyWithWhereWithoutUsersInput | counselingsessionUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: counselingsessionScalarWhereInput | counselingsessionScalarWhereInput[]
  }

  export type counselorUncheckedUpdateOneWithoutUsersNestedInput = {
    create?: XOR<counselorCreateWithoutUsersInput, counselorUncheckedCreateWithoutUsersInput>
    connectOrCreate?: counselorCreateOrConnectWithoutUsersInput
    upsert?: counselorUpsertWithoutUsersInput
    disconnect?: counselorWhereInput | boolean
    delete?: counselorWhereInput | boolean
    connect?: counselorWhereUniqueInput
    update?: XOR<XOR<counselorUpdateToOneWithWhereWithoutUsersInput, counselorUpdateWithoutUsersInput>, counselorUncheckedUpdateWithoutUsersInput>
  }

  export type courseUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<courseCreateWithoutUsersInput, courseUncheckedCreateWithoutUsersInput> | courseCreateWithoutUsersInput[] | courseUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: courseCreateOrConnectWithoutUsersInput | courseCreateOrConnectWithoutUsersInput[]
    upsert?: courseUpsertWithWhereUniqueWithoutUsersInput | courseUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: courseCreateManyUsersInputEnvelope
    set?: courseWhereUniqueInput | courseWhereUniqueInput[]
    disconnect?: courseWhereUniqueInput | courseWhereUniqueInput[]
    delete?: courseWhereUniqueInput | courseWhereUniqueInput[]
    connect?: courseWhereUniqueInput | courseWhereUniqueInput[]
    update?: courseUpdateWithWhereUniqueWithoutUsersInput | courseUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: courseUpdateManyWithWhereWithoutUsersInput | courseUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: courseScalarWhereInput | courseScalarWhereInput[]
  }

  export type courseprogressUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<courseprogressCreateWithoutUsersInput, courseprogressUncheckedCreateWithoutUsersInput> | courseprogressCreateWithoutUsersInput[] | courseprogressUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: courseprogressCreateOrConnectWithoutUsersInput | courseprogressCreateOrConnectWithoutUsersInput[]
    upsert?: courseprogressUpsertWithWhereUniqueWithoutUsersInput | courseprogressUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: courseprogressCreateManyUsersInputEnvelope
    set?: courseprogressWhereUniqueInput | courseprogressWhereUniqueInput[]
    disconnect?: courseprogressWhereUniqueInput | courseprogressWhereUniqueInput[]
    delete?: courseprogressWhereUniqueInput | courseprogressWhereUniqueInput[]
    connect?: courseprogressWhereUniqueInput | courseprogressWhereUniqueInput[]
    update?: courseprogressUpdateWithWhereUniqueWithoutUsersInput | courseprogressUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: courseprogressUpdateManyWithWhereWithoutUsersInput | courseprogressUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: courseprogressScalarWhereInput | courseprogressScalarWhereInput[]
  }

  export type cvreviewUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<cvreviewCreateWithoutUsersInput, cvreviewUncheckedCreateWithoutUsersInput> | cvreviewCreateWithoutUsersInput[] | cvreviewUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: cvreviewCreateOrConnectWithoutUsersInput | cvreviewCreateOrConnectWithoutUsersInput[]
    upsert?: cvreviewUpsertWithWhereUniqueWithoutUsersInput | cvreviewUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: cvreviewCreateManyUsersInputEnvelope
    set?: cvreviewWhereUniqueInput | cvreviewWhereUniqueInput[]
    disconnect?: cvreviewWhereUniqueInput | cvreviewWhereUniqueInput[]
    delete?: cvreviewWhereUniqueInput | cvreviewWhereUniqueInput[]
    connect?: cvreviewWhereUniqueInput | cvreviewWhereUniqueInput[]
    update?: cvreviewUpdateWithWhereUniqueWithoutUsersInput | cvreviewUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: cvreviewUpdateManyWithWhereWithoutUsersInput | cvreviewUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: cvreviewScalarWhereInput | cvreviewScalarWhereInput[]
  }

  export type enrollmentUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<enrollmentCreateWithoutUsersInput, enrollmentUncheckedCreateWithoutUsersInput> | enrollmentCreateWithoutUsersInput[] | enrollmentUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: enrollmentCreateOrConnectWithoutUsersInput | enrollmentCreateOrConnectWithoutUsersInput[]
    upsert?: enrollmentUpsertWithWhereUniqueWithoutUsersInput | enrollmentUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: enrollmentCreateManyUsersInputEnvelope
    set?: enrollmentWhereUniqueInput | enrollmentWhereUniqueInput[]
    disconnect?: enrollmentWhereUniqueInput | enrollmentWhereUniqueInput[]
    delete?: enrollmentWhereUniqueInput | enrollmentWhereUniqueInput[]
    connect?: enrollmentWhereUniqueInput | enrollmentWhereUniqueInput[]
    update?: enrollmentUpdateWithWhereUniqueWithoutUsersInput | enrollmentUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: enrollmentUpdateManyWithWhereWithoutUsersInput | enrollmentUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: enrollmentScalarWhereInput | enrollmentScalarWhereInput[]
  }

  export type jobmatchUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<jobmatchCreateWithoutUsersInput, jobmatchUncheckedCreateWithoutUsersInput> | jobmatchCreateWithoutUsersInput[] | jobmatchUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: jobmatchCreateOrConnectWithoutUsersInput | jobmatchCreateOrConnectWithoutUsersInput[]
    upsert?: jobmatchUpsertWithWhereUniqueWithoutUsersInput | jobmatchUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: jobmatchCreateManyUsersInputEnvelope
    set?: jobmatchWhereUniqueInput | jobmatchWhereUniqueInput[]
    disconnect?: jobmatchWhereUniqueInput | jobmatchWhereUniqueInput[]
    delete?: jobmatchWhereUniqueInput | jobmatchWhereUniqueInput[]
    connect?: jobmatchWhereUniqueInput | jobmatchWhereUniqueInput[]
    update?: jobmatchUpdateWithWhereUniqueWithoutUsersInput | jobmatchUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: jobmatchUpdateManyWithWhereWithoutUsersInput | jobmatchUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: jobmatchScalarWhereInput | jobmatchScalarWhereInput[]
  }

  export type lessonprogressUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<lessonprogressCreateWithoutUsersInput, lessonprogressUncheckedCreateWithoutUsersInput> | lessonprogressCreateWithoutUsersInput[] | lessonprogressUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: lessonprogressCreateOrConnectWithoutUsersInput | lessonprogressCreateOrConnectWithoutUsersInput[]
    upsert?: lessonprogressUpsertWithWhereUniqueWithoutUsersInput | lessonprogressUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: lessonprogressCreateManyUsersInputEnvelope
    set?: lessonprogressWhereUniqueInput | lessonprogressWhereUniqueInput[]
    disconnect?: lessonprogressWhereUniqueInput | lessonprogressWhereUniqueInput[]
    delete?: lessonprogressWhereUniqueInput | lessonprogressWhereUniqueInput[]
    connect?: lessonprogressWhereUniqueInput | lessonprogressWhereUniqueInput[]
    update?: lessonprogressUpdateWithWhereUniqueWithoutUsersInput | lessonprogressUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: lessonprogressUpdateManyWithWhereWithoutUsersInput | lessonprogressUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: lessonprogressScalarWhereInput | lessonprogressScalarWhereInput[]
  }

  export type notificationUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<notificationCreateWithoutUsersInput, notificationUncheckedCreateWithoutUsersInput> | notificationCreateWithoutUsersInput[] | notificationUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: notificationCreateOrConnectWithoutUsersInput | notificationCreateOrConnectWithoutUsersInput[]
    upsert?: notificationUpsertWithWhereUniqueWithoutUsersInput | notificationUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: notificationCreateManyUsersInputEnvelope
    set?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    disconnect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    delete?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    connect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    update?: notificationUpdateWithWhereUniqueWithoutUsersInput | notificationUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: notificationUpdateManyWithWhereWithoutUsersInput | notificationUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: notificationScalarWhereInput | notificationScalarWhereInput[]
  }

  export type paymentUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<paymentCreateWithoutUsersInput, paymentUncheckedCreateWithoutUsersInput> | paymentCreateWithoutUsersInput[] | paymentUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: paymentCreateOrConnectWithoutUsersInput | paymentCreateOrConnectWithoutUsersInput[]
    upsert?: paymentUpsertWithWhereUniqueWithoutUsersInput | paymentUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: paymentCreateManyUsersInputEnvelope
    set?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    disconnect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    delete?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    connect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    update?: paymentUpdateWithWhereUniqueWithoutUsersInput | paymentUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: paymentUpdateManyWithWhereWithoutUsersInput | paymentUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: paymentScalarWhereInput | paymentScalarWhereInput[]
  }

  export type quizsubmissionUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<quizsubmissionCreateWithoutUsersInput, quizsubmissionUncheckedCreateWithoutUsersInput> | quizsubmissionCreateWithoutUsersInput[] | quizsubmissionUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: quizsubmissionCreateOrConnectWithoutUsersInput | quizsubmissionCreateOrConnectWithoutUsersInput[]
    upsert?: quizsubmissionUpsertWithWhereUniqueWithoutUsersInput | quizsubmissionUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: quizsubmissionCreateManyUsersInputEnvelope
    set?: quizsubmissionWhereUniqueInput | quizsubmissionWhereUniqueInput[]
    disconnect?: quizsubmissionWhereUniqueInput | quizsubmissionWhereUniqueInput[]
    delete?: quizsubmissionWhereUniqueInput | quizsubmissionWhereUniqueInput[]
    connect?: quizsubmissionWhereUniqueInput | quizsubmissionWhereUniqueInput[]
    update?: quizsubmissionUpdateWithWhereUniqueWithoutUsersInput | quizsubmissionUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: quizsubmissionUpdateManyWithWhereWithoutUsersInput | quizsubmissionUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: quizsubmissionScalarWhereInput | quizsubmissionScalarWhereInput[]
  }

  export type userroadmapUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<userroadmapCreateWithoutUsersInput, userroadmapUncheckedCreateWithoutUsersInput> | userroadmapCreateWithoutUsersInput[] | userroadmapUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: userroadmapCreateOrConnectWithoutUsersInput | userroadmapCreateOrConnectWithoutUsersInput[]
    upsert?: userroadmapUpsertWithWhereUniqueWithoutUsersInput | userroadmapUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: userroadmapCreateManyUsersInputEnvelope
    set?: userroadmapWhereUniqueInput | userroadmapWhereUniqueInput[]
    disconnect?: userroadmapWhereUniqueInput | userroadmapWhereUniqueInput[]
    delete?: userroadmapWhereUniqueInput | userroadmapWhereUniqueInput[]
    connect?: userroadmapWhereUniqueInput | userroadmapWhereUniqueInput[]
    update?: userroadmapUpdateWithWhereUniqueWithoutUsersInput | userroadmapUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: userroadmapUpdateManyWithWhereWithoutUsersInput | userroadmapUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: userroadmapScalarWhereInput | userroadmapScalarWhereInput[]
  }

  export type VoucherUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<VoucherCreateWithoutUsersInput, VoucherUncheckedCreateWithoutUsersInput> | VoucherCreateWithoutUsersInput[] | VoucherUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: VoucherCreateOrConnectWithoutUsersInput | VoucherCreateOrConnectWithoutUsersInput[]
    upsert?: VoucherUpsertWithWhereUniqueWithoutUsersInput | VoucherUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: VoucherCreateManyUsersInputEnvelope
    set?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    disconnect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    delete?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    connect?: VoucherWhereUniqueInput | VoucherWhereUniqueInput[]
    update?: VoucherUpdateWithWhereUniqueWithoutUsersInput | VoucherUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: VoucherUpdateManyWithWhereWithoutUsersInput | VoucherUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: VoucherScalarWhereInput | VoucherScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAssessmentInput = {
    create?: XOR<UserCreateWithoutAssessmentInput, UserUncheckedCreateWithoutAssessmentInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssessmentInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAssessmentNestedInput = {
    create?: XOR<UserCreateWithoutAssessmentInput, UserUncheckedCreateWithoutAssessmentInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssessmentInput
    upsert?: UserUpsertWithoutAssessmentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssessmentInput, UserUpdateWithoutAssessmentInput>, UserUncheckedUpdateWithoutAssessmentInput>
  }

  export type courseCreateNestedManyWithoutCategoryInput = {
    create?: XOR<courseCreateWithoutCategoryInput, courseUncheckedCreateWithoutCategoryInput> | courseCreateWithoutCategoryInput[] | courseUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: courseCreateOrConnectWithoutCategoryInput | courseCreateOrConnectWithoutCategoryInput[]
    createMany?: courseCreateManyCategoryInputEnvelope
    connect?: courseWhereUniqueInput | courseWhereUniqueInput[]
  }

  export type courseUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<courseCreateWithoutCategoryInput, courseUncheckedCreateWithoutCategoryInput> | courseCreateWithoutCategoryInput[] | courseUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: courseCreateOrConnectWithoutCategoryInput | courseCreateOrConnectWithoutCategoryInput[]
    createMany?: courseCreateManyCategoryInputEnvelope
    connect?: courseWhereUniqueInput | courseWhereUniqueInput[]
  }

  export type courseUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<courseCreateWithoutCategoryInput, courseUncheckedCreateWithoutCategoryInput> | courseCreateWithoutCategoryInput[] | courseUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: courseCreateOrConnectWithoutCategoryInput | courseCreateOrConnectWithoutCategoryInput[]
    upsert?: courseUpsertWithWhereUniqueWithoutCategoryInput | courseUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: courseCreateManyCategoryInputEnvelope
    set?: courseWhereUniqueInput | courseWhereUniqueInput[]
    disconnect?: courseWhereUniqueInput | courseWhereUniqueInput[]
    delete?: courseWhereUniqueInput | courseWhereUniqueInput[]
    connect?: courseWhereUniqueInput | courseWhereUniqueInput[]
    update?: courseUpdateWithWhereUniqueWithoutCategoryInput | courseUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: courseUpdateManyWithWhereWithoutCategoryInput | courseUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: courseScalarWhereInput | courseScalarWhereInput[]
  }

  export type courseUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<courseCreateWithoutCategoryInput, courseUncheckedCreateWithoutCategoryInput> | courseCreateWithoutCategoryInput[] | courseUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: courseCreateOrConnectWithoutCategoryInput | courseCreateOrConnectWithoutCategoryInput[]
    upsert?: courseUpsertWithWhereUniqueWithoutCategoryInput | courseUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: courseCreateManyCategoryInputEnvelope
    set?: courseWhereUniqueInput | courseWhereUniqueInput[]
    disconnect?: courseWhereUniqueInput | courseWhereUniqueInput[]
    delete?: courseWhereUniqueInput | courseWhereUniqueInput[]
    connect?: courseWhereUniqueInput | courseWhereUniqueInput[]
    update?: courseUpdateWithWhereUniqueWithoutCategoryInput | courseUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: courseUpdateManyWithWhereWithoutCategoryInput | courseUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: courseScalarWhereInput | courseScalarWhereInput[]
  }

  export type courseCreateNestedOneWithoutCertificateInput = {
    create?: XOR<courseCreateWithoutCertificateInput, courseUncheckedCreateWithoutCertificateInput>
    connectOrCreate?: courseCreateOrConnectWithoutCertificateInput
    connect?: courseWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCertificateInput = {
    create?: XOR<UserCreateWithoutCertificateInput, UserUncheckedCreateWithoutCertificateInput>
    connectOrCreate?: UserCreateOrConnectWithoutCertificateInput
    connect?: UserWhereUniqueInput
  }

  export type courseUpdateOneRequiredWithoutCertificateNestedInput = {
    create?: XOR<courseCreateWithoutCertificateInput, courseUncheckedCreateWithoutCertificateInput>
    connectOrCreate?: courseCreateOrConnectWithoutCertificateInput
    upsert?: courseUpsertWithoutCertificateInput
    connect?: courseWhereUniqueInput
    update?: XOR<XOR<courseUpdateToOneWithWhereWithoutCertificateInput, courseUpdateWithoutCertificateInput>, courseUncheckedUpdateWithoutCertificateInput>
  }

  export type UserUpdateOneRequiredWithoutCertificateNestedInput = {
    create?: XOR<UserCreateWithoutCertificateInput, UserUncheckedCreateWithoutCertificateInput>
    connectOrCreate?: UserCreateOrConnectWithoutCertificateInput
    upsert?: UserUpsertWithoutCertificateInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCertificateInput, UserUpdateWithoutCertificateInput>, UserUncheckedUpdateWithoutCertificateInput>
  }

  export type UserCreateNestedOneWithoutChatmessageInput = {
    create?: XOR<UserCreateWithoutChatmessageInput, UserUncheckedCreateWithoutChatmessageInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatmessageInput
    connect?: UserWhereUniqueInput
  }

  export type counselingsessionCreateNestedOneWithoutChatmessageInput = {
    create?: XOR<counselingsessionCreateWithoutChatmessageInput, counselingsessionUncheckedCreateWithoutChatmessageInput>
    connectOrCreate?: counselingsessionCreateOrConnectWithoutChatmessageInput
    connect?: counselingsessionWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutChatmessageNestedInput = {
    create?: XOR<UserCreateWithoutChatmessageInput, UserUncheckedCreateWithoutChatmessageInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatmessageInput
    upsert?: UserUpsertWithoutChatmessageInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChatmessageInput, UserUpdateWithoutChatmessageInput>, UserUncheckedUpdateWithoutChatmessageInput>
  }

  export type counselingsessionUpdateOneRequiredWithoutChatmessageNestedInput = {
    create?: XOR<counselingsessionCreateWithoutChatmessageInput, counselingsessionUncheckedCreateWithoutChatmessageInput>
    connectOrCreate?: counselingsessionCreateOrConnectWithoutChatmessageInput
    upsert?: counselingsessionUpsertWithoutChatmessageInput
    connect?: counselingsessionWhereUniqueInput
    update?: XOR<XOR<counselingsessionUpdateToOneWithWhereWithoutChatmessageInput, counselingsessionUpdateWithoutChatmessageInput>, counselingsessionUncheckedUpdateWithoutChatmessageInput>
  }

  export type chatmessageCreateNestedManyWithoutCounselingsessionInput = {
    create?: XOR<chatmessageCreateWithoutCounselingsessionInput, chatmessageUncheckedCreateWithoutCounselingsessionInput> | chatmessageCreateWithoutCounselingsessionInput[] | chatmessageUncheckedCreateWithoutCounselingsessionInput[]
    connectOrCreate?: chatmessageCreateOrConnectWithoutCounselingsessionInput | chatmessageCreateOrConnectWithoutCounselingsessionInput[]
    createMany?: chatmessageCreateManyCounselingsessionInputEnvelope
    connect?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
  }

  export type counselorCreateNestedOneWithoutCounselingsessionInput = {
    create?: XOR<counselorCreateWithoutCounselingsessionInput, counselorUncheckedCreateWithoutCounselingsessionInput>
    connectOrCreate?: counselorCreateOrConnectWithoutCounselingsessionInput
    connect?: counselorWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCounselingsessionInput = {
    create?: XOR<UserCreateWithoutCounselingsessionInput, UserUncheckedCreateWithoutCounselingsessionInput>
    connectOrCreate?: UserCreateOrConnectWithoutCounselingsessionInput
    connect?: UserWhereUniqueInput
  }

  export type chatmessageUncheckedCreateNestedManyWithoutCounselingsessionInput = {
    create?: XOR<chatmessageCreateWithoutCounselingsessionInput, chatmessageUncheckedCreateWithoutCounselingsessionInput> | chatmessageCreateWithoutCounselingsessionInput[] | chatmessageUncheckedCreateWithoutCounselingsessionInput[]
    connectOrCreate?: chatmessageCreateOrConnectWithoutCounselingsessionInput | chatmessageCreateOrConnectWithoutCounselingsessionInput[]
    createMany?: chatmessageCreateManyCounselingsessionInputEnvelope
    connect?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type chatmessageUpdateManyWithoutCounselingsessionNestedInput = {
    create?: XOR<chatmessageCreateWithoutCounselingsessionInput, chatmessageUncheckedCreateWithoutCounselingsessionInput> | chatmessageCreateWithoutCounselingsessionInput[] | chatmessageUncheckedCreateWithoutCounselingsessionInput[]
    connectOrCreate?: chatmessageCreateOrConnectWithoutCounselingsessionInput | chatmessageCreateOrConnectWithoutCounselingsessionInput[]
    upsert?: chatmessageUpsertWithWhereUniqueWithoutCounselingsessionInput | chatmessageUpsertWithWhereUniqueWithoutCounselingsessionInput[]
    createMany?: chatmessageCreateManyCounselingsessionInputEnvelope
    set?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
    disconnect?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
    delete?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
    connect?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
    update?: chatmessageUpdateWithWhereUniqueWithoutCounselingsessionInput | chatmessageUpdateWithWhereUniqueWithoutCounselingsessionInput[]
    updateMany?: chatmessageUpdateManyWithWhereWithoutCounselingsessionInput | chatmessageUpdateManyWithWhereWithoutCounselingsessionInput[]
    deleteMany?: chatmessageScalarWhereInput | chatmessageScalarWhereInput[]
  }

  export type counselorUpdateOneRequiredWithoutCounselingsessionNestedInput = {
    create?: XOR<counselorCreateWithoutCounselingsessionInput, counselorUncheckedCreateWithoutCounselingsessionInput>
    connectOrCreate?: counselorCreateOrConnectWithoutCounselingsessionInput
    upsert?: counselorUpsertWithoutCounselingsessionInput
    connect?: counselorWhereUniqueInput
    update?: XOR<XOR<counselorUpdateToOneWithWhereWithoutCounselingsessionInput, counselorUpdateWithoutCounselingsessionInput>, counselorUncheckedUpdateWithoutCounselingsessionInput>
  }

  export type UserUpdateOneRequiredWithoutCounselingsessionNestedInput = {
    create?: XOR<UserCreateWithoutCounselingsessionInput, UserUncheckedCreateWithoutCounselingsessionInput>
    connectOrCreate?: UserCreateOrConnectWithoutCounselingsessionInput
    upsert?: UserUpsertWithoutCounselingsessionInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCounselingsessionInput, UserUpdateWithoutCounselingsessionInput>, UserUncheckedUpdateWithoutCounselingsessionInput>
  }

  export type chatmessageUncheckedUpdateManyWithoutCounselingsessionNestedInput = {
    create?: XOR<chatmessageCreateWithoutCounselingsessionInput, chatmessageUncheckedCreateWithoutCounselingsessionInput> | chatmessageCreateWithoutCounselingsessionInput[] | chatmessageUncheckedCreateWithoutCounselingsessionInput[]
    connectOrCreate?: chatmessageCreateOrConnectWithoutCounselingsessionInput | chatmessageCreateOrConnectWithoutCounselingsessionInput[]
    upsert?: chatmessageUpsertWithWhereUniqueWithoutCounselingsessionInput | chatmessageUpsertWithWhereUniqueWithoutCounselingsessionInput[]
    createMany?: chatmessageCreateManyCounselingsessionInputEnvelope
    set?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
    disconnect?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
    delete?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
    connect?: chatmessageWhereUniqueInput | chatmessageWhereUniqueInput[]
    update?: chatmessageUpdateWithWhereUniqueWithoutCounselingsessionInput | chatmessageUpdateWithWhereUniqueWithoutCounselingsessionInput[]
    updateMany?: chatmessageUpdateManyWithWhereWithoutCounselingsessionInput | chatmessageUpdateManyWithWhereWithoutCounselingsessionInput[]
    deleteMany?: chatmessageScalarWhereInput | chatmessageScalarWhereInput[]
  }

  export type counselingsessionCreateNestedManyWithoutCounselorInput = {
    create?: XOR<counselingsessionCreateWithoutCounselorInput, counselingsessionUncheckedCreateWithoutCounselorInput> | counselingsessionCreateWithoutCounselorInput[] | counselingsessionUncheckedCreateWithoutCounselorInput[]
    connectOrCreate?: counselingsessionCreateOrConnectWithoutCounselorInput | counselingsessionCreateOrConnectWithoutCounselorInput[]
    createMany?: counselingsessionCreateManyCounselorInputEnvelope
    connect?: counselingsessionWhereUniqueInput | counselingsessionWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutCounselorInput = {
    create?: XOR<UserCreateWithoutCounselorInput, UserUncheckedCreateWithoutCounselorInput>
    connectOrCreate?: UserCreateOrConnectWithoutCounselorInput
    connect?: UserWhereUniqueInput
  }

  export type counselingsessionUncheckedCreateNestedManyWithoutCounselorInput = {
    create?: XOR<counselingsessionCreateWithoutCounselorInput, counselingsessionUncheckedCreateWithoutCounselorInput> | counselingsessionCreateWithoutCounselorInput[] | counselingsessionUncheckedCreateWithoutCounselorInput[]
    connectOrCreate?: counselingsessionCreateOrConnectWithoutCounselorInput | counselingsessionCreateOrConnectWithoutCounselorInput[]
    createMany?: counselingsessionCreateManyCounselorInputEnvelope
    connect?: counselingsessionWhereUniqueInput | counselingsessionWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type counselingsessionUpdateManyWithoutCounselorNestedInput = {
    create?: XOR<counselingsessionCreateWithoutCounselorInput, counselingsessionUncheckedCreateWithoutCounselorInput> | counselingsessionCreateWithoutCounselorInput[] | counselingsessionUncheckedCreateWithoutCounselorInput[]
    connectOrCreate?: counselingsessionCreateOrConnectWithoutCounselorInput | counselingsessionCreateOrConnectWithoutCounselorInput[]
    upsert?: counselingsessionUpsertWithWhereUniqueWithoutCounselorInput | counselingsessionUpsertWithWhereUniqueWithoutCounselorInput[]
    createMany?: counselingsessionCreateManyCounselorInputEnvelope
    set?: counselingsessionWhereUniqueInput | counselingsessionWhereUniqueInput[]
    disconnect?: counselingsessionWhereUniqueInput | counselingsessionWhereUniqueInput[]
    delete?: counselingsessionWhereUniqueInput | counselingsessionWhereUniqueInput[]
    connect?: counselingsessionWhereUniqueInput | counselingsessionWhereUniqueInput[]
    update?: counselingsessionUpdateWithWhereUniqueWithoutCounselorInput | counselingsessionUpdateWithWhereUniqueWithoutCounselorInput[]
    updateMany?: counselingsessionUpdateManyWithWhereWithoutCounselorInput | counselingsessionUpdateManyWithWhereWithoutCounselorInput[]
    deleteMany?: counselingsessionScalarWhereInput | counselingsessionScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutCounselorNestedInput = {
    create?: XOR<UserCreateWithoutCounselorInput, UserUncheckedCreateWithoutCounselorInput>
    connectOrCreate?: UserCreateOrConnectWithoutCounselorInput
    upsert?: UserUpsertWithoutCounselorInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCounselorInput, UserUpdateWithoutCounselorInput>, UserUncheckedUpdateWithoutCounselorInput>
  }

  export type counselingsessionUncheckedUpdateManyWithoutCounselorNestedInput = {
    create?: XOR<counselingsessionCreateWithoutCounselorInput, counselingsessionUncheckedCreateWithoutCounselorInput> | counselingsessionCreateWithoutCounselorInput[] | counselingsessionUncheckedCreateWithoutCounselorInput[]
    connectOrCreate?: counselingsessionCreateOrConnectWithoutCounselorInput | counselingsessionCreateOrConnectWithoutCounselorInput[]
    upsert?: counselingsessionUpsertWithWhereUniqueWithoutCounselorInput | counselingsessionUpsertWithWhereUniqueWithoutCounselorInput[]
    createMany?: counselingsessionCreateManyCounselorInputEnvelope
    set?: counselingsessionWhereUniqueInput | counselingsessionWhereUniqueInput[]
    disconnect?: counselingsessionWhereUniqueInput | counselingsessionWhereUniqueInput[]
    delete?: counselingsessionWhereUniqueInput | counselingsessionWhereUniqueInput[]
    connect?: counselingsessionWhereUniqueInput | counselingsessionWhereUniqueInput[]
    update?: counselingsessionUpdateWithWhereUniqueWithoutCounselorInput | counselingsessionUpdateWithWhereUniqueWithoutCounselorInput[]
    updateMany?: counselingsessionUpdateManyWithWhereWithoutCounselorInput | counselingsessionUpdateManyWithWhereWithoutCounselorInput[]
    deleteMany?: counselingsessionScalarWhereInput | counselingsessionScalarWhereInput[]
  }

  export type certificateCreateNestedManyWithoutCourseInput = {
    create?: XOR<certificateCreateWithoutCourseInput, certificateUncheckedCreateWithoutCourseInput> | certificateCreateWithoutCourseInput[] | certificateUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: certificateCreateOrConnectWithoutCourseInput | certificateCreateOrConnectWithoutCourseInput[]
    createMany?: certificateCreateManyCourseInputEnvelope
    connect?: certificateWhereUniqueInput | certificateWhereUniqueInput[]
  }

  export type categoryCreateNestedOneWithoutCourseInput = {
    create?: XOR<categoryCreateWithoutCourseInput, categoryUncheckedCreateWithoutCourseInput>
    connectOrCreate?: categoryCreateOrConnectWithoutCourseInput
    connect?: categoryWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCourseInput = {
    create?: XOR<UserCreateWithoutCourseInput, UserUncheckedCreateWithoutCourseInput>
    connectOrCreate?: UserCreateOrConnectWithoutCourseInput
    connect?: UserWhereUniqueInput
  }

  export type courseprogressCreateNestedManyWithoutCourseInput = {
    create?: XOR<courseprogressCreateWithoutCourseInput, courseprogressUncheckedCreateWithoutCourseInput> | courseprogressCreateWithoutCourseInput[] | courseprogressUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: courseprogressCreateOrConnectWithoutCourseInput | courseprogressCreateOrConnectWithoutCourseInput[]
    createMany?: courseprogressCreateManyCourseInputEnvelope
    connect?: courseprogressWhereUniqueInput | courseprogressWhereUniqueInput[]
  }

  export type coursevideoCreateNestedManyWithoutCourseInput = {
    create?: XOR<coursevideoCreateWithoutCourseInput, coursevideoUncheckedCreateWithoutCourseInput> | coursevideoCreateWithoutCourseInput[] | coursevideoUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: coursevideoCreateOrConnectWithoutCourseInput | coursevideoCreateOrConnectWithoutCourseInput[]
    createMany?: coursevideoCreateManyCourseInputEnvelope
    connect?: coursevideoWhereUniqueInput | coursevideoWhereUniqueInput[]
  }

  export type enrollmentCreateNestedManyWithoutCourseInput = {
    create?: XOR<enrollmentCreateWithoutCourseInput, enrollmentUncheckedCreateWithoutCourseInput> | enrollmentCreateWithoutCourseInput[] | enrollmentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: enrollmentCreateOrConnectWithoutCourseInput | enrollmentCreateOrConnectWithoutCourseInput[]
    createMany?: enrollmentCreateManyCourseInputEnvelope
    connect?: enrollmentWhereUniqueInput | enrollmentWhereUniqueInput[]
  }

  export type lessonCreateNestedManyWithoutCourseInput = {
    create?: XOR<lessonCreateWithoutCourseInput, lessonUncheckedCreateWithoutCourseInput> | lessonCreateWithoutCourseInput[] | lessonUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: lessonCreateOrConnectWithoutCourseInput | lessonCreateOrConnectWithoutCourseInput[]
    createMany?: lessonCreateManyCourseInputEnvelope
    connect?: lessonWhereUniqueInput | lessonWhereUniqueInput[]
  }

  export type paymentCreateNestedManyWithoutCourseInput = {
    create?: XOR<paymentCreateWithoutCourseInput, paymentUncheckedCreateWithoutCourseInput> | paymentCreateWithoutCourseInput[] | paymentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: paymentCreateOrConnectWithoutCourseInput | paymentCreateOrConnectWithoutCourseInput[]
    createMany?: paymentCreateManyCourseInputEnvelope
    connect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
  }

  export type quizCreateNestedManyWithoutCourseInput = {
    create?: XOR<quizCreateWithoutCourseInput, quizUncheckedCreateWithoutCourseInput> | quizCreateWithoutCourseInput[] | quizUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: quizCreateOrConnectWithoutCourseInput | quizCreateOrConnectWithoutCourseInput[]
    createMany?: quizCreateManyCourseInputEnvelope
    connect?: quizWhereUniqueInput | quizWhereUniqueInput[]
  }

  export type quizsubmissionCreateNestedManyWithoutCourseInput = {
    create?: XOR<quizsubmissionCreateWithoutCourseInput, quizsubmissionUncheckedCreateWithoutCourseInput> | quizsubmissionCreateWithoutCourseInput[] | quizsubmissionUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: quizsubmissionCreateOrConnectWithoutCourseInput | quizsubmissionCreateOrConnectWithoutCourseInput[]
    createMany?: quizsubmissionCreateManyCourseInputEnvelope
    connect?: quizsubmissionWhereUniqueInput | quizsubmissionWhereUniqueInput[]
  }

  export type roadmapcourseCreateNestedManyWithoutCourseInput = {
    create?: XOR<roadmapcourseCreateWithoutCourseInput, roadmapcourseUncheckedCreateWithoutCourseInput> | roadmapcourseCreateWithoutCourseInput[] | roadmapcourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: roadmapcourseCreateOrConnectWithoutCourseInput | roadmapcourseCreateOrConnectWithoutCourseInput[]
    createMany?: roadmapcourseCreateManyCourseInputEnvelope
    connect?: roadmapcourseWhereUniqueInput | roadmapcourseWhereUniqueInput[]
  }

  export type certificateUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<certificateCreateWithoutCourseInput, certificateUncheckedCreateWithoutCourseInput> | certificateCreateWithoutCourseInput[] | certificateUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: certificateCreateOrConnectWithoutCourseInput | certificateCreateOrConnectWithoutCourseInput[]
    createMany?: certificateCreateManyCourseInputEnvelope
    connect?: certificateWhereUniqueInput | certificateWhereUniqueInput[]
  }

  export type courseprogressUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<courseprogressCreateWithoutCourseInput, courseprogressUncheckedCreateWithoutCourseInput> | courseprogressCreateWithoutCourseInput[] | courseprogressUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: courseprogressCreateOrConnectWithoutCourseInput | courseprogressCreateOrConnectWithoutCourseInput[]
    createMany?: courseprogressCreateManyCourseInputEnvelope
    connect?: courseprogressWhereUniqueInput | courseprogressWhereUniqueInput[]
  }

  export type coursevideoUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<coursevideoCreateWithoutCourseInput, coursevideoUncheckedCreateWithoutCourseInput> | coursevideoCreateWithoutCourseInput[] | coursevideoUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: coursevideoCreateOrConnectWithoutCourseInput | coursevideoCreateOrConnectWithoutCourseInput[]
    createMany?: coursevideoCreateManyCourseInputEnvelope
    connect?: coursevideoWhereUniqueInput | coursevideoWhereUniqueInput[]
  }

  export type enrollmentUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<enrollmentCreateWithoutCourseInput, enrollmentUncheckedCreateWithoutCourseInput> | enrollmentCreateWithoutCourseInput[] | enrollmentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: enrollmentCreateOrConnectWithoutCourseInput | enrollmentCreateOrConnectWithoutCourseInput[]
    createMany?: enrollmentCreateManyCourseInputEnvelope
    connect?: enrollmentWhereUniqueInput | enrollmentWhereUniqueInput[]
  }

  export type lessonUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<lessonCreateWithoutCourseInput, lessonUncheckedCreateWithoutCourseInput> | lessonCreateWithoutCourseInput[] | lessonUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: lessonCreateOrConnectWithoutCourseInput | lessonCreateOrConnectWithoutCourseInput[]
    createMany?: lessonCreateManyCourseInputEnvelope
    connect?: lessonWhereUniqueInput | lessonWhereUniqueInput[]
  }

  export type paymentUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<paymentCreateWithoutCourseInput, paymentUncheckedCreateWithoutCourseInput> | paymentCreateWithoutCourseInput[] | paymentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: paymentCreateOrConnectWithoutCourseInput | paymentCreateOrConnectWithoutCourseInput[]
    createMany?: paymentCreateManyCourseInputEnvelope
    connect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
  }

  export type quizUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<quizCreateWithoutCourseInput, quizUncheckedCreateWithoutCourseInput> | quizCreateWithoutCourseInput[] | quizUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: quizCreateOrConnectWithoutCourseInput | quizCreateOrConnectWithoutCourseInput[]
    createMany?: quizCreateManyCourseInputEnvelope
    connect?: quizWhereUniqueInput | quizWhereUniqueInput[]
  }

  export type quizsubmissionUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<quizsubmissionCreateWithoutCourseInput, quizsubmissionUncheckedCreateWithoutCourseInput> | quizsubmissionCreateWithoutCourseInput[] | quizsubmissionUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: quizsubmissionCreateOrConnectWithoutCourseInput | quizsubmissionCreateOrConnectWithoutCourseInput[]
    createMany?: quizsubmissionCreateManyCourseInputEnvelope
    connect?: quizsubmissionWhereUniqueInput | quizsubmissionWhereUniqueInput[]
  }

  export type roadmapcourseUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<roadmapcourseCreateWithoutCourseInput, roadmapcourseUncheckedCreateWithoutCourseInput> | roadmapcourseCreateWithoutCourseInput[] | roadmapcourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: roadmapcourseCreateOrConnectWithoutCourseInput | roadmapcourseCreateOrConnectWithoutCourseInput[]
    createMany?: roadmapcourseCreateManyCourseInputEnvelope
    connect?: roadmapcourseWhereUniqueInput | roadmapcourseWhereUniqueInput[]
  }

  export type certificateUpdateManyWithoutCourseNestedInput = {
    create?: XOR<certificateCreateWithoutCourseInput, certificateUncheckedCreateWithoutCourseInput> | certificateCreateWithoutCourseInput[] | certificateUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: certificateCreateOrConnectWithoutCourseInput | certificateCreateOrConnectWithoutCourseInput[]
    upsert?: certificateUpsertWithWhereUniqueWithoutCourseInput | certificateUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: certificateCreateManyCourseInputEnvelope
    set?: certificateWhereUniqueInput | certificateWhereUniqueInput[]
    disconnect?: certificateWhereUniqueInput | certificateWhereUniqueInput[]
    delete?: certificateWhereUniqueInput | certificateWhereUniqueInput[]
    connect?: certificateWhereUniqueInput | certificateWhereUniqueInput[]
    update?: certificateUpdateWithWhereUniqueWithoutCourseInput | certificateUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: certificateUpdateManyWithWhereWithoutCourseInput | certificateUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: certificateScalarWhereInput | certificateScalarWhereInput[]
  }

  export type categoryUpdateOneRequiredWithoutCourseNestedInput = {
    create?: XOR<categoryCreateWithoutCourseInput, categoryUncheckedCreateWithoutCourseInput>
    connectOrCreate?: categoryCreateOrConnectWithoutCourseInput
    upsert?: categoryUpsertWithoutCourseInput
    connect?: categoryWhereUniqueInput
    update?: XOR<XOR<categoryUpdateToOneWithWhereWithoutCourseInput, categoryUpdateWithoutCourseInput>, categoryUncheckedUpdateWithoutCourseInput>
  }

  export type UserUpdateOneRequiredWithoutCourseNestedInput = {
    create?: XOR<UserCreateWithoutCourseInput, UserUncheckedCreateWithoutCourseInput>
    connectOrCreate?: UserCreateOrConnectWithoutCourseInput
    upsert?: UserUpsertWithoutCourseInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCourseInput, UserUpdateWithoutCourseInput>, UserUncheckedUpdateWithoutCourseInput>
  }

  export type courseprogressUpdateManyWithoutCourseNestedInput = {
    create?: XOR<courseprogressCreateWithoutCourseInput, courseprogressUncheckedCreateWithoutCourseInput> | courseprogressCreateWithoutCourseInput[] | courseprogressUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: courseprogressCreateOrConnectWithoutCourseInput | courseprogressCreateOrConnectWithoutCourseInput[]
    upsert?: courseprogressUpsertWithWhereUniqueWithoutCourseInput | courseprogressUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: courseprogressCreateManyCourseInputEnvelope
    set?: courseprogressWhereUniqueInput | courseprogressWhereUniqueInput[]
    disconnect?: courseprogressWhereUniqueInput | courseprogressWhereUniqueInput[]
    delete?: courseprogressWhereUniqueInput | courseprogressWhereUniqueInput[]
    connect?: courseprogressWhereUniqueInput | courseprogressWhereUniqueInput[]
    update?: courseprogressUpdateWithWhereUniqueWithoutCourseInput | courseprogressUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: courseprogressUpdateManyWithWhereWithoutCourseInput | courseprogressUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: courseprogressScalarWhereInput | courseprogressScalarWhereInput[]
  }

  export type coursevideoUpdateManyWithoutCourseNestedInput = {
    create?: XOR<coursevideoCreateWithoutCourseInput, coursevideoUncheckedCreateWithoutCourseInput> | coursevideoCreateWithoutCourseInput[] | coursevideoUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: coursevideoCreateOrConnectWithoutCourseInput | coursevideoCreateOrConnectWithoutCourseInput[]
    upsert?: coursevideoUpsertWithWhereUniqueWithoutCourseInput | coursevideoUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: coursevideoCreateManyCourseInputEnvelope
    set?: coursevideoWhereUniqueInput | coursevideoWhereUniqueInput[]
    disconnect?: coursevideoWhereUniqueInput | coursevideoWhereUniqueInput[]
    delete?: coursevideoWhereUniqueInput | coursevideoWhereUniqueInput[]
    connect?: coursevideoWhereUniqueInput | coursevideoWhereUniqueInput[]
    update?: coursevideoUpdateWithWhereUniqueWithoutCourseInput | coursevideoUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: coursevideoUpdateManyWithWhereWithoutCourseInput | coursevideoUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: coursevideoScalarWhereInput | coursevideoScalarWhereInput[]
  }

  export type enrollmentUpdateManyWithoutCourseNestedInput = {
    create?: XOR<enrollmentCreateWithoutCourseInput, enrollmentUncheckedCreateWithoutCourseInput> | enrollmentCreateWithoutCourseInput[] | enrollmentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: enrollmentCreateOrConnectWithoutCourseInput | enrollmentCreateOrConnectWithoutCourseInput[]
    upsert?: enrollmentUpsertWithWhereUniqueWithoutCourseInput | enrollmentUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: enrollmentCreateManyCourseInputEnvelope
    set?: enrollmentWhereUniqueInput | enrollmentWhereUniqueInput[]
    disconnect?: enrollmentWhereUniqueInput | enrollmentWhereUniqueInput[]
    delete?: enrollmentWhereUniqueInput | enrollmentWhereUniqueInput[]
    connect?: enrollmentWhereUniqueInput | enrollmentWhereUniqueInput[]
    update?: enrollmentUpdateWithWhereUniqueWithoutCourseInput | enrollmentUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: enrollmentUpdateManyWithWhereWithoutCourseInput | enrollmentUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: enrollmentScalarWhereInput | enrollmentScalarWhereInput[]
  }

  export type lessonUpdateManyWithoutCourseNestedInput = {
    create?: XOR<lessonCreateWithoutCourseInput, lessonUncheckedCreateWithoutCourseInput> | lessonCreateWithoutCourseInput[] | lessonUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: lessonCreateOrConnectWithoutCourseInput | lessonCreateOrConnectWithoutCourseInput[]
    upsert?: lessonUpsertWithWhereUniqueWithoutCourseInput | lessonUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: lessonCreateManyCourseInputEnvelope
    set?: lessonWhereUniqueInput | lessonWhereUniqueInput[]
    disconnect?: lessonWhereUniqueInput | lessonWhereUniqueInput[]
    delete?: lessonWhereUniqueInput | lessonWhereUniqueInput[]
    connect?: lessonWhereUniqueInput | lessonWhereUniqueInput[]
    update?: lessonUpdateWithWhereUniqueWithoutCourseInput | lessonUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: lessonUpdateManyWithWhereWithoutCourseInput | lessonUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: lessonScalarWhereInput | lessonScalarWhereInput[]
  }

  export type paymentUpdateManyWithoutCourseNestedInput = {
    create?: XOR<paymentCreateWithoutCourseInput, paymentUncheckedCreateWithoutCourseInput> | paymentCreateWithoutCourseInput[] | paymentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: paymentCreateOrConnectWithoutCourseInput | paymentCreateOrConnectWithoutCourseInput[]
    upsert?: paymentUpsertWithWhereUniqueWithoutCourseInput | paymentUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: paymentCreateManyCourseInputEnvelope
    set?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    disconnect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    delete?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    connect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    update?: paymentUpdateWithWhereUniqueWithoutCourseInput | paymentUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: paymentUpdateManyWithWhereWithoutCourseInput | paymentUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: paymentScalarWhereInput | paymentScalarWhereInput[]
  }

  export type quizUpdateManyWithoutCourseNestedInput = {
    create?: XOR<quizCreateWithoutCourseInput, quizUncheckedCreateWithoutCourseInput> | quizCreateWithoutCourseInput[] | quizUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: quizCreateOrConnectWithoutCourseInput | quizCreateOrConnectWithoutCourseInput[]
    upsert?: quizUpsertWithWhereUniqueWithoutCourseInput | quizUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: quizCreateManyCourseInputEnvelope
    set?: quizWhereUniqueInput | quizWhereUniqueInput[]
    disconnect?: quizWhereUniqueInput | quizWhereUniqueInput[]
    delete?: quizWhereUniqueInput | quizWhereUniqueInput[]
    connect?: quizWhereUniqueInput | quizWhereUniqueInput[]
    update?: quizUpdateWithWhereUniqueWithoutCourseInput | quizUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: quizUpdateManyWithWhereWithoutCourseInput | quizUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: quizScalarWhereInput | quizScalarWhereInput[]
  }

  export type quizsubmissionUpdateManyWithoutCourseNestedInput = {
    create?: XOR<quizsubmissionCreateWithoutCourseInput, quizsubmissionUncheckedCreateWithoutCourseInput> | quizsubmissionCreateWithoutCourseInput[] | quizsubmissionUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: quizsubmissionCreateOrConnectWithoutCourseInput | quizsubmissionCreateOrConnectWithoutCourseInput[]
    upsert?: quizsubmissionUpsertWithWhereUniqueWithoutCourseInput | quizsubmissionUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: quizsubmissionCreateManyCourseInputEnvelope
    set?: quizsubmissionWhereUniqueInput | quizsubmissionWhereUniqueInput[]
    disconnect?: quizsubmissionWhereUniqueInput | quizsubmissionWhereUniqueInput[]
    delete?: quizsubmissionWhereUniqueInput | quizsubmissionWhereUniqueInput[]
    connect?: quizsubmissionWhereUniqueInput | quizsubmissionWhereUniqueInput[]
    update?: quizsubmissionUpdateWithWhereUniqueWithoutCourseInput | quizsubmissionUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: quizsubmissionUpdateManyWithWhereWithoutCourseInput | quizsubmissionUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: quizsubmissionScalarWhereInput | quizsubmissionScalarWhereInput[]
  }

  export type roadmapcourseUpdateManyWithoutCourseNestedInput = {
    create?: XOR<roadmapcourseCreateWithoutCourseInput, roadmapcourseUncheckedCreateWithoutCourseInput> | roadmapcourseCreateWithoutCourseInput[] | roadmapcourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: roadmapcourseCreateOrConnectWithoutCourseInput | roadmapcourseCreateOrConnectWithoutCourseInput[]
    upsert?: roadmapcourseUpsertWithWhereUniqueWithoutCourseInput | roadmapcourseUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: roadmapcourseCreateManyCourseInputEnvelope
    set?: roadmapcourseWhereUniqueInput | roadmapcourseWhereUniqueInput[]
    disconnect?: roadmapcourseWhereUniqueInput | roadmapcourseWhereUniqueInput[]
    delete?: roadmapcourseWhereUniqueInput | roadmapcourseWhereUniqueInput[]
    connect?: roadmapcourseWhereUniqueInput | roadmapcourseWhereUniqueInput[]
    update?: roadmapcourseUpdateWithWhereUniqueWithoutCourseInput | roadmapcourseUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: roadmapcourseUpdateManyWithWhereWithoutCourseInput | roadmapcourseUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: roadmapcourseScalarWhereInput | roadmapcourseScalarWhereInput[]
  }

  export type certificateUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<certificateCreateWithoutCourseInput, certificateUncheckedCreateWithoutCourseInput> | certificateCreateWithoutCourseInput[] | certificateUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: certificateCreateOrConnectWithoutCourseInput | certificateCreateOrConnectWithoutCourseInput[]
    upsert?: certificateUpsertWithWhereUniqueWithoutCourseInput | certificateUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: certificateCreateManyCourseInputEnvelope
    set?: certificateWhereUniqueInput | certificateWhereUniqueInput[]
    disconnect?: certificateWhereUniqueInput | certificateWhereUniqueInput[]
    delete?: certificateWhereUniqueInput | certificateWhereUniqueInput[]
    connect?: certificateWhereUniqueInput | certificateWhereUniqueInput[]
    update?: certificateUpdateWithWhereUniqueWithoutCourseInput | certificateUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: certificateUpdateManyWithWhereWithoutCourseInput | certificateUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: certificateScalarWhereInput | certificateScalarWhereInput[]
  }

  export type courseprogressUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<courseprogressCreateWithoutCourseInput, courseprogressUncheckedCreateWithoutCourseInput> | courseprogressCreateWithoutCourseInput[] | courseprogressUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: courseprogressCreateOrConnectWithoutCourseInput | courseprogressCreateOrConnectWithoutCourseInput[]
    upsert?: courseprogressUpsertWithWhereUniqueWithoutCourseInput | courseprogressUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: courseprogressCreateManyCourseInputEnvelope
    set?: courseprogressWhereUniqueInput | courseprogressWhereUniqueInput[]
    disconnect?: courseprogressWhereUniqueInput | courseprogressWhereUniqueInput[]
    delete?: courseprogressWhereUniqueInput | courseprogressWhereUniqueInput[]
    connect?: courseprogressWhereUniqueInput | courseprogressWhereUniqueInput[]
    update?: courseprogressUpdateWithWhereUniqueWithoutCourseInput | courseprogressUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: courseprogressUpdateManyWithWhereWithoutCourseInput | courseprogressUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: courseprogressScalarWhereInput | courseprogressScalarWhereInput[]
  }

  export type coursevideoUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<coursevideoCreateWithoutCourseInput, coursevideoUncheckedCreateWithoutCourseInput> | coursevideoCreateWithoutCourseInput[] | coursevideoUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: coursevideoCreateOrConnectWithoutCourseInput | coursevideoCreateOrConnectWithoutCourseInput[]
    upsert?: coursevideoUpsertWithWhereUniqueWithoutCourseInput | coursevideoUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: coursevideoCreateManyCourseInputEnvelope
    set?: coursevideoWhereUniqueInput | coursevideoWhereUniqueInput[]
    disconnect?: coursevideoWhereUniqueInput | coursevideoWhereUniqueInput[]
    delete?: coursevideoWhereUniqueInput | coursevideoWhereUniqueInput[]
    connect?: coursevideoWhereUniqueInput | coursevideoWhereUniqueInput[]
    update?: coursevideoUpdateWithWhereUniqueWithoutCourseInput | coursevideoUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: coursevideoUpdateManyWithWhereWithoutCourseInput | coursevideoUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: coursevideoScalarWhereInput | coursevideoScalarWhereInput[]
  }

  export type enrollmentUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<enrollmentCreateWithoutCourseInput, enrollmentUncheckedCreateWithoutCourseInput> | enrollmentCreateWithoutCourseInput[] | enrollmentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: enrollmentCreateOrConnectWithoutCourseInput | enrollmentCreateOrConnectWithoutCourseInput[]
    upsert?: enrollmentUpsertWithWhereUniqueWithoutCourseInput | enrollmentUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: enrollmentCreateManyCourseInputEnvelope
    set?: enrollmentWhereUniqueInput | enrollmentWhereUniqueInput[]
    disconnect?: enrollmentWhereUniqueInput | enrollmentWhereUniqueInput[]
    delete?: enrollmentWhereUniqueInput | enrollmentWhereUniqueInput[]
    connect?: enrollmentWhereUniqueInput | enrollmentWhereUniqueInput[]
    update?: enrollmentUpdateWithWhereUniqueWithoutCourseInput | enrollmentUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: enrollmentUpdateManyWithWhereWithoutCourseInput | enrollmentUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: enrollmentScalarWhereInput | enrollmentScalarWhereInput[]
  }

  export type lessonUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<lessonCreateWithoutCourseInput, lessonUncheckedCreateWithoutCourseInput> | lessonCreateWithoutCourseInput[] | lessonUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: lessonCreateOrConnectWithoutCourseInput | lessonCreateOrConnectWithoutCourseInput[]
    upsert?: lessonUpsertWithWhereUniqueWithoutCourseInput | lessonUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: lessonCreateManyCourseInputEnvelope
    set?: lessonWhereUniqueInput | lessonWhereUniqueInput[]
    disconnect?: lessonWhereUniqueInput | lessonWhereUniqueInput[]
    delete?: lessonWhereUniqueInput | lessonWhereUniqueInput[]
    connect?: lessonWhereUniqueInput | lessonWhereUniqueInput[]
    update?: lessonUpdateWithWhereUniqueWithoutCourseInput | lessonUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: lessonUpdateManyWithWhereWithoutCourseInput | lessonUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: lessonScalarWhereInput | lessonScalarWhereInput[]
  }

  export type paymentUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<paymentCreateWithoutCourseInput, paymentUncheckedCreateWithoutCourseInput> | paymentCreateWithoutCourseInput[] | paymentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: paymentCreateOrConnectWithoutCourseInput | paymentCreateOrConnectWithoutCourseInput[]
    upsert?: paymentUpsertWithWhereUniqueWithoutCourseInput | paymentUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: paymentCreateManyCourseInputEnvelope
    set?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    disconnect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    delete?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    connect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    update?: paymentUpdateWithWhereUniqueWithoutCourseInput | paymentUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: paymentUpdateManyWithWhereWithoutCourseInput | paymentUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: paymentScalarWhereInput | paymentScalarWhereInput[]
  }

  export type quizUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<quizCreateWithoutCourseInput, quizUncheckedCreateWithoutCourseInput> | quizCreateWithoutCourseInput[] | quizUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: quizCreateOrConnectWithoutCourseInput | quizCreateOrConnectWithoutCourseInput[]
    upsert?: quizUpsertWithWhereUniqueWithoutCourseInput | quizUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: quizCreateManyCourseInputEnvelope
    set?: quizWhereUniqueInput | quizWhereUniqueInput[]
    disconnect?: quizWhereUniqueInput | quizWhereUniqueInput[]
    delete?: quizWhereUniqueInput | quizWhereUniqueInput[]
    connect?: quizWhereUniqueInput | quizWhereUniqueInput[]
    update?: quizUpdateWithWhereUniqueWithoutCourseInput | quizUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: quizUpdateManyWithWhereWithoutCourseInput | quizUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: quizScalarWhereInput | quizScalarWhereInput[]
  }

  export type quizsubmissionUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<quizsubmissionCreateWithoutCourseInput, quizsubmissionUncheckedCreateWithoutCourseInput> | quizsubmissionCreateWithoutCourseInput[] | quizsubmissionUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: quizsubmissionCreateOrConnectWithoutCourseInput | quizsubmissionCreateOrConnectWithoutCourseInput[]
    upsert?: quizsubmissionUpsertWithWhereUniqueWithoutCourseInput | quizsubmissionUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: quizsubmissionCreateManyCourseInputEnvelope
    set?: quizsubmissionWhereUniqueInput | quizsubmissionWhereUniqueInput[]
    disconnect?: quizsubmissionWhereUniqueInput | quizsubmissionWhereUniqueInput[]
    delete?: quizsubmissionWhereUniqueInput | quizsubmissionWhereUniqueInput[]
    connect?: quizsubmissionWhereUniqueInput | quizsubmissionWhereUniqueInput[]
    update?: quizsubmissionUpdateWithWhereUniqueWithoutCourseInput | quizsubmissionUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: quizsubmissionUpdateManyWithWhereWithoutCourseInput | quizsubmissionUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: quizsubmissionScalarWhereInput | quizsubmissionScalarWhereInput[]
  }

  export type roadmapcourseUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<roadmapcourseCreateWithoutCourseInput, roadmapcourseUncheckedCreateWithoutCourseInput> | roadmapcourseCreateWithoutCourseInput[] | roadmapcourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: roadmapcourseCreateOrConnectWithoutCourseInput | roadmapcourseCreateOrConnectWithoutCourseInput[]
    upsert?: roadmapcourseUpsertWithWhereUniqueWithoutCourseInput | roadmapcourseUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: roadmapcourseCreateManyCourseInputEnvelope
    set?: roadmapcourseWhereUniqueInput | roadmapcourseWhereUniqueInput[]
    disconnect?: roadmapcourseWhereUniqueInput | roadmapcourseWhereUniqueInput[]
    delete?: roadmapcourseWhereUniqueInput | roadmapcourseWhereUniqueInput[]
    connect?: roadmapcourseWhereUniqueInput | roadmapcourseWhereUniqueInput[]
    update?: roadmapcourseUpdateWithWhereUniqueWithoutCourseInput | roadmapcourseUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: roadmapcourseUpdateManyWithWhereWithoutCourseInput | roadmapcourseUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: roadmapcourseScalarWhereInput | roadmapcourseScalarWhereInput[]
  }

  export type courseCreateNestedOneWithoutCourseprogressInput = {
    create?: XOR<courseCreateWithoutCourseprogressInput, courseUncheckedCreateWithoutCourseprogressInput>
    connectOrCreate?: courseCreateOrConnectWithoutCourseprogressInput
    connect?: courseWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCourseprogressInput = {
    create?: XOR<UserCreateWithoutCourseprogressInput, UserUncheckedCreateWithoutCourseprogressInput>
    connectOrCreate?: UserCreateOrConnectWithoutCourseprogressInput
    connect?: UserWhereUniqueInput
  }

  export type courseUpdateOneRequiredWithoutCourseprogressNestedInput = {
    create?: XOR<courseCreateWithoutCourseprogressInput, courseUncheckedCreateWithoutCourseprogressInput>
    connectOrCreate?: courseCreateOrConnectWithoutCourseprogressInput
    upsert?: courseUpsertWithoutCourseprogressInput
    connect?: courseWhereUniqueInput
    update?: XOR<XOR<courseUpdateToOneWithWhereWithoutCourseprogressInput, courseUpdateWithoutCourseprogressInput>, courseUncheckedUpdateWithoutCourseprogressInput>
  }

  export type UserUpdateOneRequiredWithoutCourseprogressNestedInput = {
    create?: XOR<UserCreateWithoutCourseprogressInput, UserUncheckedCreateWithoutCourseprogressInput>
    connectOrCreate?: UserCreateOrConnectWithoutCourseprogressInput
    upsert?: UserUpsertWithoutCourseprogressInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCourseprogressInput, UserUpdateWithoutCourseprogressInput>, UserUncheckedUpdateWithoutCourseprogressInput>
  }

  export type courseCreateNestedOneWithoutCoursevideoInput = {
    create?: XOR<courseCreateWithoutCoursevideoInput, courseUncheckedCreateWithoutCoursevideoInput>
    connectOrCreate?: courseCreateOrConnectWithoutCoursevideoInput
    connect?: courseWhereUniqueInput
  }

  export type courseUpdateOneRequiredWithoutCoursevideoNestedInput = {
    create?: XOR<courseCreateWithoutCoursevideoInput, courseUncheckedCreateWithoutCoursevideoInput>
    connectOrCreate?: courseCreateOrConnectWithoutCoursevideoInput
    upsert?: courseUpsertWithoutCoursevideoInput
    connect?: courseWhereUniqueInput
    update?: XOR<XOR<courseUpdateToOneWithWhereWithoutCoursevideoInput, courseUpdateWithoutCoursevideoInput>, courseUncheckedUpdateWithoutCoursevideoInput>
  }

  export type UserCreateNestedOneWithoutCvreviewInput = {
    create?: XOR<UserCreateWithoutCvreviewInput, UserUncheckedCreateWithoutCvreviewInput>
    connectOrCreate?: UserCreateOrConnectWithoutCvreviewInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCvreviewNestedInput = {
    create?: XOR<UserCreateWithoutCvreviewInput, UserUncheckedCreateWithoutCvreviewInput>
    connectOrCreate?: UserCreateOrConnectWithoutCvreviewInput
    upsert?: UserUpsertWithoutCvreviewInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCvreviewInput, UserUpdateWithoutCvreviewInput>, UserUncheckedUpdateWithoutCvreviewInput>
  }

  export type courseCreateNestedOneWithoutEnrollmentInput = {
    create?: XOR<courseCreateWithoutEnrollmentInput, courseUncheckedCreateWithoutEnrollmentInput>
    connectOrCreate?: courseCreateOrConnectWithoutEnrollmentInput
    connect?: courseWhereUniqueInput
  }

  export type paymentCreateNestedOneWithoutEnrollmentInput = {
    create?: XOR<paymentCreateWithoutEnrollmentInput, paymentUncheckedCreateWithoutEnrollmentInput>
    connectOrCreate?: paymentCreateOrConnectWithoutEnrollmentInput
    connect?: paymentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEnrollmentInput = {
    create?: XOR<UserCreateWithoutEnrollmentInput, UserUncheckedCreateWithoutEnrollmentInput>
    connectOrCreate?: UserCreateOrConnectWithoutEnrollmentInput
    connect?: UserWhereUniqueInput
  }

  export type courseUpdateOneRequiredWithoutEnrollmentNestedInput = {
    create?: XOR<courseCreateWithoutEnrollmentInput, courseUncheckedCreateWithoutEnrollmentInput>
    connectOrCreate?: courseCreateOrConnectWithoutEnrollmentInput
    upsert?: courseUpsertWithoutEnrollmentInput
    connect?: courseWhereUniqueInput
    update?: XOR<XOR<courseUpdateToOneWithWhereWithoutEnrollmentInput, courseUpdateWithoutEnrollmentInput>, courseUncheckedUpdateWithoutEnrollmentInput>
  }

  export type paymentUpdateOneWithoutEnrollmentNestedInput = {
    create?: XOR<paymentCreateWithoutEnrollmentInput, paymentUncheckedCreateWithoutEnrollmentInput>
    connectOrCreate?: paymentCreateOrConnectWithoutEnrollmentInput
    upsert?: paymentUpsertWithoutEnrollmentInput
    disconnect?: paymentWhereInput | boolean
    delete?: paymentWhereInput | boolean
    connect?: paymentWhereUniqueInput
    update?: XOR<XOR<paymentUpdateToOneWithWhereWithoutEnrollmentInput, paymentUpdateWithoutEnrollmentInput>, paymentUncheckedUpdateWithoutEnrollmentInput>
  }

  export type UserUpdateOneRequiredWithoutEnrollmentNestedInput = {
    create?: XOR<UserCreateWithoutEnrollmentInput, UserUncheckedCreateWithoutEnrollmentInput>
    connectOrCreate?: UserCreateOrConnectWithoutEnrollmentInput
    upsert?: UserUpsertWithoutEnrollmentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEnrollmentInput, UserUpdateWithoutEnrollmentInput>, UserUncheckedUpdateWithoutEnrollmentInput>
  }

  export type UserCreateNestedOneWithoutJobmatchInput = {
    create?: XOR<UserCreateWithoutJobmatchInput, UserUncheckedCreateWithoutJobmatchInput>
    connectOrCreate?: UserCreateOrConnectWithoutJobmatchInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutJobmatchNestedInput = {
    create?: XOR<UserCreateWithoutJobmatchInput, UserUncheckedCreateWithoutJobmatchInput>
    connectOrCreate?: UserCreateOrConnectWithoutJobmatchInput
    upsert?: UserUpsertWithoutJobmatchInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutJobmatchInput, UserUpdateWithoutJobmatchInput>, UserUncheckedUpdateWithoutJobmatchInput>
  }

  export type courseCreateNestedOneWithoutLessonInput = {
    create?: XOR<courseCreateWithoutLessonInput, courseUncheckedCreateWithoutLessonInput>
    connectOrCreate?: courseCreateOrConnectWithoutLessonInput
    connect?: courseWhereUniqueInput
  }

  export type lessonprogressCreateNestedManyWithoutLessonInput = {
    create?: XOR<lessonprogressCreateWithoutLessonInput, lessonprogressUncheckedCreateWithoutLessonInput> | lessonprogressCreateWithoutLessonInput[] | lessonprogressUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: lessonprogressCreateOrConnectWithoutLessonInput | lessonprogressCreateOrConnectWithoutLessonInput[]
    createMany?: lessonprogressCreateManyLessonInputEnvelope
    connect?: lessonprogressWhereUniqueInput | lessonprogressWhereUniqueInput[]
  }

  export type lessonprogressUncheckedCreateNestedManyWithoutLessonInput = {
    create?: XOR<lessonprogressCreateWithoutLessonInput, lessonprogressUncheckedCreateWithoutLessonInput> | lessonprogressCreateWithoutLessonInput[] | lessonprogressUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: lessonprogressCreateOrConnectWithoutLessonInput | lessonprogressCreateOrConnectWithoutLessonInput[]
    createMany?: lessonprogressCreateManyLessonInputEnvelope
    connect?: lessonprogressWhereUniqueInput | lessonprogressWhereUniqueInput[]
  }

  export type courseUpdateOneRequiredWithoutLessonNestedInput = {
    create?: XOR<courseCreateWithoutLessonInput, courseUncheckedCreateWithoutLessonInput>
    connectOrCreate?: courseCreateOrConnectWithoutLessonInput
    upsert?: courseUpsertWithoutLessonInput
    connect?: courseWhereUniqueInput
    update?: XOR<XOR<courseUpdateToOneWithWhereWithoutLessonInput, courseUpdateWithoutLessonInput>, courseUncheckedUpdateWithoutLessonInput>
  }

  export type lessonprogressUpdateManyWithoutLessonNestedInput = {
    create?: XOR<lessonprogressCreateWithoutLessonInput, lessonprogressUncheckedCreateWithoutLessonInput> | lessonprogressCreateWithoutLessonInput[] | lessonprogressUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: lessonprogressCreateOrConnectWithoutLessonInput | lessonprogressCreateOrConnectWithoutLessonInput[]
    upsert?: lessonprogressUpsertWithWhereUniqueWithoutLessonInput | lessonprogressUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: lessonprogressCreateManyLessonInputEnvelope
    set?: lessonprogressWhereUniqueInput | lessonprogressWhereUniqueInput[]
    disconnect?: lessonprogressWhereUniqueInput | lessonprogressWhereUniqueInput[]
    delete?: lessonprogressWhereUniqueInput | lessonprogressWhereUniqueInput[]
    connect?: lessonprogressWhereUniqueInput | lessonprogressWhereUniqueInput[]
    update?: lessonprogressUpdateWithWhereUniqueWithoutLessonInput | lessonprogressUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: lessonprogressUpdateManyWithWhereWithoutLessonInput | lessonprogressUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: lessonprogressScalarWhereInput | lessonprogressScalarWhereInput[]
  }

  export type lessonprogressUncheckedUpdateManyWithoutLessonNestedInput = {
    create?: XOR<lessonprogressCreateWithoutLessonInput, lessonprogressUncheckedCreateWithoutLessonInput> | lessonprogressCreateWithoutLessonInput[] | lessonprogressUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: lessonprogressCreateOrConnectWithoutLessonInput | lessonprogressCreateOrConnectWithoutLessonInput[]
    upsert?: lessonprogressUpsertWithWhereUniqueWithoutLessonInput | lessonprogressUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: lessonprogressCreateManyLessonInputEnvelope
    set?: lessonprogressWhereUniqueInput | lessonprogressWhereUniqueInput[]
    disconnect?: lessonprogressWhereUniqueInput | lessonprogressWhereUniqueInput[]
    delete?: lessonprogressWhereUniqueInput | lessonprogressWhereUniqueInput[]
    connect?: lessonprogressWhereUniqueInput | lessonprogressWhereUniqueInput[]
    update?: lessonprogressUpdateWithWhereUniqueWithoutLessonInput | lessonprogressUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: lessonprogressUpdateManyWithWhereWithoutLessonInput | lessonprogressUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: lessonprogressScalarWhereInput | lessonprogressScalarWhereInput[]
  }

  export type lessonCreateNestedOneWithoutLessonprogressInput = {
    create?: XOR<lessonCreateWithoutLessonprogressInput, lessonUncheckedCreateWithoutLessonprogressInput>
    connectOrCreate?: lessonCreateOrConnectWithoutLessonprogressInput
    connect?: lessonWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutLessonprogressInput = {
    create?: XOR<UserCreateWithoutLessonprogressInput, UserUncheckedCreateWithoutLessonprogressInput>
    connectOrCreate?: UserCreateOrConnectWithoutLessonprogressInput
    connect?: UserWhereUniqueInput
  }

  export type lessonUpdateOneRequiredWithoutLessonprogressNestedInput = {
    create?: XOR<lessonCreateWithoutLessonprogressInput, lessonUncheckedCreateWithoutLessonprogressInput>
    connectOrCreate?: lessonCreateOrConnectWithoutLessonprogressInput
    upsert?: lessonUpsertWithoutLessonprogressInput
    connect?: lessonWhereUniqueInput
    update?: XOR<XOR<lessonUpdateToOneWithWhereWithoutLessonprogressInput, lessonUpdateWithoutLessonprogressInput>, lessonUncheckedUpdateWithoutLessonprogressInput>
  }

  export type UserUpdateOneRequiredWithoutLessonprogressNestedInput = {
    create?: XOR<UserCreateWithoutLessonprogressInput, UserUncheckedCreateWithoutLessonprogressInput>
    connectOrCreate?: UserCreateOrConnectWithoutLessonprogressInput
    upsert?: UserUpsertWithoutLessonprogressInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLessonprogressInput, UserUpdateWithoutLessonprogressInput>, UserUncheckedUpdateWithoutLessonprogressInput>
  }

  export type UserCreateNestedOneWithoutNotificationInput = {
    create?: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationNestedInput = {
    create?: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationInput
    upsert?: UserUpsertWithoutNotificationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationInput, UserUpdateWithoutNotificationInput>, UserUncheckedUpdateWithoutNotificationInput>
  }

  export type enrollmentCreateNestedManyWithoutPaymentInput = {
    create?: XOR<enrollmentCreateWithoutPaymentInput, enrollmentUncheckedCreateWithoutPaymentInput> | enrollmentCreateWithoutPaymentInput[] | enrollmentUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: enrollmentCreateOrConnectWithoutPaymentInput | enrollmentCreateOrConnectWithoutPaymentInput[]
    createMany?: enrollmentCreateManyPaymentInputEnvelope
    connect?: enrollmentWhereUniqueInput | enrollmentWhereUniqueInput[]
  }

  export type courseCreateNestedOneWithoutPaymentInput = {
    create?: XOR<courseCreateWithoutPaymentInput, courseUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: courseCreateOrConnectWithoutPaymentInput
    connect?: courseWhereUniqueInput
  }

  export type roadmapCreateNestedOneWithoutPaymentInput = {
    create?: XOR<roadmapCreateWithoutPaymentInput, roadmapUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: roadmapCreateOrConnectWithoutPaymentInput
    connect?: roadmapWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPaymentInput = {
    create?: XOR<UserCreateWithoutPaymentInput, UserUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentInput
    connect?: UserWhereUniqueInput
  }

  export type enrollmentUncheckedCreateNestedManyWithoutPaymentInput = {
    create?: XOR<enrollmentCreateWithoutPaymentInput, enrollmentUncheckedCreateWithoutPaymentInput> | enrollmentCreateWithoutPaymentInput[] | enrollmentUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: enrollmentCreateOrConnectWithoutPaymentInput | enrollmentCreateOrConnectWithoutPaymentInput[]
    createMany?: enrollmentCreateManyPaymentInputEnvelope
    connect?: enrollmentWhereUniqueInput | enrollmentWhereUniqueInput[]
  }

  export type enrollmentUpdateManyWithoutPaymentNestedInput = {
    create?: XOR<enrollmentCreateWithoutPaymentInput, enrollmentUncheckedCreateWithoutPaymentInput> | enrollmentCreateWithoutPaymentInput[] | enrollmentUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: enrollmentCreateOrConnectWithoutPaymentInput | enrollmentCreateOrConnectWithoutPaymentInput[]
    upsert?: enrollmentUpsertWithWhereUniqueWithoutPaymentInput | enrollmentUpsertWithWhereUniqueWithoutPaymentInput[]
    createMany?: enrollmentCreateManyPaymentInputEnvelope
    set?: enrollmentWhereUniqueInput | enrollmentWhereUniqueInput[]
    disconnect?: enrollmentWhereUniqueInput | enrollmentWhereUniqueInput[]
    delete?: enrollmentWhereUniqueInput | enrollmentWhereUniqueInput[]
    connect?: enrollmentWhereUniqueInput | enrollmentWhereUniqueInput[]
    update?: enrollmentUpdateWithWhereUniqueWithoutPaymentInput | enrollmentUpdateWithWhereUniqueWithoutPaymentInput[]
    updateMany?: enrollmentUpdateManyWithWhereWithoutPaymentInput | enrollmentUpdateManyWithWhereWithoutPaymentInput[]
    deleteMany?: enrollmentScalarWhereInput | enrollmentScalarWhereInput[]
  }

  export type courseUpdateOneWithoutPaymentNestedInput = {
    create?: XOR<courseCreateWithoutPaymentInput, courseUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: courseCreateOrConnectWithoutPaymentInput
    upsert?: courseUpsertWithoutPaymentInput
    disconnect?: courseWhereInput | boolean
    delete?: courseWhereInput | boolean
    connect?: courseWhereUniqueInput
    update?: XOR<XOR<courseUpdateToOneWithWhereWithoutPaymentInput, courseUpdateWithoutPaymentInput>, courseUncheckedUpdateWithoutPaymentInput>
  }

  export type roadmapUpdateOneWithoutPaymentNestedInput = {
    create?: XOR<roadmapCreateWithoutPaymentInput, roadmapUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: roadmapCreateOrConnectWithoutPaymentInput
    upsert?: roadmapUpsertWithoutPaymentInput
    disconnect?: roadmapWhereInput | boolean
    delete?: roadmapWhereInput | boolean
    connect?: roadmapWhereUniqueInput
    update?: XOR<XOR<roadmapUpdateToOneWithWhereWithoutPaymentInput, roadmapUpdateWithoutPaymentInput>, roadmapUncheckedUpdateWithoutPaymentInput>
  }

  export type UserUpdateOneRequiredWithoutPaymentNestedInput = {
    create?: XOR<UserCreateWithoutPaymentInput, UserUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentInput
    upsert?: UserUpsertWithoutPaymentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPaymentInput, UserUpdateWithoutPaymentInput>, UserUncheckedUpdateWithoutPaymentInput>
  }

  export type enrollmentUncheckedUpdateManyWithoutPaymentNestedInput = {
    create?: XOR<enrollmentCreateWithoutPaymentInput, enrollmentUncheckedCreateWithoutPaymentInput> | enrollmentCreateWithoutPaymentInput[] | enrollmentUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: enrollmentCreateOrConnectWithoutPaymentInput | enrollmentCreateOrConnectWithoutPaymentInput[]
    upsert?: enrollmentUpsertWithWhereUniqueWithoutPaymentInput | enrollmentUpsertWithWhereUniqueWithoutPaymentInput[]
    createMany?: enrollmentCreateManyPaymentInputEnvelope
    set?: enrollmentWhereUniqueInput | enrollmentWhereUniqueInput[]
    disconnect?: enrollmentWhereUniqueInput | enrollmentWhereUniqueInput[]
    delete?: enrollmentWhereUniqueInput | enrollmentWhereUniqueInput[]
    connect?: enrollmentWhereUniqueInput | enrollmentWhereUniqueInput[]
    update?: enrollmentUpdateWithWhereUniqueWithoutPaymentInput | enrollmentUpdateWithWhereUniqueWithoutPaymentInput[]
    updateMany?: enrollmentUpdateManyWithWhereWithoutPaymentInput | enrollmentUpdateManyWithWhereWithoutPaymentInput[]
    deleteMany?: enrollmentScalarWhereInput | enrollmentScalarWhereInput[]
  }

  export type courseCreateNestedOneWithoutQuizInput = {
    create?: XOR<courseCreateWithoutQuizInput, courseUncheckedCreateWithoutQuizInput>
    connectOrCreate?: courseCreateOrConnectWithoutQuizInput
    connect?: courseWhereUniqueInput
  }

  export type quizsubmissionCreateNestedManyWithoutQuizInput = {
    create?: XOR<quizsubmissionCreateWithoutQuizInput, quizsubmissionUncheckedCreateWithoutQuizInput> | quizsubmissionCreateWithoutQuizInput[] | quizsubmissionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: quizsubmissionCreateOrConnectWithoutQuizInput | quizsubmissionCreateOrConnectWithoutQuizInput[]
    createMany?: quizsubmissionCreateManyQuizInputEnvelope
    connect?: quizsubmissionWhereUniqueInput | quizsubmissionWhereUniqueInput[]
  }

  export type quizsubmissionUncheckedCreateNestedManyWithoutQuizInput = {
    create?: XOR<quizsubmissionCreateWithoutQuizInput, quizsubmissionUncheckedCreateWithoutQuizInput> | quizsubmissionCreateWithoutQuizInput[] | quizsubmissionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: quizsubmissionCreateOrConnectWithoutQuizInput | quizsubmissionCreateOrConnectWithoutQuizInput[]
    createMany?: quizsubmissionCreateManyQuizInputEnvelope
    connect?: quizsubmissionWhereUniqueInput | quizsubmissionWhereUniqueInput[]
  }

  export type courseUpdateOneRequiredWithoutQuizNestedInput = {
    create?: XOR<courseCreateWithoutQuizInput, courseUncheckedCreateWithoutQuizInput>
    connectOrCreate?: courseCreateOrConnectWithoutQuizInput
    upsert?: courseUpsertWithoutQuizInput
    connect?: courseWhereUniqueInput
    update?: XOR<XOR<courseUpdateToOneWithWhereWithoutQuizInput, courseUpdateWithoutQuizInput>, courseUncheckedUpdateWithoutQuizInput>
  }

  export type quizsubmissionUpdateManyWithoutQuizNestedInput = {
    create?: XOR<quizsubmissionCreateWithoutQuizInput, quizsubmissionUncheckedCreateWithoutQuizInput> | quizsubmissionCreateWithoutQuizInput[] | quizsubmissionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: quizsubmissionCreateOrConnectWithoutQuizInput | quizsubmissionCreateOrConnectWithoutQuizInput[]
    upsert?: quizsubmissionUpsertWithWhereUniqueWithoutQuizInput | quizsubmissionUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: quizsubmissionCreateManyQuizInputEnvelope
    set?: quizsubmissionWhereUniqueInput | quizsubmissionWhereUniqueInput[]
    disconnect?: quizsubmissionWhereUniqueInput | quizsubmissionWhereUniqueInput[]
    delete?: quizsubmissionWhereUniqueInput | quizsubmissionWhereUniqueInput[]
    connect?: quizsubmissionWhereUniqueInput | quizsubmissionWhereUniqueInput[]
    update?: quizsubmissionUpdateWithWhereUniqueWithoutQuizInput | quizsubmissionUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: quizsubmissionUpdateManyWithWhereWithoutQuizInput | quizsubmissionUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: quizsubmissionScalarWhereInput | quizsubmissionScalarWhereInput[]
  }

  export type quizsubmissionUncheckedUpdateManyWithoutQuizNestedInput = {
    create?: XOR<quizsubmissionCreateWithoutQuizInput, quizsubmissionUncheckedCreateWithoutQuizInput> | quizsubmissionCreateWithoutQuizInput[] | quizsubmissionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: quizsubmissionCreateOrConnectWithoutQuizInput | quizsubmissionCreateOrConnectWithoutQuizInput[]
    upsert?: quizsubmissionUpsertWithWhereUniqueWithoutQuizInput | quizsubmissionUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: quizsubmissionCreateManyQuizInputEnvelope
    set?: quizsubmissionWhereUniqueInput | quizsubmissionWhereUniqueInput[]
    disconnect?: quizsubmissionWhereUniqueInput | quizsubmissionWhereUniqueInput[]
    delete?: quizsubmissionWhereUniqueInput | quizsubmissionWhereUniqueInput[]
    connect?: quizsubmissionWhereUniqueInput | quizsubmissionWhereUniqueInput[]
    update?: quizsubmissionUpdateWithWhereUniqueWithoutQuizInput | quizsubmissionUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: quizsubmissionUpdateManyWithWhereWithoutQuizInput | quizsubmissionUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: quizsubmissionScalarWhereInput | quizsubmissionScalarWhereInput[]
  }

  export type courseCreateNestedOneWithoutQuizsubmissionInput = {
    create?: XOR<courseCreateWithoutQuizsubmissionInput, courseUncheckedCreateWithoutQuizsubmissionInput>
    connectOrCreate?: courseCreateOrConnectWithoutQuizsubmissionInput
    connect?: courseWhereUniqueInput
  }

  export type quizCreateNestedOneWithoutQuizsubmissionInput = {
    create?: XOR<quizCreateWithoutQuizsubmissionInput, quizUncheckedCreateWithoutQuizsubmissionInput>
    connectOrCreate?: quizCreateOrConnectWithoutQuizsubmissionInput
    connect?: quizWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutQuizsubmissionInput = {
    create?: XOR<UserCreateWithoutQuizsubmissionInput, UserUncheckedCreateWithoutQuizsubmissionInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuizsubmissionInput
    connect?: UserWhereUniqueInput
  }

  export type courseUpdateOneRequiredWithoutQuizsubmissionNestedInput = {
    create?: XOR<courseCreateWithoutQuizsubmissionInput, courseUncheckedCreateWithoutQuizsubmissionInput>
    connectOrCreate?: courseCreateOrConnectWithoutQuizsubmissionInput
    upsert?: courseUpsertWithoutQuizsubmissionInput
    connect?: courseWhereUniqueInput
    update?: XOR<XOR<courseUpdateToOneWithWhereWithoutQuizsubmissionInput, courseUpdateWithoutQuizsubmissionInput>, courseUncheckedUpdateWithoutQuizsubmissionInput>
  }

  export type quizUpdateOneRequiredWithoutQuizsubmissionNestedInput = {
    create?: XOR<quizCreateWithoutQuizsubmissionInput, quizUncheckedCreateWithoutQuizsubmissionInput>
    connectOrCreate?: quizCreateOrConnectWithoutQuizsubmissionInput
    upsert?: quizUpsertWithoutQuizsubmissionInput
    connect?: quizWhereUniqueInput
    update?: XOR<XOR<quizUpdateToOneWithWhereWithoutQuizsubmissionInput, quizUpdateWithoutQuizsubmissionInput>, quizUncheckedUpdateWithoutQuizsubmissionInput>
  }

  export type UserUpdateOneRequiredWithoutQuizsubmissionNestedInput = {
    create?: XOR<UserCreateWithoutQuizsubmissionInput, UserUncheckedCreateWithoutQuizsubmissionInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuizsubmissionInput
    upsert?: UserUpsertWithoutQuizsubmissionInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutQuizsubmissionInput, UserUpdateWithoutQuizsubmissionInput>, UserUncheckedUpdateWithoutQuizsubmissionInput>
  }

  export type paymentCreateNestedManyWithoutRoadmapInput = {
    create?: XOR<paymentCreateWithoutRoadmapInput, paymentUncheckedCreateWithoutRoadmapInput> | paymentCreateWithoutRoadmapInput[] | paymentUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: paymentCreateOrConnectWithoutRoadmapInput | paymentCreateOrConnectWithoutRoadmapInput[]
    createMany?: paymentCreateManyRoadmapInputEnvelope
    connect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
  }

  export type roadmapcourseCreateNestedManyWithoutRoadmapInput = {
    create?: XOR<roadmapcourseCreateWithoutRoadmapInput, roadmapcourseUncheckedCreateWithoutRoadmapInput> | roadmapcourseCreateWithoutRoadmapInput[] | roadmapcourseUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: roadmapcourseCreateOrConnectWithoutRoadmapInput | roadmapcourseCreateOrConnectWithoutRoadmapInput[]
    createMany?: roadmapcourseCreateManyRoadmapInputEnvelope
    connect?: roadmapcourseWhereUniqueInput | roadmapcourseWhereUniqueInput[]
  }

  export type userroadmapCreateNestedManyWithoutRoadmapInput = {
    create?: XOR<userroadmapCreateWithoutRoadmapInput, userroadmapUncheckedCreateWithoutRoadmapInput> | userroadmapCreateWithoutRoadmapInput[] | userroadmapUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: userroadmapCreateOrConnectWithoutRoadmapInput | userroadmapCreateOrConnectWithoutRoadmapInput[]
    createMany?: userroadmapCreateManyRoadmapInputEnvelope
    connect?: userroadmapWhereUniqueInput | userroadmapWhereUniqueInput[]
  }

  export type paymentUncheckedCreateNestedManyWithoutRoadmapInput = {
    create?: XOR<paymentCreateWithoutRoadmapInput, paymentUncheckedCreateWithoutRoadmapInput> | paymentCreateWithoutRoadmapInput[] | paymentUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: paymentCreateOrConnectWithoutRoadmapInput | paymentCreateOrConnectWithoutRoadmapInput[]
    createMany?: paymentCreateManyRoadmapInputEnvelope
    connect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
  }

  export type roadmapcourseUncheckedCreateNestedManyWithoutRoadmapInput = {
    create?: XOR<roadmapcourseCreateWithoutRoadmapInput, roadmapcourseUncheckedCreateWithoutRoadmapInput> | roadmapcourseCreateWithoutRoadmapInput[] | roadmapcourseUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: roadmapcourseCreateOrConnectWithoutRoadmapInput | roadmapcourseCreateOrConnectWithoutRoadmapInput[]
    createMany?: roadmapcourseCreateManyRoadmapInputEnvelope
    connect?: roadmapcourseWhereUniqueInput | roadmapcourseWhereUniqueInput[]
  }

  export type userroadmapUncheckedCreateNestedManyWithoutRoadmapInput = {
    create?: XOR<userroadmapCreateWithoutRoadmapInput, userroadmapUncheckedCreateWithoutRoadmapInput> | userroadmapCreateWithoutRoadmapInput[] | userroadmapUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: userroadmapCreateOrConnectWithoutRoadmapInput | userroadmapCreateOrConnectWithoutRoadmapInput[]
    createMany?: userroadmapCreateManyRoadmapInputEnvelope
    connect?: userroadmapWhereUniqueInput | userroadmapWhereUniqueInput[]
  }

  export type paymentUpdateManyWithoutRoadmapNestedInput = {
    create?: XOR<paymentCreateWithoutRoadmapInput, paymentUncheckedCreateWithoutRoadmapInput> | paymentCreateWithoutRoadmapInput[] | paymentUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: paymentCreateOrConnectWithoutRoadmapInput | paymentCreateOrConnectWithoutRoadmapInput[]
    upsert?: paymentUpsertWithWhereUniqueWithoutRoadmapInput | paymentUpsertWithWhereUniqueWithoutRoadmapInput[]
    createMany?: paymentCreateManyRoadmapInputEnvelope
    set?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    disconnect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    delete?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    connect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    update?: paymentUpdateWithWhereUniqueWithoutRoadmapInput | paymentUpdateWithWhereUniqueWithoutRoadmapInput[]
    updateMany?: paymentUpdateManyWithWhereWithoutRoadmapInput | paymentUpdateManyWithWhereWithoutRoadmapInput[]
    deleteMany?: paymentScalarWhereInput | paymentScalarWhereInput[]
  }

  export type roadmapcourseUpdateManyWithoutRoadmapNestedInput = {
    create?: XOR<roadmapcourseCreateWithoutRoadmapInput, roadmapcourseUncheckedCreateWithoutRoadmapInput> | roadmapcourseCreateWithoutRoadmapInput[] | roadmapcourseUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: roadmapcourseCreateOrConnectWithoutRoadmapInput | roadmapcourseCreateOrConnectWithoutRoadmapInput[]
    upsert?: roadmapcourseUpsertWithWhereUniqueWithoutRoadmapInput | roadmapcourseUpsertWithWhereUniqueWithoutRoadmapInput[]
    createMany?: roadmapcourseCreateManyRoadmapInputEnvelope
    set?: roadmapcourseWhereUniqueInput | roadmapcourseWhereUniqueInput[]
    disconnect?: roadmapcourseWhereUniqueInput | roadmapcourseWhereUniqueInput[]
    delete?: roadmapcourseWhereUniqueInput | roadmapcourseWhereUniqueInput[]
    connect?: roadmapcourseWhereUniqueInput | roadmapcourseWhereUniqueInput[]
    update?: roadmapcourseUpdateWithWhereUniqueWithoutRoadmapInput | roadmapcourseUpdateWithWhereUniqueWithoutRoadmapInput[]
    updateMany?: roadmapcourseUpdateManyWithWhereWithoutRoadmapInput | roadmapcourseUpdateManyWithWhereWithoutRoadmapInput[]
    deleteMany?: roadmapcourseScalarWhereInput | roadmapcourseScalarWhereInput[]
  }

  export type userroadmapUpdateManyWithoutRoadmapNestedInput = {
    create?: XOR<userroadmapCreateWithoutRoadmapInput, userroadmapUncheckedCreateWithoutRoadmapInput> | userroadmapCreateWithoutRoadmapInput[] | userroadmapUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: userroadmapCreateOrConnectWithoutRoadmapInput | userroadmapCreateOrConnectWithoutRoadmapInput[]
    upsert?: userroadmapUpsertWithWhereUniqueWithoutRoadmapInput | userroadmapUpsertWithWhereUniqueWithoutRoadmapInput[]
    createMany?: userroadmapCreateManyRoadmapInputEnvelope
    set?: userroadmapWhereUniqueInput | userroadmapWhereUniqueInput[]
    disconnect?: userroadmapWhereUniqueInput | userroadmapWhereUniqueInput[]
    delete?: userroadmapWhereUniqueInput | userroadmapWhereUniqueInput[]
    connect?: userroadmapWhereUniqueInput | userroadmapWhereUniqueInput[]
    update?: userroadmapUpdateWithWhereUniqueWithoutRoadmapInput | userroadmapUpdateWithWhereUniqueWithoutRoadmapInput[]
    updateMany?: userroadmapUpdateManyWithWhereWithoutRoadmapInput | userroadmapUpdateManyWithWhereWithoutRoadmapInput[]
    deleteMany?: userroadmapScalarWhereInput | userroadmapScalarWhereInput[]
  }

  export type paymentUncheckedUpdateManyWithoutRoadmapNestedInput = {
    create?: XOR<paymentCreateWithoutRoadmapInput, paymentUncheckedCreateWithoutRoadmapInput> | paymentCreateWithoutRoadmapInput[] | paymentUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: paymentCreateOrConnectWithoutRoadmapInput | paymentCreateOrConnectWithoutRoadmapInput[]
    upsert?: paymentUpsertWithWhereUniqueWithoutRoadmapInput | paymentUpsertWithWhereUniqueWithoutRoadmapInput[]
    createMany?: paymentCreateManyRoadmapInputEnvelope
    set?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    disconnect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    delete?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    connect?: paymentWhereUniqueInput | paymentWhereUniqueInput[]
    update?: paymentUpdateWithWhereUniqueWithoutRoadmapInput | paymentUpdateWithWhereUniqueWithoutRoadmapInput[]
    updateMany?: paymentUpdateManyWithWhereWithoutRoadmapInput | paymentUpdateManyWithWhereWithoutRoadmapInput[]
    deleteMany?: paymentScalarWhereInput | paymentScalarWhereInput[]
  }

  export type roadmapcourseUncheckedUpdateManyWithoutRoadmapNestedInput = {
    create?: XOR<roadmapcourseCreateWithoutRoadmapInput, roadmapcourseUncheckedCreateWithoutRoadmapInput> | roadmapcourseCreateWithoutRoadmapInput[] | roadmapcourseUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: roadmapcourseCreateOrConnectWithoutRoadmapInput | roadmapcourseCreateOrConnectWithoutRoadmapInput[]
    upsert?: roadmapcourseUpsertWithWhereUniqueWithoutRoadmapInput | roadmapcourseUpsertWithWhereUniqueWithoutRoadmapInput[]
    createMany?: roadmapcourseCreateManyRoadmapInputEnvelope
    set?: roadmapcourseWhereUniqueInput | roadmapcourseWhereUniqueInput[]
    disconnect?: roadmapcourseWhereUniqueInput | roadmapcourseWhereUniqueInput[]
    delete?: roadmapcourseWhereUniqueInput | roadmapcourseWhereUniqueInput[]
    connect?: roadmapcourseWhereUniqueInput | roadmapcourseWhereUniqueInput[]
    update?: roadmapcourseUpdateWithWhereUniqueWithoutRoadmapInput | roadmapcourseUpdateWithWhereUniqueWithoutRoadmapInput[]
    updateMany?: roadmapcourseUpdateManyWithWhereWithoutRoadmapInput | roadmapcourseUpdateManyWithWhereWithoutRoadmapInput[]
    deleteMany?: roadmapcourseScalarWhereInput | roadmapcourseScalarWhereInput[]
  }

  export type userroadmapUncheckedUpdateManyWithoutRoadmapNestedInput = {
    create?: XOR<userroadmapCreateWithoutRoadmapInput, userroadmapUncheckedCreateWithoutRoadmapInput> | userroadmapCreateWithoutRoadmapInput[] | userroadmapUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: userroadmapCreateOrConnectWithoutRoadmapInput | userroadmapCreateOrConnectWithoutRoadmapInput[]
    upsert?: userroadmapUpsertWithWhereUniqueWithoutRoadmapInput | userroadmapUpsertWithWhereUniqueWithoutRoadmapInput[]
    createMany?: userroadmapCreateManyRoadmapInputEnvelope
    set?: userroadmapWhereUniqueInput | userroadmapWhereUniqueInput[]
    disconnect?: userroadmapWhereUniqueInput | userroadmapWhereUniqueInput[]
    delete?: userroadmapWhereUniqueInput | userroadmapWhereUniqueInput[]
    connect?: userroadmapWhereUniqueInput | userroadmapWhereUniqueInput[]
    update?: userroadmapUpdateWithWhereUniqueWithoutRoadmapInput | userroadmapUpdateWithWhereUniqueWithoutRoadmapInput[]
    updateMany?: userroadmapUpdateManyWithWhereWithoutRoadmapInput | userroadmapUpdateManyWithWhereWithoutRoadmapInput[]
    deleteMany?: userroadmapScalarWhereInput | userroadmapScalarWhereInput[]
  }

  export type courseCreateNestedOneWithoutRoadmapcourseInput = {
    create?: XOR<courseCreateWithoutRoadmapcourseInput, courseUncheckedCreateWithoutRoadmapcourseInput>
    connectOrCreate?: courseCreateOrConnectWithoutRoadmapcourseInput
    connect?: courseWhereUniqueInput
  }

  export type roadmapCreateNestedOneWithoutRoadmapcourseInput = {
    create?: XOR<roadmapCreateWithoutRoadmapcourseInput, roadmapUncheckedCreateWithoutRoadmapcourseInput>
    connectOrCreate?: roadmapCreateOrConnectWithoutRoadmapcourseInput
    connect?: roadmapWhereUniqueInput
  }

  export type courseUpdateOneRequiredWithoutRoadmapcourseNestedInput = {
    create?: XOR<courseCreateWithoutRoadmapcourseInput, courseUncheckedCreateWithoutRoadmapcourseInput>
    connectOrCreate?: courseCreateOrConnectWithoutRoadmapcourseInput
    upsert?: courseUpsertWithoutRoadmapcourseInput
    connect?: courseWhereUniqueInput
    update?: XOR<XOR<courseUpdateToOneWithWhereWithoutRoadmapcourseInput, courseUpdateWithoutRoadmapcourseInput>, courseUncheckedUpdateWithoutRoadmapcourseInput>
  }

  export type roadmapUpdateOneRequiredWithoutRoadmapcourseNestedInput = {
    create?: XOR<roadmapCreateWithoutRoadmapcourseInput, roadmapUncheckedCreateWithoutRoadmapcourseInput>
    connectOrCreate?: roadmapCreateOrConnectWithoutRoadmapcourseInput
    upsert?: roadmapUpsertWithoutRoadmapcourseInput
    connect?: roadmapWhereUniqueInput
    update?: XOR<XOR<roadmapUpdateToOneWithWhereWithoutRoadmapcourseInput, roadmapUpdateWithoutRoadmapcourseInput>, roadmapUncheckedUpdateWithoutRoadmapcourseInput>
  }

  export type roadmapCreateNestedOneWithoutUserroadmapInput = {
    create?: XOR<roadmapCreateWithoutUserroadmapInput, roadmapUncheckedCreateWithoutUserroadmapInput>
    connectOrCreate?: roadmapCreateOrConnectWithoutUserroadmapInput
    connect?: roadmapWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUserroadmapInput = {
    create?: XOR<UserCreateWithoutUserroadmapInput, UserUncheckedCreateWithoutUserroadmapInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserroadmapInput
    connect?: UserWhereUniqueInput
  }

  export type roadmapUpdateOneRequiredWithoutUserroadmapNestedInput = {
    create?: XOR<roadmapCreateWithoutUserroadmapInput, roadmapUncheckedCreateWithoutUserroadmapInput>
    connectOrCreate?: roadmapCreateOrConnectWithoutUserroadmapInput
    upsert?: roadmapUpsertWithoutUserroadmapInput
    connect?: roadmapWhereUniqueInput
    update?: XOR<XOR<roadmapUpdateToOneWithWhereWithoutUserroadmapInput, roadmapUpdateWithoutUserroadmapInput>, roadmapUncheckedUpdateWithoutUserroadmapInput>
  }

  export type UserUpdateOneRequiredWithoutUserroadmapNestedInput = {
    create?: XOR<UserCreateWithoutUserroadmapInput, UserUncheckedCreateWithoutUserroadmapInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserroadmapInput
    upsert?: UserUpsertWithoutUserroadmapInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserroadmapInput, UserUpdateWithoutUserroadmapInput>, UserUncheckedUpdateWithoutUserroadmapInput>
  }

  export type UserCreateNestedOneWithoutVoucherInput = {
    create?: XOR<UserCreateWithoutVoucherInput, UserUncheckedCreateWithoutVoucherInput>
    connectOrCreate?: UserCreateOrConnectWithoutVoucherInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutVoucherNestedInput = {
    create?: XOR<UserCreateWithoutVoucherInput, UserUncheckedCreateWithoutVoucherInput>
    connectOrCreate?: UserCreateOrConnectWithoutVoucherInput
    upsert?: UserUpsertWithoutVoucherInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVoucherInput, UserUpdateWithoutVoucherInput>, UserUncheckedUpdateWithoutVoucherInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type assessmentCreateWithoutUsersInput = {
    studentStatus: string
    majorStudy: string
    currentSemester: string
    createdAt?: Date | string
    currentField: string
    dreamJob: string
    interestedField: string
    mainGoal: string
  }

  export type assessmentUncheckedCreateWithoutUsersInput = {
    id?: number
    studentStatus: string
    majorStudy: string
    currentSemester: string
    createdAt?: Date | string
    currentField: string
    dreamJob: string
    interestedField: string
    mainGoal: string
  }

  export type assessmentCreateOrConnectWithoutUsersInput = {
    where: assessmentWhereUniqueInput
    create: XOR<assessmentCreateWithoutUsersInput, assessmentUncheckedCreateWithoutUsersInput>
  }

  export type assessmentCreateManyUsersInputEnvelope = {
    data: assessmentCreateManyUsersInput | assessmentCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type certificateCreateWithoutUsersInput = {
    filePath: string
    issuedAt: Date | string
    course: courseCreateNestedOneWithoutCertificateInput
  }

  export type certificateUncheckedCreateWithoutUsersInput = {
    id?: number
    courseId: number
    filePath: string
    issuedAt: Date | string
  }

  export type certificateCreateOrConnectWithoutUsersInput = {
    where: certificateWhereUniqueInput
    create: XOR<certificateCreateWithoutUsersInput, certificateUncheckedCreateWithoutUsersInput>
  }

  export type certificateCreateManyUsersInputEnvelope = {
    data: certificateCreateManyUsersInput | certificateCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type chatmessageCreateWithoutUsersInput = {
    message: string
    sentAt?: Date | string
    counselingsession: counselingsessionCreateNestedOneWithoutChatmessageInput
  }

  export type chatmessageUncheckedCreateWithoutUsersInput = {
    id?: number
    sessionId: number
    message: string
    sentAt?: Date | string
  }

  export type chatmessageCreateOrConnectWithoutUsersInput = {
    where: chatmessageWhereUniqueInput
    create: XOR<chatmessageCreateWithoutUsersInput, chatmessageUncheckedCreateWithoutUsersInput>
  }

  export type chatmessageCreateManyUsersInputEnvelope = {
    data: chatmessageCreateManyUsersInput | chatmessageCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type counselingsessionCreateWithoutUsersInput = {
    topic: string
    question: string
    response?: string | null
    status: string
    createdAt?: Date | string
    rating?: number | null
    feedback?: string | null
    chatmessage?: chatmessageCreateNestedManyWithoutCounselingsessionInput
    counselor: counselorCreateNestedOneWithoutCounselingsessionInput
  }

  export type counselingsessionUncheckedCreateWithoutUsersInput = {
    id?: number
    counselorId: number
    topic: string
    question: string
    response?: string | null
    status: string
    createdAt?: Date | string
    rating?: number | null
    feedback?: string | null
    chatmessage?: chatmessageUncheckedCreateNestedManyWithoutCounselingsessionInput
  }

  export type counselingsessionCreateOrConnectWithoutUsersInput = {
    where: counselingsessionWhereUniqueInput
    create: XOR<counselingsessionCreateWithoutUsersInput, counselingsessionUncheckedCreateWithoutUsersInput>
  }

  export type counselingsessionCreateManyUsersInputEnvelope = {
    data: counselingsessionCreateManyUsersInput | counselingsessionCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type counselorCreateWithoutUsersInput = {
    specialization: string
    bio: string
    verified: boolean
    counselingsession?: counselingsessionCreateNestedManyWithoutCounselorInput
  }

  export type counselorUncheckedCreateWithoutUsersInput = {
    id?: number
    specialization: string
    bio: string
    verified: boolean
    counselingsession?: counselingsessionUncheckedCreateNestedManyWithoutCounselorInput
  }

  export type counselorCreateOrConnectWithoutUsersInput = {
    where: counselorWhereUniqueInput
    create: XOR<counselorCreateWithoutUsersInput, counselorUncheckedCreateWithoutUsersInput>
  }

  export type courseCreateWithoutUsersInput = {
    title: string
    description: string
    thumbnail: string
    isPaid: boolean
    price: number
    createdAt?: Date | string
    certificate?: certificateCreateNestedManyWithoutCourseInput
    category: categoryCreateNestedOneWithoutCourseInput
    courseprogress?: courseprogressCreateNestedManyWithoutCourseInput
    coursevideo?: coursevideoCreateNestedManyWithoutCourseInput
    enrollment?: enrollmentCreateNestedManyWithoutCourseInput
    lesson?: lessonCreateNestedManyWithoutCourseInput
    payment?: paymentCreateNestedManyWithoutCourseInput
    quiz?: quizCreateNestedManyWithoutCourseInput
    quizsubmission?: quizsubmissionCreateNestedManyWithoutCourseInput
    roadmapcourse?: roadmapcourseCreateNestedManyWithoutCourseInput
  }

  export type courseUncheckedCreateWithoutUsersInput = {
    id?: number
    title: string
    description: string
    thumbnail: string
    categoryId: number
    isPaid: boolean
    price: number
    createdAt?: Date | string
    certificate?: certificateUncheckedCreateNestedManyWithoutCourseInput
    courseprogress?: courseprogressUncheckedCreateNestedManyWithoutCourseInput
    coursevideo?: coursevideoUncheckedCreateNestedManyWithoutCourseInput
    enrollment?: enrollmentUncheckedCreateNestedManyWithoutCourseInput
    lesson?: lessonUncheckedCreateNestedManyWithoutCourseInput
    payment?: paymentUncheckedCreateNestedManyWithoutCourseInput
    quiz?: quizUncheckedCreateNestedManyWithoutCourseInput
    quizsubmission?: quizsubmissionUncheckedCreateNestedManyWithoutCourseInput
    roadmapcourse?: roadmapcourseUncheckedCreateNestedManyWithoutCourseInput
  }

  export type courseCreateOrConnectWithoutUsersInput = {
    where: courseWhereUniqueInput
    create: XOR<courseCreateWithoutUsersInput, courseUncheckedCreateWithoutUsersInput>
  }

  export type courseCreateManyUsersInputEnvelope = {
    data: courseCreateManyUsersInput | courseCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type courseprogressCreateWithoutUsersInput = {
    completedVideoCount: number
    completedQuizCount: number
    isCompleted: boolean
    course: courseCreateNestedOneWithoutCourseprogressInput
  }

  export type courseprogressUncheckedCreateWithoutUsersInput = {
    id?: number
    courseId: number
    completedVideoCount: number
    completedQuizCount: number
    isCompleted: boolean
  }

  export type courseprogressCreateOrConnectWithoutUsersInput = {
    where: courseprogressWhereUniqueInput
    create: XOR<courseprogressCreateWithoutUsersInput, courseprogressUncheckedCreateWithoutUsersInput>
  }

  export type courseprogressCreateManyUsersInputEnvelope = {
    data: courseprogressCreateManyUsersInput | courseprogressCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type cvreviewCreateWithoutUsersInput = {
    cvFilePath: string
    cvVersion: number
    reviewResult: string
    relevanceScore: number
    feedback: string
    createdAt?: Date | string
  }

  export type cvreviewUncheckedCreateWithoutUsersInput = {
    id?: number
    cvFilePath: string
    cvVersion: number
    reviewResult: string
    relevanceScore: number
    feedback: string
    createdAt?: Date | string
  }

  export type cvreviewCreateOrConnectWithoutUsersInput = {
    where: cvreviewWhereUniqueInput
    create: XOR<cvreviewCreateWithoutUsersInput, cvreviewUncheckedCreateWithoutUsersInput>
  }

  export type cvreviewCreateManyUsersInputEnvelope = {
    data: cvreviewCreateManyUsersInput | cvreviewCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type enrollmentCreateWithoutUsersInput = {
    enrolledAt?: Date | string
    isPaid: boolean
    course: courseCreateNestedOneWithoutEnrollmentInput
    payment?: paymentCreateNestedOneWithoutEnrollmentInput
  }

  export type enrollmentUncheckedCreateWithoutUsersInput = {
    id?: number
    courseId: number
    enrolledAt?: Date | string
    isPaid: boolean
    paymentId?: number | null
  }

  export type enrollmentCreateOrConnectWithoutUsersInput = {
    where: enrollmentWhereUniqueInput
    create: XOR<enrollmentCreateWithoutUsersInput, enrollmentUncheckedCreateWithoutUsersInput>
  }

  export type enrollmentCreateManyUsersInputEnvelope = {
    data: enrollmentCreateManyUsersInput | enrollmentCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type jobmatchCreateWithoutUsersInput = {
    cvFilePath: string
    matchedJobs: JsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
  }

  export type jobmatchUncheckedCreateWithoutUsersInput = {
    id?: number
    cvFilePath: string
    matchedJobs: JsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
  }

  export type jobmatchCreateOrConnectWithoutUsersInput = {
    where: jobmatchWhereUniqueInput
    create: XOR<jobmatchCreateWithoutUsersInput, jobmatchUncheckedCreateWithoutUsersInput>
  }

  export type jobmatchCreateManyUsersInputEnvelope = {
    data: jobmatchCreateManyUsersInput | jobmatchCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type lessonprogressCreateWithoutUsersInput = {
    isCompleted?: boolean
    updatedAt: Date | string
    lesson: lessonCreateNestedOneWithoutLessonprogressInput
  }

  export type lessonprogressUncheckedCreateWithoutUsersInput = {
    id?: number
    lessonId: number
    isCompleted?: boolean
    updatedAt: Date | string
  }

  export type lessonprogressCreateOrConnectWithoutUsersInput = {
    where: lessonprogressWhereUniqueInput
    create: XOR<lessonprogressCreateWithoutUsersInput, lessonprogressUncheckedCreateWithoutUsersInput>
  }

  export type lessonprogressCreateManyUsersInputEnvelope = {
    data: lessonprogressCreateManyUsersInput | lessonprogressCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type notificationCreateWithoutUsersInput = {
    message: string
    isRead?: boolean
    createdAt?: Date | string
    type: string
  }

  export type notificationUncheckedCreateWithoutUsersInput = {
    id?: number
    message: string
    isRead?: boolean
    createdAt?: Date | string
    type: string
  }

  export type notificationCreateOrConnectWithoutUsersInput = {
    where: notificationWhereUniqueInput
    create: XOR<notificationCreateWithoutUsersInput, notificationUncheckedCreateWithoutUsersInput>
  }

  export type notificationCreateManyUsersInputEnvelope = {
    data: notificationCreateManyUsersInput | notificationCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type paymentCreateWithoutUsersInput = {
    amount: number
    paymentStatus: string
    status: string
    paidAt: Date | string
    createdAt?: Date | string
    orderId?: string | null
    snapToken?: string | null
    enrollment?: enrollmentCreateNestedManyWithoutPaymentInput
    course?: courseCreateNestedOneWithoutPaymentInput
    roadmap?: roadmapCreateNestedOneWithoutPaymentInput
  }

  export type paymentUncheckedCreateWithoutUsersInput = {
    id?: number
    courseId?: number | null
    roadmapId?: number | null
    amount: number
    paymentStatus: string
    status: string
    paidAt: Date | string
    createdAt?: Date | string
    orderId?: string | null
    snapToken?: string | null
    enrollment?: enrollmentUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type paymentCreateOrConnectWithoutUsersInput = {
    where: paymentWhereUniqueInput
    create: XOR<paymentCreateWithoutUsersInput, paymentUncheckedCreateWithoutUsersInput>
  }

  export type paymentCreateManyUsersInputEnvelope = {
    data: paymentCreateManyUsersInput | paymentCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type quizsubmissionCreateWithoutUsersInput = {
    answers: JsonNullValueInput | InputJsonValue
    score: number
    totalQuestions: number
    isPassed: boolean
    createdAt?: Date | string
    course: courseCreateNestedOneWithoutQuizsubmissionInput
    quiz: quizCreateNestedOneWithoutQuizsubmissionInput
  }

  export type quizsubmissionUncheckedCreateWithoutUsersInput = {
    id?: number
    courseId: number
    quizId: number
    answers: JsonNullValueInput | InputJsonValue
    score: number
    totalQuestions: number
    isPassed: boolean
    createdAt?: Date | string
  }

  export type quizsubmissionCreateOrConnectWithoutUsersInput = {
    where: quizsubmissionWhereUniqueInput
    create: XOR<quizsubmissionCreateWithoutUsersInput, quizsubmissionUncheckedCreateWithoutUsersInput>
  }

  export type quizsubmissionCreateManyUsersInputEnvelope = {
    data: quizsubmissionCreateManyUsersInput | quizsubmissionCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type userroadmapCreateWithoutUsersInput = {
    isUnlocked: boolean
    unlockedAt?: Date | string | null
    roadmap: roadmapCreateNestedOneWithoutUserroadmapInput
  }

  export type userroadmapUncheckedCreateWithoutUsersInput = {
    id?: number
    roadmapId: number
    isUnlocked: boolean
    unlockedAt?: Date | string | null
  }

  export type userroadmapCreateOrConnectWithoutUsersInput = {
    where: userroadmapWhereUniqueInput
    create: XOR<userroadmapCreateWithoutUsersInput, userroadmapUncheckedCreateWithoutUsersInput>
  }

  export type userroadmapCreateManyUsersInputEnvelope = {
    data: userroadmapCreateManyUsersInput | userroadmapCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type VoucherCreateWithoutUsersInput = {
    code: string
    discount: number
    expiresAt: Date | string
    isUsed?: boolean
  }

  export type VoucherUncheckedCreateWithoutUsersInput = {
    id?: number
    code: string
    discount: number
    expiresAt: Date | string
    isUsed?: boolean
  }

  export type VoucherCreateOrConnectWithoutUsersInput = {
    where: VoucherWhereUniqueInput
    create: XOR<VoucherCreateWithoutUsersInput, VoucherUncheckedCreateWithoutUsersInput>
  }

  export type VoucherCreateManyUsersInputEnvelope = {
    data: VoucherCreateManyUsersInput | VoucherCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type assessmentUpsertWithWhereUniqueWithoutUsersInput = {
    where: assessmentWhereUniqueInput
    update: XOR<assessmentUpdateWithoutUsersInput, assessmentUncheckedUpdateWithoutUsersInput>
    create: XOR<assessmentCreateWithoutUsersInput, assessmentUncheckedCreateWithoutUsersInput>
  }

  export type assessmentUpdateWithWhereUniqueWithoutUsersInput = {
    where: assessmentWhereUniqueInput
    data: XOR<assessmentUpdateWithoutUsersInput, assessmentUncheckedUpdateWithoutUsersInput>
  }

  export type assessmentUpdateManyWithWhereWithoutUsersInput = {
    where: assessmentScalarWhereInput
    data: XOR<assessmentUpdateManyMutationInput, assessmentUncheckedUpdateManyWithoutUsersInput>
  }

  export type assessmentScalarWhereInput = {
    AND?: assessmentScalarWhereInput | assessmentScalarWhereInput[]
    OR?: assessmentScalarWhereInput[]
    NOT?: assessmentScalarWhereInput | assessmentScalarWhereInput[]
    id?: IntFilter<"assessment"> | number
    userId?: IntFilter<"assessment"> | number
    studentStatus?: StringFilter<"assessment"> | string
    majorStudy?: StringFilter<"assessment"> | string
    currentSemester?: StringFilter<"assessment"> | string
    createdAt?: DateTimeFilter<"assessment"> | Date | string
    currentField?: StringFilter<"assessment"> | string
    dreamJob?: StringFilter<"assessment"> | string
    interestedField?: StringFilter<"assessment"> | string
    mainGoal?: StringFilter<"assessment"> | string
  }

  export type certificateUpsertWithWhereUniqueWithoutUsersInput = {
    where: certificateWhereUniqueInput
    update: XOR<certificateUpdateWithoutUsersInput, certificateUncheckedUpdateWithoutUsersInput>
    create: XOR<certificateCreateWithoutUsersInput, certificateUncheckedCreateWithoutUsersInput>
  }

  export type certificateUpdateWithWhereUniqueWithoutUsersInput = {
    where: certificateWhereUniqueInput
    data: XOR<certificateUpdateWithoutUsersInput, certificateUncheckedUpdateWithoutUsersInput>
  }

  export type certificateUpdateManyWithWhereWithoutUsersInput = {
    where: certificateScalarWhereInput
    data: XOR<certificateUpdateManyMutationInput, certificateUncheckedUpdateManyWithoutUsersInput>
  }

  export type certificateScalarWhereInput = {
    AND?: certificateScalarWhereInput | certificateScalarWhereInput[]
    OR?: certificateScalarWhereInput[]
    NOT?: certificateScalarWhereInput | certificateScalarWhereInput[]
    id?: IntFilter<"certificate"> | number
    userId?: IntFilter<"certificate"> | number
    courseId?: IntFilter<"certificate"> | number
    filePath?: StringFilter<"certificate"> | string
    issuedAt?: DateTimeFilter<"certificate"> | Date | string
  }

  export type chatmessageUpsertWithWhereUniqueWithoutUsersInput = {
    where: chatmessageWhereUniqueInput
    update: XOR<chatmessageUpdateWithoutUsersInput, chatmessageUncheckedUpdateWithoutUsersInput>
    create: XOR<chatmessageCreateWithoutUsersInput, chatmessageUncheckedCreateWithoutUsersInput>
  }

  export type chatmessageUpdateWithWhereUniqueWithoutUsersInput = {
    where: chatmessageWhereUniqueInput
    data: XOR<chatmessageUpdateWithoutUsersInput, chatmessageUncheckedUpdateWithoutUsersInput>
  }

  export type chatmessageUpdateManyWithWhereWithoutUsersInput = {
    where: chatmessageScalarWhereInput
    data: XOR<chatmessageUpdateManyMutationInput, chatmessageUncheckedUpdateManyWithoutUsersInput>
  }

  export type chatmessageScalarWhereInput = {
    AND?: chatmessageScalarWhereInput | chatmessageScalarWhereInput[]
    OR?: chatmessageScalarWhereInput[]
    NOT?: chatmessageScalarWhereInput | chatmessageScalarWhereInput[]
    id?: IntFilter<"chatmessage"> | number
    sessionId?: IntFilter<"chatmessage"> | number
    senderId?: IntFilter<"chatmessage"> | number
    message?: StringFilter<"chatmessage"> | string
    sentAt?: DateTimeFilter<"chatmessage"> | Date | string
  }

  export type counselingsessionUpsertWithWhereUniqueWithoutUsersInput = {
    where: counselingsessionWhereUniqueInput
    update: XOR<counselingsessionUpdateWithoutUsersInput, counselingsessionUncheckedUpdateWithoutUsersInput>
    create: XOR<counselingsessionCreateWithoutUsersInput, counselingsessionUncheckedCreateWithoutUsersInput>
  }

  export type counselingsessionUpdateWithWhereUniqueWithoutUsersInput = {
    where: counselingsessionWhereUniqueInput
    data: XOR<counselingsessionUpdateWithoutUsersInput, counselingsessionUncheckedUpdateWithoutUsersInput>
  }

  export type counselingsessionUpdateManyWithWhereWithoutUsersInput = {
    where: counselingsessionScalarWhereInput
    data: XOR<counselingsessionUpdateManyMutationInput, counselingsessionUncheckedUpdateManyWithoutUsersInput>
  }

  export type counselingsessionScalarWhereInput = {
    AND?: counselingsessionScalarWhereInput | counselingsessionScalarWhereInput[]
    OR?: counselingsessionScalarWhereInput[]
    NOT?: counselingsessionScalarWhereInput | counselingsessionScalarWhereInput[]
    id?: IntFilter<"counselingsession"> | number
    userId?: IntFilter<"counselingsession"> | number
    counselorId?: IntFilter<"counselingsession"> | number
    topic?: StringFilter<"counselingsession"> | string
    question?: StringFilter<"counselingsession"> | string
    response?: StringNullableFilter<"counselingsession"> | string | null
    status?: StringFilter<"counselingsession"> | string
    createdAt?: DateTimeFilter<"counselingsession"> | Date | string
    rating?: IntNullableFilter<"counselingsession"> | number | null
    feedback?: StringNullableFilter<"counselingsession"> | string | null
  }

  export type counselorUpsertWithoutUsersInput = {
    update: XOR<counselorUpdateWithoutUsersInput, counselorUncheckedUpdateWithoutUsersInput>
    create: XOR<counselorCreateWithoutUsersInput, counselorUncheckedCreateWithoutUsersInput>
    where?: counselorWhereInput
  }

  export type counselorUpdateToOneWithWhereWithoutUsersInput = {
    where?: counselorWhereInput
    data: XOR<counselorUpdateWithoutUsersInput, counselorUncheckedUpdateWithoutUsersInput>
  }

  export type counselorUpdateWithoutUsersInput = {
    specialization?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    counselingsession?: counselingsessionUpdateManyWithoutCounselorNestedInput
  }

  export type counselorUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    specialization?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    counselingsession?: counselingsessionUncheckedUpdateManyWithoutCounselorNestedInput
  }

  export type courseUpsertWithWhereUniqueWithoutUsersInput = {
    where: courseWhereUniqueInput
    update: XOR<courseUpdateWithoutUsersInput, courseUncheckedUpdateWithoutUsersInput>
    create: XOR<courseCreateWithoutUsersInput, courseUncheckedCreateWithoutUsersInput>
  }

  export type courseUpdateWithWhereUniqueWithoutUsersInput = {
    where: courseWhereUniqueInput
    data: XOR<courseUpdateWithoutUsersInput, courseUncheckedUpdateWithoutUsersInput>
  }

  export type courseUpdateManyWithWhereWithoutUsersInput = {
    where: courseScalarWhereInput
    data: XOR<courseUpdateManyMutationInput, courseUncheckedUpdateManyWithoutUsersInput>
  }

  export type courseScalarWhereInput = {
    AND?: courseScalarWhereInput | courseScalarWhereInput[]
    OR?: courseScalarWhereInput[]
    NOT?: courseScalarWhereInput | courseScalarWhereInput[]
    id?: IntFilter<"course"> | number
    title?: StringFilter<"course"> | string
    description?: StringFilter<"course"> | string
    thumbnail?: StringFilter<"course"> | string
    categoryId?: IntFilter<"course"> | number
    isPaid?: BoolFilter<"course"> | boolean
    price?: IntFilter<"course"> | number
    createdById?: IntFilter<"course"> | number
    createdAt?: DateTimeFilter<"course"> | Date | string
  }

  export type courseprogressUpsertWithWhereUniqueWithoutUsersInput = {
    where: courseprogressWhereUniqueInput
    update: XOR<courseprogressUpdateWithoutUsersInput, courseprogressUncheckedUpdateWithoutUsersInput>
    create: XOR<courseprogressCreateWithoutUsersInput, courseprogressUncheckedCreateWithoutUsersInput>
  }

  export type courseprogressUpdateWithWhereUniqueWithoutUsersInput = {
    where: courseprogressWhereUniqueInput
    data: XOR<courseprogressUpdateWithoutUsersInput, courseprogressUncheckedUpdateWithoutUsersInput>
  }

  export type courseprogressUpdateManyWithWhereWithoutUsersInput = {
    where: courseprogressScalarWhereInput
    data: XOR<courseprogressUpdateManyMutationInput, courseprogressUncheckedUpdateManyWithoutUsersInput>
  }

  export type courseprogressScalarWhereInput = {
    AND?: courseprogressScalarWhereInput | courseprogressScalarWhereInput[]
    OR?: courseprogressScalarWhereInput[]
    NOT?: courseprogressScalarWhereInput | courseprogressScalarWhereInput[]
    id?: IntFilter<"courseprogress"> | number
    userId?: IntFilter<"courseprogress"> | number
    courseId?: IntFilter<"courseprogress"> | number
    completedVideoCount?: IntFilter<"courseprogress"> | number
    completedQuizCount?: IntFilter<"courseprogress"> | number
    isCompleted?: BoolFilter<"courseprogress"> | boolean
  }

  export type cvreviewUpsertWithWhereUniqueWithoutUsersInput = {
    where: cvreviewWhereUniqueInput
    update: XOR<cvreviewUpdateWithoutUsersInput, cvreviewUncheckedUpdateWithoutUsersInput>
    create: XOR<cvreviewCreateWithoutUsersInput, cvreviewUncheckedCreateWithoutUsersInput>
  }

  export type cvreviewUpdateWithWhereUniqueWithoutUsersInput = {
    where: cvreviewWhereUniqueInput
    data: XOR<cvreviewUpdateWithoutUsersInput, cvreviewUncheckedUpdateWithoutUsersInput>
  }

  export type cvreviewUpdateManyWithWhereWithoutUsersInput = {
    where: cvreviewScalarWhereInput
    data: XOR<cvreviewUpdateManyMutationInput, cvreviewUncheckedUpdateManyWithoutUsersInput>
  }

  export type cvreviewScalarWhereInput = {
    AND?: cvreviewScalarWhereInput | cvreviewScalarWhereInput[]
    OR?: cvreviewScalarWhereInput[]
    NOT?: cvreviewScalarWhereInput | cvreviewScalarWhereInput[]
    id?: IntFilter<"cvreview"> | number
    userId?: IntFilter<"cvreview"> | number
    cvFilePath?: StringFilter<"cvreview"> | string
    cvVersion?: IntFilter<"cvreview"> | number
    reviewResult?: StringFilter<"cvreview"> | string
    relevanceScore?: IntFilter<"cvreview"> | number
    feedback?: StringFilter<"cvreview"> | string
    createdAt?: DateTimeFilter<"cvreview"> | Date | string
  }

  export type enrollmentUpsertWithWhereUniqueWithoutUsersInput = {
    where: enrollmentWhereUniqueInput
    update: XOR<enrollmentUpdateWithoutUsersInput, enrollmentUncheckedUpdateWithoutUsersInput>
    create: XOR<enrollmentCreateWithoutUsersInput, enrollmentUncheckedCreateWithoutUsersInput>
  }

  export type enrollmentUpdateWithWhereUniqueWithoutUsersInput = {
    where: enrollmentWhereUniqueInput
    data: XOR<enrollmentUpdateWithoutUsersInput, enrollmentUncheckedUpdateWithoutUsersInput>
  }

  export type enrollmentUpdateManyWithWhereWithoutUsersInput = {
    where: enrollmentScalarWhereInput
    data: XOR<enrollmentUpdateManyMutationInput, enrollmentUncheckedUpdateManyWithoutUsersInput>
  }

  export type enrollmentScalarWhereInput = {
    AND?: enrollmentScalarWhereInput | enrollmentScalarWhereInput[]
    OR?: enrollmentScalarWhereInput[]
    NOT?: enrollmentScalarWhereInput | enrollmentScalarWhereInput[]
    id?: IntFilter<"enrollment"> | number
    userId?: IntFilter<"enrollment"> | number
    courseId?: IntFilter<"enrollment"> | number
    enrolledAt?: DateTimeFilter<"enrollment"> | Date | string
    isPaid?: BoolFilter<"enrollment"> | boolean
    paymentId?: IntNullableFilter<"enrollment"> | number | null
  }

  export type jobmatchUpsertWithWhereUniqueWithoutUsersInput = {
    where: jobmatchWhereUniqueInput
    update: XOR<jobmatchUpdateWithoutUsersInput, jobmatchUncheckedUpdateWithoutUsersInput>
    create: XOR<jobmatchCreateWithoutUsersInput, jobmatchUncheckedCreateWithoutUsersInput>
  }

  export type jobmatchUpdateWithWhereUniqueWithoutUsersInput = {
    where: jobmatchWhereUniqueInput
    data: XOR<jobmatchUpdateWithoutUsersInput, jobmatchUncheckedUpdateWithoutUsersInput>
  }

  export type jobmatchUpdateManyWithWhereWithoutUsersInput = {
    where: jobmatchScalarWhereInput
    data: XOR<jobmatchUpdateManyMutationInput, jobmatchUncheckedUpdateManyWithoutUsersInput>
  }

  export type jobmatchScalarWhereInput = {
    AND?: jobmatchScalarWhereInput | jobmatchScalarWhereInput[]
    OR?: jobmatchScalarWhereInput[]
    NOT?: jobmatchScalarWhereInput | jobmatchScalarWhereInput[]
    id?: IntFilter<"jobmatch"> | number
    userId?: IntFilter<"jobmatch"> | number
    cvFilePath?: StringFilter<"jobmatch"> | string
    matchedJobs?: JsonFilter<"jobmatch">
    generatedAt?: DateTimeFilter<"jobmatch"> | Date | string
  }

  export type lessonprogressUpsertWithWhereUniqueWithoutUsersInput = {
    where: lessonprogressWhereUniqueInput
    update: XOR<lessonprogressUpdateWithoutUsersInput, lessonprogressUncheckedUpdateWithoutUsersInput>
    create: XOR<lessonprogressCreateWithoutUsersInput, lessonprogressUncheckedCreateWithoutUsersInput>
  }

  export type lessonprogressUpdateWithWhereUniqueWithoutUsersInput = {
    where: lessonprogressWhereUniqueInput
    data: XOR<lessonprogressUpdateWithoutUsersInput, lessonprogressUncheckedUpdateWithoutUsersInput>
  }

  export type lessonprogressUpdateManyWithWhereWithoutUsersInput = {
    where: lessonprogressScalarWhereInput
    data: XOR<lessonprogressUpdateManyMutationInput, lessonprogressUncheckedUpdateManyWithoutUsersInput>
  }

  export type lessonprogressScalarWhereInput = {
    AND?: lessonprogressScalarWhereInput | lessonprogressScalarWhereInput[]
    OR?: lessonprogressScalarWhereInput[]
    NOT?: lessonprogressScalarWhereInput | lessonprogressScalarWhereInput[]
    id?: IntFilter<"lessonprogress"> | number
    userId?: IntFilter<"lessonprogress"> | number
    lessonId?: IntFilter<"lessonprogress"> | number
    isCompleted?: BoolFilter<"lessonprogress"> | boolean
    updatedAt?: DateTimeFilter<"lessonprogress"> | Date | string
  }

  export type notificationUpsertWithWhereUniqueWithoutUsersInput = {
    where: notificationWhereUniqueInput
    update: XOR<notificationUpdateWithoutUsersInput, notificationUncheckedUpdateWithoutUsersInput>
    create: XOR<notificationCreateWithoutUsersInput, notificationUncheckedCreateWithoutUsersInput>
  }

  export type notificationUpdateWithWhereUniqueWithoutUsersInput = {
    where: notificationWhereUniqueInput
    data: XOR<notificationUpdateWithoutUsersInput, notificationUncheckedUpdateWithoutUsersInput>
  }

  export type notificationUpdateManyWithWhereWithoutUsersInput = {
    where: notificationScalarWhereInput
    data: XOR<notificationUpdateManyMutationInput, notificationUncheckedUpdateManyWithoutUsersInput>
  }

  export type notificationScalarWhereInput = {
    AND?: notificationScalarWhereInput | notificationScalarWhereInput[]
    OR?: notificationScalarWhereInput[]
    NOT?: notificationScalarWhereInput | notificationScalarWhereInput[]
    id?: IntFilter<"notification"> | number
    userId?: IntFilter<"notification"> | number
    message?: StringFilter<"notification"> | string
    isRead?: BoolFilter<"notification"> | boolean
    createdAt?: DateTimeFilter<"notification"> | Date | string
    type?: StringFilter<"notification"> | string
  }

  export type paymentUpsertWithWhereUniqueWithoutUsersInput = {
    where: paymentWhereUniqueInput
    update: XOR<paymentUpdateWithoutUsersInput, paymentUncheckedUpdateWithoutUsersInput>
    create: XOR<paymentCreateWithoutUsersInput, paymentUncheckedCreateWithoutUsersInput>
  }

  export type paymentUpdateWithWhereUniqueWithoutUsersInput = {
    where: paymentWhereUniqueInput
    data: XOR<paymentUpdateWithoutUsersInput, paymentUncheckedUpdateWithoutUsersInput>
  }

  export type paymentUpdateManyWithWhereWithoutUsersInput = {
    where: paymentScalarWhereInput
    data: XOR<paymentUpdateManyMutationInput, paymentUncheckedUpdateManyWithoutUsersInput>
  }

  export type paymentScalarWhereInput = {
    AND?: paymentScalarWhereInput | paymentScalarWhereInput[]
    OR?: paymentScalarWhereInput[]
    NOT?: paymentScalarWhereInput | paymentScalarWhereInput[]
    id?: IntFilter<"payment"> | number
    userId?: IntFilter<"payment"> | number
    courseId?: IntNullableFilter<"payment"> | number | null
    roadmapId?: IntNullableFilter<"payment"> | number | null
    amount?: IntFilter<"payment"> | number
    paymentStatus?: StringFilter<"payment"> | string
    status?: StringFilter<"payment"> | string
    paidAt?: DateTimeFilter<"payment"> | Date | string
    createdAt?: DateTimeFilter<"payment"> | Date | string
    orderId?: StringNullableFilter<"payment"> | string | null
    snapToken?: StringNullableFilter<"payment"> | string | null
  }

  export type quizsubmissionUpsertWithWhereUniqueWithoutUsersInput = {
    where: quizsubmissionWhereUniqueInput
    update: XOR<quizsubmissionUpdateWithoutUsersInput, quizsubmissionUncheckedUpdateWithoutUsersInput>
    create: XOR<quizsubmissionCreateWithoutUsersInput, quizsubmissionUncheckedCreateWithoutUsersInput>
  }

  export type quizsubmissionUpdateWithWhereUniqueWithoutUsersInput = {
    where: quizsubmissionWhereUniqueInput
    data: XOR<quizsubmissionUpdateWithoutUsersInput, quizsubmissionUncheckedUpdateWithoutUsersInput>
  }

  export type quizsubmissionUpdateManyWithWhereWithoutUsersInput = {
    where: quizsubmissionScalarWhereInput
    data: XOR<quizsubmissionUpdateManyMutationInput, quizsubmissionUncheckedUpdateManyWithoutUsersInput>
  }

  export type quizsubmissionScalarWhereInput = {
    AND?: quizsubmissionScalarWhereInput | quizsubmissionScalarWhereInput[]
    OR?: quizsubmissionScalarWhereInput[]
    NOT?: quizsubmissionScalarWhereInput | quizsubmissionScalarWhereInput[]
    id?: IntFilter<"quizsubmission"> | number
    userId?: IntFilter<"quizsubmission"> | number
    courseId?: IntFilter<"quizsubmission"> | number
    quizId?: IntFilter<"quizsubmission"> | number
    answers?: JsonFilter<"quizsubmission">
    score?: IntFilter<"quizsubmission"> | number
    totalQuestions?: IntFilter<"quizsubmission"> | number
    isPassed?: BoolFilter<"quizsubmission"> | boolean
    createdAt?: DateTimeFilter<"quizsubmission"> | Date | string
  }

  export type userroadmapUpsertWithWhereUniqueWithoutUsersInput = {
    where: userroadmapWhereUniqueInput
    update: XOR<userroadmapUpdateWithoutUsersInput, userroadmapUncheckedUpdateWithoutUsersInput>
    create: XOR<userroadmapCreateWithoutUsersInput, userroadmapUncheckedCreateWithoutUsersInput>
  }

  export type userroadmapUpdateWithWhereUniqueWithoutUsersInput = {
    where: userroadmapWhereUniqueInput
    data: XOR<userroadmapUpdateWithoutUsersInput, userroadmapUncheckedUpdateWithoutUsersInput>
  }

  export type userroadmapUpdateManyWithWhereWithoutUsersInput = {
    where: userroadmapScalarWhereInput
    data: XOR<userroadmapUpdateManyMutationInput, userroadmapUncheckedUpdateManyWithoutUsersInput>
  }

  export type userroadmapScalarWhereInput = {
    AND?: userroadmapScalarWhereInput | userroadmapScalarWhereInput[]
    OR?: userroadmapScalarWhereInput[]
    NOT?: userroadmapScalarWhereInput | userroadmapScalarWhereInput[]
    id?: IntFilter<"userroadmap"> | number
    userId?: IntFilter<"userroadmap"> | number
    roadmapId?: IntFilter<"userroadmap"> | number
    isUnlocked?: BoolFilter<"userroadmap"> | boolean
    unlockedAt?: DateTimeNullableFilter<"userroadmap"> | Date | string | null
  }

  export type VoucherUpsertWithWhereUniqueWithoutUsersInput = {
    where: VoucherWhereUniqueInput
    update: XOR<VoucherUpdateWithoutUsersInput, VoucherUncheckedUpdateWithoutUsersInput>
    create: XOR<VoucherCreateWithoutUsersInput, VoucherUncheckedCreateWithoutUsersInput>
  }

  export type VoucherUpdateWithWhereUniqueWithoutUsersInput = {
    where: VoucherWhereUniqueInput
    data: XOR<VoucherUpdateWithoutUsersInput, VoucherUncheckedUpdateWithoutUsersInput>
  }

  export type VoucherUpdateManyWithWhereWithoutUsersInput = {
    where: VoucherScalarWhereInput
    data: XOR<VoucherUpdateManyMutationInput, VoucherUncheckedUpdateManyWithoutUsersInput>
  }

  export type VoucherScalarWhereInput = {
    AND?: VoucherScalarWhereInput | VoucherScalarWhereInput[]
    OR?: VoucherScalarWhereInput[]
    NOT?: VoucherScalarWhereInput | VoucherScalarWhereInput[]
    id?: IntFilter<"Voucher"> | number
    code?: StringFilter<"Voucher"> | string
    discount?: IntFilter<"Voucher"> | number
    expiresAt?: DateTimeFilter<"Voucher"> | Date | string
    userId?: IntFilter<"Voucher"> | number
    isUsed?: BoolFilter<"Voucher"> | boolean
  }

  export type UserCreateWithoutAssessmentInput = {
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    address?: string | null
    gender?: string | null
    birthDate?: Date | string | null
    role?: $Enums.Role
    profilePicture?: string | null
    createdAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    certificate?: certificateCreateNestedManyWithoutUsersInput
    chatmessage?: chatmessageCreateNestedManyWithoutUsersInput
    counselingsession?: counselingsessionCreateNestedManyWithoutUsersInput
    counselor?: counselorCreateNestedOneWithoutUsersInput
    course?: courseCreateNestedManyWithoutUsersInput
    courseprogress?: courseprogressCreateNestedManyWithoutUsersInput
    cvreview?: cvreviewCreateNestedManyWithoutUsersInput
    enrollment?: enrollmentCreateNestedManyWithoutUsersInput
    jobmatch?: jobmatchCreateNestedManyWithoutUsersInput
    lessonprogress?: lessonprogressCreateNestedManyWithoutUsersInput
    notification?: notificationCreateNestedManyWithoutUsersInput
    payment?: paymentCreateNestedManyWithoutUsersInput
    quizsubmission?: quizsubmissionCreateNestedManyWithoutUsersInput
    userroadmap?: userroadmapCreateNestedManyWithoutUsersInput
    voucher?: VoucherCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutAssessmentInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    address?: string | null
    gender?: string | null
    birthDate?: Date | string | null
    role?: $Enums.Role
    profilePicture?: string | null
    createdAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    certificate?: certificateUncheckedCreateNestedManyWithoutUsersInput
    chatmessage?: chatmessageUncheckedCreateNestedManyWithoutUsersInput
    counselingsession?: counselingsessionUncheckedCreateNestedManyWithoutUsersInput
    counselor?: counselorUncheckedCreateNestedOneWithoutUsersInput
    course?: courseUncheckedCreateNestedManyWithoutUsersInput
    courseprogress?: courseprogressUncheckedCreateNestedManyWithoutUsersInput
    cvreview?: cvreviewUncheckedCreateNestedManyWithoutUsersInput
    enrollment?: enrollmentUncheckedCreateNestedManyWithoutUsersInput
    jobmatch?: jobmatchUncheckedCreateNestedManyWithoutUsersInput
    lessonprogress?: lessonprogressUncheckedCreateNestedManyWithoutUsersInput
    notification?: notificationUncheckedCreateNestedManyWithoutUsersInput
    payment?: paymentUncheckedCreateNestedManyWithoutUsersInput
    quizsubmission?: quizsubmissionUncheckedCreateNestedManyWithoutUsersInput
    userroadmap?: userroadmapUncheckedCreateNestedManyWithoutUsersInput
    voucher?: VoucherUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutAssessmentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssessmentInput, UserUncheckedCreateWithoutAssessmentInput>
  }

  export type UserUpsertWithoutAssessmentInput = {
    update: XOR<UserUpdateWithoutAssessmentInput, UserUncheckedUpdateWithoutAssessmentInput>
    create: XOR<UserCreateWithoutAssessmentInput, UserUncheckedCreateWithoutAssessmentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssessmentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssessmentInput, UserUncheckedUpdateWithoutAssessmentInput>
  }

  export type UserUpdateWithoutAssessmentInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificate?: certificateUpdateManyWithoutUsersNestedInput
    chatmessage?: chatmessageUpdateManyWithoutUsersNestedInput
    counselingsession?: counselingsessionUpdateManyWithoutUsersNestedInput
    counselor?: counselorUpdateOneWithoutUsersNestedInput
    course?: courseUpdateManyWithoutUsersNestedInput
    courseprogress?: courseprogressUpdateManyWithoutUsersNestedInput
    cvreview?: cvreviewUpdateManyWithoutUsersNestedInput
    enrollment?: enrollmentUpdateManyWithoutUsersNestedInput
    jobmatch?: jobmatchUpdateManyWithoutUsersNestedInput
    lessonprogress?: lessonprogressUpdateManyWithoutUsersNestedInput
    notification?: notificationUpdateManyWithoutUsersNestedInput
    payment?: paymentUpdateManyWithoutUsersNestedInput
    quizsubmission?: quizsubmissionUpdateManyWithoutUsersNestedInput
    userroadmap?: userroadmapUpdateManyWithoutUsersNestedInput
    voucher?: VoucherUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutAssessmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificate?: certificateUncheckedUpdateManyWithoutUsersNestedInput
    chatmessage?: chatmessageUncheckedUpdateManyWithoutUsersNestedInput
    counselingsession?: counselingsessionUncheckedUpdateManyWithoutUsersNestedInput
    counselor?: counselorUncheckedUpdateOneWithoutUsersNestedInput
    course?: courseUncheckedUpdateManyWithoutUsersNestedInput
    courseprogress?: courseprogressUncheckedUpdateManyWithoutUsersNestedInput
    cvreview?: cvreviewUncheckedUpdateManyWithoutUsersNestedInput
    enrollment?: enrollmentUncheckedUpdateManyWithoutUsersNestedInput
    jobmatch?: jobmatchUncheckedUpdateManyWithoutUsersNestedInput
    lessonprogress?: lessonprogressUncheckedUpdateManyWithoutUsersNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUsersNestedInput
    payment?: paymentUncheckedUpdateManyWithoutUsersNestedInput
    quizsubmission?: quizsubmissionUncheckedUpdateManyWithoutUsersNestedInput
    userroadmap?: userroadmapUncheckedUpdateManyWithoutUsersNestedInput
    voucher?: VoucherUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type courseCreateWithoutCategoryInput = {
    title: string
    description: string
    thumbnail: string
    isPaid: boolean
    price: number
    createdAt?: Date | string
    certificate?: certificateCreateNestedManyWithoutCourseInput
    users: UserCreateNestedOneWithoutCourseInput
    courseprogress?: courseprogressCreateNestedManyWithoutCourseInput
    coursevideo?: coursevideoCreateNestedManyWithoutCourseInput
    enrollment?: enrollmentCreateNestedManyWithoutCourseInput
    lesson?: lessonCreateNestedManyWithoutCourseInput
    payment?: paymentCreateNestedManyWithoutCourseInput
    quiz?: quizCreateNestedManyWithoutCourseInput
    quizsubmission?: quizsubmissionCreateNestedManyWithoutCourseInput
    roadmapcourse?: roadmapcourseCreateNestedManyWithoutCourseInput
  }

  export type courseUncheckedCreateWithoutCategoryInput = {
    id?: number
    title: string
    description: string
    thumbnail: string
    isPaid: boolean
    price: number
    createdById: number
    createdAt?: Date | string
    certificate?: certificateUncheckedCreateNestedManyWithoutCourseInput
    courseprogress?: courseprogressUncheckedCreateNestedManyWithoutCourseInput
    coursevideo?: coursevideoUncheckedCreateNestedManyWithoutCourseInput
    enrollment?: enrollmentUncheckedCreateNestedManyWithoutCourseInput
    lesson?: lessonUncheckedCreateNestedManyWithoutCourseInput
    payment?: paymentUncheckedCreateNestedManyWithoutCourseInput
    quiz?: quizUncheckedCreateNestedManyWithoutCourseInput
    quizsubmission?: quizsubmissionUncheckedCreateNestedManyWithoutCourseInput
    roadmapcourse?: roadmapcourseUncheckedCreateNestedManyWithoutCourseInput
  }

  export type courseCreateOrConnectWithoutCategoryInput = {
    where: courseWhereUniqueInput
    create: XOR<courseCreateWithoutCategoryInput, courseUncheckedCreateWithoutCategoryInput>
  }

  export type courseCreateManyCategoryInputEnvelope = {
    data: courseCreateManyCategoryInput | courseCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type courseUpsertWithWhereUniqueWithoutCategoryInput = {
    where: courseWhereUniqueInput
    update: XOR<courseUpdateWithoutCategoryInput, courseUncheckedUpdateWithoutCategoryInput>
    create: XOR<courseCreateWithoutCategoryInput, courseUncheckedCreateWithoutCategoryInput>
  }

  export type courseUpdateWithWhereUniqueWithoutCategoryInput = {
    where: courseWhereUniqueInput
    data: XOR<courseUpdateWithoutCategoryInput, courseUncheckedUpdateWithoutCategoryInput>
  }

  export type courseUpdateManyWithWhereWithoutCategoryInput = {
    where: courseScalarWhereInput
    data: XOR<courseUpdateManyMutationInput, courseUncheckedUpdateManyWithoutCategoryInput>
  }

  export type courseCreateWithoutCertificateInput = {
    title: string
    description: string
    thumbnail: string
    isPaid: boolean
    price: number
    createdAt?: Date | string
    category: categoryCreateNestedOneWithoutCourseInput
    users: UserCreateNestedOneWithoutCourseInput
    courseprogress?: courseprogressCreateNestedManyWithoutCourseInput
    coursevideo?: coursevideoCreateNestedManyWithoutCourseInput
    enrollment?: enrollmentCreateNestedManyWithoutCourseInput
    lesson?: lessonCreateNestedManyWithoutCourseInput
    payment?: paymentCreateNestedManyWithoutCourseInput
    quiz?: quizCreateNestedManyWithoutCourseInput
    quizsubmission?: quizsubmissionCreateNestedManyWithoutCourseInput
    roadmapcourse?: roadmapcourseCreateNestedManyWithoutCourseInput
  }

  export type courseUncheckedCreateWithoutCertificateInput = {
    id?: number
    title: string
    description: string
    thumbnail: string
    categoryId: number
    isPaid: boolean
    price: number
    createdById: number
    createdAt?: Date | string
    courseprogress?: courseprogressUncheckedCreateNestedManyWithoutCourseInput
    coursevideo?: coursevideoUncheckedCreateNestedManyWithoutCourseInput
    enrollment?: enrollmentUncheckedCreateNestedManyWithoutCourseInput
    lesson?: lessonUncheckedCreateNestedManyWithoutCourseInput
    payment?: paymentUncheckedCreateNestedManyWithoutCourseInput
    quiz?: quizUncheckedCreateNestedManyWithoutCourseInput
    quizsubmission?: quizsubmissionUncheckedCreateNestedManyWithoutCourseInput
    roadmapcourse?: roadmapcourseUncheckedCreateNestedManyWithoutCourseInput
  }

  export type courseCreateOrConnectWithoutCertificateInput = {
    where: courseWhereUniqueInput
    create: XOR<courseCreateWithoutCertificateInput, courseUncheckedCreateWithoutCertificateInput>
  }

  export type UserCreateWithoutCertificateInput = {
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    address?: string | null
    gender?: string | null
    birthDate?: Date | string | null
    role?: $Enums.Role
    profilePicture?: string | null
    createdAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    assessment?: assessmentCreateNestedManyWithoutUsersInput
    chatmessage?: chatmessageCreateNestedManyWithoutUsersInput
    counselingsession?: counselingsessionCreateNestedManyWithoutUsersInput
    counselor?: counselorCreateNestedOneWithoutUsersInput
    course?: courseCreateNestedManyWithoutUsersInput
    courseprogress?: courseprogressCreateNestedManyWithoutUsersInput
    cvreview?: cvreviewCreateNestedManyWithoutUsersInput
    enrollment?: enrollmentCreateNestedManyWithoutUsersInput
    jobmatch?: jobmatchCreateNestedManyWithoutUsersInput
    lessonprogress?: lessonprogressCreateNestedManyWithoutUsersInput
    notification?: notificationCreateNestedManyWithoutUsersInput
    payment?: paymentCreateNestedManyWithoutUsersInput
    quizsubmission?: quizsubmissionCreateNestedManyWithoutUsersInput
    userroadmap?: userroadmapCreateNestedManyWithoutUsersInput
    voucher?: VoucherCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutCertificateInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    address?: string | null
    gender?: string | null
    birthDate?: Date | string | null
    role?: $Enums.Role
    profilePicture?: string | null
    createdAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    assessment?: assessmentUncheckedCreateNestedManyWithoutUsersInput
    chatmessage?: chatmessageUncheckedCreateNestedManyWithoutUsersInput
    counselingsession?: counselingsessionUncheckedCreateNestedManyWithoutUsersInput
    counselor?: counselorUncheckedCreateNestedOneWithoutUsersInput
    course?: courseUncheckedCreateNestedManyWithoutUsersInput
    courseprogress?: courseprogressUncheckedCreateNestedManyWithoutUsersInput
    cvreview?: cvreviewUncheckedCreateNestedManyWithoutUsersInput
    enrollment?: enrollmentUncheckedCreateNestedManyWithoutUsersInput
    jobmatch?: jobmatchUncheckedCreateNestedManyWithoutUsersInput
    lessonprogress?: lessonprogressUncheckedCreateNestedManyWithoutUsersInput
    notification?: notificationUncheckedCreateNestedManyWithoutUsersInput
    payment?: paymentUncheckedCreateNestedManyWithoutUsersInput
    quizsubmission?: quizsubmissionUncheckedCreateNestedManyWithoutUsersInput
    userroadmap?: userroadmapUncheckedCreateNestedManyWithoutUsersInput
    voucher?: VoucherUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutCertificateInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCertificateInput, UserUncheckedCreateWithoutCertificateInput>
  }

  export type courseUpsertWithoutCertificateInput = {
    update: XOR<courseUpdateWithoutCertificateInput, courseUncheckedUpdateWithoutCertificateInput>
    create: XOR<courseCreateWithoutCertificateInput, courseUncheckedCreateWithoutCertificateInput>
    where?: courseWhereInput
  }

  export type courseUpdateToOneWithWhereWithoutCertificateInput = {
    where?: courseWhereInput
    data: XOR<courseUpdateWithoutCertificateInput, courseUncheckedUpdateWithoutCertificateInput>
  }

  export type courseUpdateWithoutCertificateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: categoryUpdateOneRequiredWithoutCourseNestedInput
    users?: UserUpdateOneRequiredWithoutCourseNestedInput
    courseprogress?: courseprogressUpdateManyWithoutCourseNestedInput
    coursevideo?: coursevideoUpdateManyWithoutCourseNestedInput
    enrollment?: enrollmentUpdateManyWithoutCourseNestedInput
    lesson?: lessonUpdateManyWithoutCourseNestedInput
    payment?: paymentUpdateManyWithoutCourseNestedInput
    quiz?: quizUpdateManyWithoutCourseNestedInput
    quizsubmission?: quizsubmissionUpdateManyWithoutCourseNestedInput
    roadmapcourse?: roadmapcourseUpdateManyWithoutCourseNestedInput
  }

  export type courseUncheckedUpdateWithoutCertificateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseprogress?: courseprogressUncheckedUpdateManyWithoutCourseNestedInput
    coursevideo?: coursevideoUncheckedUpdateManyWithoutCourseNestedInput
    enrollment?: enrollmentUncheckedUpdateManyWithoutCourseNestedInput
    lesson?: lessonUncheckedUpdateManyWithoutCourseNestedInput
    payment?: paymentUncheckedUpdateManyWithoutCourseNestedInput
    quiz?: quizUncheckedUpdateManyWithoutCourseNestedInput
    quizsubmission?: quizsubmissionUncheckedUpdateManyWithoutCourseNestedInput
    roadmapcourse?: roadmapcourseUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type UserUpsertWithoutCertificateInput = {
    update: XOR<UserUpdateWithoutCertificateInput, UserUncheckedUpdateWithoutCertificateInput>
    create: XOR<UserCreateWithoutCertificateInput, UserUncheckedCreateWithoutCertificateInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCertificateInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCertificateInput, UserUncheckedUpdateWithoutCertificateInput>
  }

  export type UserUpdateWithoutCertificateInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assessment?: assessmentUpdateManyWithoutUsersNestedInput
    chatmessage?: chatmessageUpdateManyWithoutUsersNestedInput
    counselingsession?: counselingsessionUpdateManyWithoutUsersNestedInput
    counselor?: counselorUpdateOneWithoutUsersNestedInput
    course?: courseUpdateManyWithoutUsersNestedInput
    courseprogress?: courseprogressUpdateManyWithoutUsersNestedInput
    cvreview?: cvreviewUpdateManyWithoutUsersNestedInput
    enrollment?: enrollmentUpdateManyWithoutUsersNestedInput
    jobmatch?: jobmatchUpdateManyWithoutUsersNestedInput
    lessonprogress?: lessonprogressUpdateManyWithoutUsersNestedInput
    notification?: notificationUpdateManyWithoutUsersNestedInput
    payment?: paymentUpdateManyWithoutUsersNestedInput
    quizsubmission?: quizsubmissionUpdateManyWithoutUsersNestedInput
    userroadmap?: userroadmapUpdateManyWithoutUsersNestedInput
    voucher?: VoucherUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutCertificateInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assessment?: assessmentUncheckedUpdateManyWithoutUsersNestedInput
    chatmessage?: chatmessageUncheckedUpdateManyWithoutUsersNestedInput
    counselingsession?: counselingsessionUncheckedUpdateManyWithoutUsersNestedInput
    counselor?: counselorUncheckedUpdateOneWithoutUsersNestedInput
    course?: courseUncheckedUpdateManyWithoutUsersNestedInput
    courseprogress?: courseprogressUncheckedUpdateManyWithoutUsersNestedInput
    cvreview?: cvreviewUncheckedUpdateManyWithoutUsersNestedInput
    enrollment?: enrollmentUncheckedUpdateManyWithoutUsersNestedInput
    jobmatch?: jobmatchUncheckedUpdateManyWithoutUsersNestedInput
    lessonprogress?: lessonprogressUncheckedUpdateManyWithoutUsersNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUsersNestedInput
    payment?: paymentUncheckedUpdateManyWithoutUsersNestedInput
    quizsubmission?: quizsubmissionUncheckedUpdateManyWithoutUsersNestedInput
    userroadmap?: userroadmapUncheckedUpdateManyWithoutUsersNestedInput
    voucher?: VoucherUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UserCreateWithoutChatmessageInput = {
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    address?: string | null
    gender?: string | null
    birthDate?: Date | string | null
    role?: $Enums.Role
    profilePicture?: string | null
    createdAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    assessment?: assessmentCreateNestedManyWithoutUsersInput
    certificate?: certificateCreateNestedManyWithoutUsersInput
    counselingsession?: counselingsessionCreateNestedManyWithoutUsersInput
    counselor?: counselorCreateNestedOneWithoutUsersInput
    course?: courseCreateNestedManyWithoutUsersInput
    courseprogress?: courseprogressCreateNestedManyWithoutUsersInput
    cvreview?: cvreviewCreateNestedManyWithoutUsersInput
    enrollment?: enrollmentCreateNestedManyWithoutUsersInput
    jobmatch?: jobmatchCreateNestedManyWithoutUsersInput
    lessonprogress?: lessonprogressCreateNestedManyWithoutUsersInput
    notification?: notificationCreateNestedManyWithoutUsersInput
    payment?: paymentCreateNestedManyWithoutUsersInput
    quizsubmission?: quizsubmissionCreateNestedManyWithoutUsersInput
    userroadmap?: userroadmapCreateNestedManyWithoutUsersInput
    voucher?: VoucherCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutChatmessageInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    address?: string | null
    gender?: string | null
    birthDate?: Date | string | null
    role?: $Enums.Role
    profilePicture?: string | null
    createdAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    assessment?: assessmentUncheckedCreateNestedManyWithoutUsersInput
    certificate?: certificateUncheckedCreateNestedManyWithoutUsersInput
    counselingsession?: counselingsessionUncheckedCreateNestedManyWithoutUsersInput
    counselor?: counselorUncheckedCreateNestedOneWithoutUsersInput
    course?: courseUncheckedCreateNestedManyWithoutUsersInput
    courseprogress?: courseprogressUncheckedCreateNestedManyWithoutUsersInput
    cvreview?: cvreviewUncheckedCreateNestedManyWithoutUsersInput
    enrollment?: enrollmentUncheckedCreateNestedManyWithoutUsersInput
    jobmatch?: jobmatchUncheckedCreateNestedManyWithoutUsersInput
    lessonprogress?: lessonprogressUncheckedCreateNestedManyWithoutUsersInput
    notification?: notificationUncheckedCreateNestedManyWithoutUsersInput
    payment?: paymentUncheckedCreateNestedManyWithoutUsersInput
    quizsubmission?: quizsubmissionUncheckedCreateNestedManyWithoutUsersInput
    userroadmap?: userroadmapUncheckedCreateNestedManyWithoutUsersInput
    voucher?: VoucherUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutChatmessageInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChatmessageInput, UserUncheckedCreateWithoutChatmessageInput>
  }

  export type counselingsessionCreateWithoutChatmessageInput = {
    topic: string
    question: string
    response?: string | null
    status: string
    createdAt?: Date | string
    rating?: number | null
    feedback?: string | null
    counselor: counselorCreateNestedOneWithoutCounselingsessionInput
    users: UserCreateNestedOneWithoutCounselingsessionInput
  }

  export type counselingsessionUncheckedCreateWithoutChatmessageInput = {
    id?: number
    userId: number
    counselorId: number
    topic: string
    question: string
    response?: string | null
    status: string
    createdAt?: Date | string
    rating?: number | null
    feedback?: string | null
  }

  export type counselingsessionCreateOrConnectWithoutChatmessageInput = {
    where: counselingsessionWhereUniqueInput
    create: XOR<counselingsessionCreateWithoutChatmessageInput, counselingsessionUncheckedCreateWithoutChatmessageInput>
  }

  export type UserUpsertWithoutChatmessageInput = {
    update: XOR<UserUpdateWithoutChatmessageInput, UserUncheckedUpdateWithoutChatmessageInput>
    create: XOR<UserCreateWithoutChatmessageInput, UserUncheckedCreateWithoutChatmessageInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChatmessageInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChatmessageInput, UserUncheckedUpdateWithoutChatmessageInput>
  }

  export type UserUpdateWithoutChatmessageInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assessment?: assessmentUpdateManyWithoutUsersNestedInput
    certificate?: certificateUpdateManyWithoutUsersNestedInput
    counselingsession?: counselingsessionUpdateManyWithoutUsersNestedInput
    counselor?: counselorUpdateOneWithoutUsersNestedInput
    course?: courseUpdateManyWithoutUsersNestedInput
    courseprogress?: courseprogressUpdateManyWithoutUsersNestedInput
    cvreview?: cvreviewUpdateManyWithoutUsersNestedInput
    enrollment?: enrollmentUpdateManyWithoutUsersNestedInput
    jobmatch?: jobmatchUpdateManyWithoutUsersNestedInput
    lessonprogress?: lessonprogressUpdateManyWithoutUsersNestedInput
    notification?: notificationUpdateManyWithoutUsersNestedInput
    payment?: paymentUpdateManyWithoutUsersNestedInput
    quizsubmission?: quizsubmissionUpdateManyWithoutUsersNestedInput
    userroadmap?: userroadmapUpdateManyWithoutUsersNestedInput
    voucher?: VoucherUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutChatmessageInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assessment?: assessmentUncheckedUpdateManyWithoutUsersNestedInput
    certificate?: certificateUncheckedUpdateManyWithoutUsersNestedInput
    counselingsession?: counselingsessionUncheckedUpdateManyWithoutUsersNestedInput
    counselor?: counselorUncheckedUpdateOneWithoutUsersNestedInput
    course?: courseUncheckedUpdateManyWithoutUsersNestedInput
    courseprogress?: courseprogressUncheckedUpdateManyWithoutUsersNestedInput
    cvreview?: cvreviewUncheckedUpdateManyWithoutUsersNestedInput
    enrollment?: enrollmentUncheckedUpdateManyWithoutUsersNestedInput
    jobmatch?: jobmatchUncheckedUpdateManyWithoutUsersNestedInput
    lessonprogress?: lessonprogressUncheckedUpdateManyWithoutUsersNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUsersNestedInput
    payment?: paymentUncheckedUpdateManyWithoutUsersNestedInput
    quizsubmission?: quizsubmissionUncheckedUpdateManyWithoutUsersNestedInput
    userroadmap?: userroadmapUncheckedUpdateManyWithoutUsersNestedInput
    voucher?: VoucherUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type counselingsessionUpsertWithoutChatmessageInput = {
    update: XOR<counselingsessionUpdateWithoutChatmessageInput, counselingsessionUncheckedUpdateWithoutChatmessageInput>
    create: XOR<counselingsessionCreateWithoutChatmessageInput, counselingsessionUncheckedCreateWithoutChatmessageInput>
    where?: counselingsessionWhereInput
  }

  export type counselingsessionUpdateToOneWithWhereWithoutChatmessageInput = {
    where?: counselingsessionWhereInput
    data: XOR<counselingsessionUpdateWithoutChatmessageInput, counselingsessionUncheckedUpdateWithoutChatmessageInput>
  }

  export type counselingsessionUpdateWithoutChatmessageInput = {
    topic?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    counselor?: counselorUpdateOneRequiredWithoutCounselingsessionNestedInput
    users?: UserUpdateOneRequiredWithoutCounselingsessionNestedInput
  }

  export type counselingsessionUncheckedUpdateWithoutChatmessageInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    counselorId?: IntFieldUpdateOperationsInput | number
    topic?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chatmessageCreateWithoutCounselingsessionInput = {
    message: string
    sentAt?: Date | string
    users: UserCreateNestedOneWithoutChatmessageInput
  }

  export type chatmessageUncheckedCreateWithoutCounselingsessionInput = {
    id?: number
    senderId: number
    message: string
    sentAt?: Date | string
  }

  export type chatmessageCreateOrConnectWithoutCounselingsessionInput = {
    where: chatmessageWhereUniqueInput
    create: XOR<chatmessageCreateWithoutCounselingsessionInput, chatmessageUncheckedCreateWithoutCounselingsessionInput>
  }

  export type chatmessageCreateManyCounselingsessionInputEnvelope = {
    data: chatmessageCreateManyCounselingsessionInput | chatmessageCreateManyCounselingsessionInput[]
    skipDuplicates?: boolean
  }

  export type counselorCreateWithoutCounselingsessionInput = {
    specialization: string
    bio: string
    verified: boolean
    users: UserCreateNestedOneWithoutCounselorInput
  }

  export type counselorUncheckedCreateWithoutCounselingsessionInput = {
    id?: number
    userId: number
    specialization: string
    bio: string
    verified: boolean
  }

  export type counselorCreateOrConnectWithoutCounselingsessionInput = {
    where: counselorWhereUniqueInput
    create: XOR<counselorCreateWithoutCounselingsessionInput, counselorUncheckedCreateWithoutCounselingsessionInput>
  }

  export type UserCreateWithoutCounselingsessionInput = {
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    address?: string | null
    gender?: string | null
    birthDate?: Date | string | null
    role?: $Enums.Role
    profilePicture?: string | null
    createdAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    assessment?: assessmentCreateNestedManyWithoutUsersInput
    certificate?: certificateCreateNestedManyWithoutUsersInput
    chatmessage?: chatmessageCreateNestedManyWithoutUsersInput
    counselor?: counselorCreateNestedOneWithoutUsersInput
    course?: courseCreateNestedManyWithoutUsersInput
    courseprogress?: courseprogressCreateNestedManyWithoutUsersInput
    cvreview?: cvreviewCreateNestedManyWithoutUsersInput
    enrollment?: enrollmentCreateNestedManyWithoutUsersInput
    jobmatch?: jobmatchCreateNestedManyWithoutUsersInput
    lessonprogress?: lessonprogressCreateNestedManyWithoutUsersInput
    notification?: notificationCreateNestedManyWithoutUsersInput
    payment?: paymentCreateNestedManyWithoutUsersInput
    quizsubmission?: quizsubmissionCreateNestedManyWithoutUsersInput
    userroadmap?: userroadmapCreateNestedManyWithoutUsersInput
    voucher?: VoucherCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutCounselingsessionInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    address?: string | null
    gender?: string | null
    birthDate?: Date | string | null
    role?: $Enums.Role
    profilePicture?: string | null
    createdAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    assessment?: assessmentUncheckedCreateNestedManyWithoutUsersInput
    certificate?: certificateUncheckedCreateNestedManyWithoutUsersInput
    chatmessage?: chatmessageUncheckedCreateNestedManyWithoutUsersInput
    counselor?: counselorUncheckedCreateNestedOneWithoutUsersInput
    course?: courseUncheckedCreateNestedManyWithoutUsersInput
    courseprogress?: courseprogressUncheckedCreateNestedManyWithoutUsersInput
    cvreview?: cvreviewUncheckedCreateNestedManyWithoutUsersInput
    enrollment?: enrollmentUncheckedCreateNestedManyWithoutUsersInput
    jobmatch?: jobmatchUncheckedCreateNestedManyWithoutUsersInput
    lessonprogress?: lessonprogressUncheckedCreateNestedManyWithoutUsersInput
    notification?: notificationUncheckedCreateNestedManyWithoutUsersInput
    payment?: paymentUncheckedCreateNestedManyWithoutUsersInput
    quizsubmission?: quizsubmissionUncheckedCreateNestedManyWithoutUsersInput
    userroadmap?: userroadmapUncheckedCreateNestedManyWithoutUsersInput
    voucher?: VoucherUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutCounselingsessionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCounselingsessionInput, UserUncheckedCreateWithoutCounselingsessionInput>
  }

  export type chatmessageUpsertWithWhereUniqueWithoutCounselingsessionInput = {
    where: chatmessageWhereUniqueInput
    update: XOR<chatmessageUpdateWithoutCounselingsessionInput, chatmessageUncheckedUpdateWithoutCounselingsessionInput>
    create: XOR<chatmessageCreateWithoutCounselingsessionInput, chatmessageUncheckedCreateWithoutCounselingsessionInput>
  }

  export type chatmessageUpdateWithWhereUniqueWithoutCounselingsessionInput = {
    where: chatmessageWhereUniqueInput
    data: XOR<chatmessageUpdateWithoutCounselingsessionInput, chatmessageUncheckedUpdateWithoutCounselingsessionInput>
  }

  export type chatmessageUpdateManyWithWhereWithoutCounselingsessionInput = {
    where: chatmessageScalarWhereInput
    data: XOR<chatmessageUpdateManyMutationInput, chatmessageUncheckedUpdateManyWithoutCounselingsessionInput>
  }

  export type counselorUpsertWithoutCounselingsessionInput = {
    update: XOR<counselorUpdateWithoutCounselingsessionInput, counselorUncheckedUpdateWithoutCounselingsessionInput>
    create: XOR<counselorCreateWithoutCounselingsessionInput, counselorUncheckedCreateWithoutCounselingsessionInput>
    where?: counselorWhereInput
  }

  export type counselorUpdateToOneWithWhereWithoutCounselingsessionInput = {
    where?: counselorWhereInput
    data: XOR<counselorUpdateWithoutCounselingsessionInput, counselorUncheckedUpdateWithoutCounselingsessionInput>
  }

  export type counselorUpdateWithoutCounselingsessionInput = {
    specialization?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    users?: UserUpdateOneRequiredWithoutCounselorNestedInput
  }

  export type counselorUncheckedUpdateWithoutCounselingsessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    specialization?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUpsertWithoutCounselingsessionInput = {
    update: XOR<UserUpdateWithoutCounselingsessionInput, UserUncheckedUpdateWithoutCounselingsessionInput>
    create: XOR<UserCreateWithoutCounselingsessionInput, UserUncheckedCreateWithoutCounselingsessionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCounselingsessionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCounselingsessionInput, UserUncheckedUpdateWithoutCounselingsessionInput>
  }

  export type UserUpdateWithoutCounselingsessionInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assessment?: assessmentUpdateManyWithoutUsersNestedInput
    certificate?: certificateUpdateManyWithoutUsersNestedInput
    chatmessage?: chatmessageUpdateManyWithoutUsersNestedInput
    counselor?: counselorUpdateOneWithoutUsersNestedInput
    course?: courseUpdateManyWithoutUsersNestedInput
    courseprogress?: courseprogressUpdateManyWithoutUsersNestedInput
    cvreview?: cvreviewUpdateManyWithoutUsersNestedInput
    enrollment?: enrollmentUpdateManyWithoutUsersNestedInput
    jobmatch?: jobmatchUpdateManyWithoutUsersNestedInput
    lessonprogress?: lessonprogressUpdateManyWithoutUsersNestedInput
    notification?: notificationUpdateManyWithoutUsersNestedInput
    payment?: paymentUpdateManyWithoutUsersNestedInput
    quizsubmission?: quizsubmissionUpdateManyWithoutUsersNestedInput
    userroadmap?: userroadmapUpdateManyWithoutUsersNestedInput
    voucher?: VoucherUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutCounselingsessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assessment?: assessmentUncheckedUpdateManyWithoutUsersNestedInput
    certificate?: certificateUncheckedUpdateManyWithoutUsersNestedInput
    chatmessage?: chatmessageUncheckedUpdateManyWithoutUsersNestedInput
    counselor?: counselorUncheckedUpdateOneWithoutUsersNestedInput
    course?: courseUncheckedUpdateManyWithoutUsersNestedInput
    courseprogress?: courseprogressUncheckedUpdateManyWithoutUsersNestedInput
    cvreview?: cvreviewUncheckedUpdateManyWithoutUsersNestedInput
    enrollment?: enrollmentUncheckedUpdateManyWithoutUsersNestedInput
    jobmatch?: jobmatchUncheckedUpdateManyWithoutUsersNestedInput
    lessonprogress?: lessonprogressUncheckedUpdateManyWithoutUsersNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUsersNestedInput
    payment?: paymentUncheckedUpdateManyWithoutUsersNestedInput
    quizsubmission?: quizsubmissionUncheckedUpdateManyWithoutUsersNestedInput
    userroadmap?: userroadmapUncheckedUpdateManyWithoutUsersNestedInput
    voucher?: VoucherUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type counselingsessionCreateWithoutCounselorInput = {
    topic: string
    question: string
    response?: string | null
    status: string
    createdAt?: Date | string
    rating?: number | null
    feedback?: string | null
    chatmessage?: chatmessageCreateNestedManyWithoutCounselingsessionInput
    users: UserCreateNestedOneWithoutCounselingsessionInput
  }

  export type counselingsessionUncheckedCreateWithoutCounselorInput = {
    id?: number
    userId: number
    topic: string
    question: string
    response?: string | null
    status: string
    createdAt?: Date | string
    rating?: number | null
    feedback?: string | null
    chatmessage?: chatmessageUncheckedCreateNestedManyWithoutCounselingsessionInput
  }

  export type counselingsessionCreateOrConnectWithoutCounselorInput = {
    where: counselingsessionWhereUniqueInput
    create: XOR<counselingsessionCreateWithoutCounselorInput, counselingsessionUncheckedCreateWithoutCounselorInput>
  }

  export type counselingsessionCreateManyCounselorInputEnvelope = {
    data: counselingsessionCreateManyCounselorInput | counselingsessionCreateManyCounselorInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutCounselorInput = {
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    address?: string | null
    gender?: string | null
    birthDate?: Date | string | null
    role?: $Enums.Role
    profilePicture?: string | null
    createdAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    assessment?: assessmentCreateNestedManyWithoutUsersInput
    certificate?: certificateCreateNestedManyWithoutUsersInput
    chatmessage?: chatmessageCreateNestedManyWithoutUsersInput
    counselingsession?: counselingsessionCreateNestedManyWithoutUsersInput
    course?: courseCreateNestedManyWithoutUsersInput
    courseprogress?: courseprogressCreateNestedManyWithoutUsersInput
    cvreview?: cvreviewCreateNestedManyWithoutUsersInput
    enrollment?: enrollmentCreateNestedManyWithoutUsersInput
    jobmatch?: jobmatchCreateNestedManyWithoutUsersInput
    lessonprogress?: lessonprogressCreateNestedManyWithoutUsersInput
    notification?: notificationCreateNestedManyWithoutUsersInput
    payment?: paymentCreateNestedManyWithoutUsersInput
    quizsubmission?: quizsubmissionCreateNestedManyWithoutUsersInput
    userroadmap?: userroadmapCreateNestedManyWithoutUsersInput
    voucher?: VoucherCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutCounselorInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    address?: string | null
    gender?: string | null
    birthDate?: Date | string | null
    role?: $Enums.Role
    profilePicture?: string | null
    createdAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    assessment?: assessmentUncheckedCreateNestedManyWithoutUsersInput
    certificate?: certificateUncheckedCreateNestedManyWithoutUsersInput
    chatmessage?: chatmessageUncheckedCreateNestedManyWithoutUsersInput
    counselingsession?: counselingsessionUncheckedCreateNestedManyWithoutUsersInput
    course?: courseUncheckedCreateNestedManyWithoutUsersInput
    courseprogress?: courseprogressUncheckedCreateNestedManyWithoutUsersInput
    cvreview?: cvreviewUncheckedCreateNestedManyWithoutUsersInput
    enrollment?: enrollmentUncheckedCreateNestedManyWithoutUsersInput
    jobmatch?: jobmatchUncheckedCreateNestedManyWithoutUsersInput
    lessonprogress?: lessonprogressUncheckedCreateNestedManyWithoutUsersInput
    notification?: notificationUncheckedCreateNestedManyWithoutUsersInput
    payment?: paymentUncheckedCreateNestedManyWithoutUsersInput
    quizsubmission?: quizsubmissionUncheckedCreateNestedManyWithoutUsersInput
    userroadmap?: userroadmapUncheckedCreateNestedManyWithoutUsersInput
    voucher?: VoucherUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutCounselorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCounselorInput, UserUncheckedCreateWithoutCounselorInput>
  }

  export type counselingsessionUpsertWithWhereUniqueWithoutCounselorInput = {
    where: counselingsessionWhereUniqueInput
    update: XOR<counselingsessionUpdateWithoutCounselorInput, counselingsessionUncheckedUpdateWithoutCounselorInput>
    create: XOR<counselingsessionCreateWithoutCounselorInput, counselingsessionUncheckedCreateWithoutCounselorInput>
  }

  export type counselingsessionUpdateWithWhereUniqueWithoutCounselorInput = {
    where: counselingsessionWhereUniqueInput
    data: XOR<counselingsessionUpdateWithoutCounselorInput, counselingsessionUncheckedUpdateWithoutCounselorInput>
  }

  export type counselingsessionUpdateManyWithWhereWithoutCounselorInput = {
    where: counselingsessionScalarWhereInput
    data: XOR<counselingsessionUpdateManyMutationInput, counselingsessionUncheckedUpdateManyWithoutCounselorInput>
  }

  export type UserUpsertWithoutCounselorInput = {
    update: XOR<UserUpdateWithoutCounselorInput, UserUncheckedUpdateWithoutCounselorInput>
    create: XOR<UserCreateWithoutCounselorInput, UserUncheckedCreateWithoutCounselorInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCounselorInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCounselorInput, UserUncheckedUpdateWithoutCounselorInput>
  }

  export type UserUpdateWithoutCounselorInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assessment?: assessmentUpdateManyWithoutUsersNestedInput
    certificate?: certificateUpdateManyWithoutUsersNestedInput
    chatmessage?: chatmessageUpdateManyWithoutUsersNestedInput
    counselingsession?: counselingsessionUpdateManyWithoutUsersNestedInput
    course?: courseUpdateManyWithoutUsersNestedInput
    courseprogress?: courseprogressUpdateManyWithoutUsersNestedInput
    cvreview?: cvreviewUpdateManyWithoutUsersNestedInput
    enrollment?: enrollmentUpdateManyWithoutUsersNestedInput
    jobmatch?: jobmatchUpdateManyWithoutUsersNestedInput
    lessonprogress?: lessonprogressUpdateManyWithoutUsersNestedInput
    notification?: notificationUpdateManyWithoutUsersNestedInput
    payment?: paymentUpdateManyWithoutUsersNestedInput
    quizsubmission?: quizsubmissionUpdateManyWithoutUsersNestedInput
    userroadmap?: userroadmapUpdateManyWithoutUsersNestedInput
    voucher?: VoucherUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutCounselorInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assessment?: assessmentUncheckedUpdateManyWithoutUsersNestedInput
    certificate?: certificateUncheckedUpdateManyWithoutUsersNestedInput
    chatmessage?: chatmessageUncheckedUpdateManyWithoutUsersNestedInput
    counselingsession?: counselingsessionUncheckedUpdateManyWithoutUsersNestedInput
    course?: courseUncheckedUpdateManyWithoutUsersNestedInput
    courseprogress?: courseprogressUncheckedUpdateManyWithoutUsersNestedInput
    cvreview?: cvreviewUncheckedUpdateManyWithoutUsersNestedInput
    enrollment?: enrollmentUncheckedUpdateManyWithoutUsersNestedInput
    jobmatch?: jobmatchUncheckedUpdateManyWithoutUsersNestedInput
    lessonprogress?: lessonprogressUncheckedUpdateManyWithoutUsersNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUsersNestedInput
    payment?: paymentUncheckedUpdateManyWithoutUsersNestedInput
    quizsubmission?: quizsubmissionUncheckedUpdateManyWithoutUsersNestedInput
    userroadmap?: userroadmapUncheckedUpdateManyWithoutUsersNestedInput
    voucher?: VoucherUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type certificateCreateWithoutCourseInput = {
    filePath: string
    issuedAt: Date | string
    users: UserCreateNestedOneWithoutCertificateInput
  }

  export type certificateUncheckedCreateWithoutCourseInput = {
    id?: number
    userId: number
    filePath: string
    issuedAt: Date | string
  }

  export type certificateCreateOrConnectWithoutCourseInput = {
    where: certificateWhereUniqueInput
    create: XOR<certificateCreateWithoutCourseInput, certificateUncheckedCreateWithoutCourseInput>
  }

  export type certificateCreateManyCourseInputEnvelope = {
    data: certificateCreateManyCourseInput | certificateCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type categoryCreateWithoutCourseInput = {
    name: string
  }

  export type categoryUncheckedCreateWithoutCourseInput = {
    id?: number
    name: string
  }

  export type categoryCreateOrConnectWithoutCourseInput = {
    where: categoryWhereUniqueInput
    create: XOR<categoryCreateWithoutCourseInput, categoryUncheckedCreateWithoutCourseInput>
  }

  export type UserCreateWithoutCourseInput = {
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    address?: string | null
    gender?: string | null
    birthDate?: Date | string | null
    role?: $Enums.Role
    profilePicture?: string | null
    createdAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    assessment?: assessmentCreateNestedManyWithoutUsersInput
    certificate?: certificateCreateNestedManyWithoutUsersInput
    chatmessage?: chatmessageCreateNestedManyWithoutUsersInput
    counselingsession?: counselingsessionCreateNestedManyWithoutUsersInput
    counselor?: counselorCreateNestedOneWithoutUsersInput
    courseprogress?: courseprogressCreateNestedManyWithoutUsersInput
    cvreview?: cvreviewCreateNestedManyWithoutUsersInput
    enrollment?: enrollmentCreateNestedManyWithoutUsersInput
    jobmatch?: jobmatchCreateNestedManyWithoutUsersInput
    lessonprogress?: lessonprogressCreateNestedManyWithoutUsersInput
    notification?: notificationCreateNestedManyWithoutUsersInput
    payment?: paymentCreateNestedManyWithoutUsersInput
    quizsubmission?: quizsubmissionCreateNestedManyWithoutUsersInput
    userroadmap?: userroadmapCreateNestedManyWithoutUsersInput
    voucher?: VoucherCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutCourseInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    address?: string | null
    gender?: string | null
    birthDate?: Date | string | null
    role?: $Enums.Role
    profilePicture?: string | null
    createdAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    assessment?: assessmentUncheckedCreateNestedManyWithoutUsersInput
    certificate?: certificateUncheckedCreateNestedManyWithoutUsersInput
    chatmessage?: chatmessageUncheckedCreateNestedManyWithoutUsersInput
    counselingsession?: counselingsessionUncheckedCreateNestedManyWithoutUsersInput
    counselor?: counselorUncheckedCreateNestedOneWithoutUsersInput
    courseprogress?: courseprogressUncheckedCreateNestedManyWithoutUsersInput
    cvreview?: cvreviewUncheckedCreateNestedManyWithoutUsersInput
    enrollment?: enrollmentUncheckedCreateNestedManyWithoutUsersInput
    jobmatch?: jobmatchUncheckedCreateNestedManyWithoutUsersInput
    lessonprogress?: lessonprogressUncheckedCreateNestedManyWithoutUsersInput
    notification?: notificationUncheckedCreateNestedManyWithoutUsersInput
    payment?: paymentUncheckedCreateNestedManyWithoutUsersInput
    quizsubmission?: quizsubmissionUncheckedCreateNestedManyWithoutUsersInput
    userroadmap?: userroadmapUncheckedCreateNestedManyWithoutUsersInput
    voucher?: VoucherUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutCourseInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCourseInput, UserUncheckedCreateWithoutCourseInput>
  }

  export type courseprogressCreateWithoutCourseInput = {
    completedVideoCount: number
    completedQuizCount: number
    isCompleted: boolean
    users: UserCreateNestedOneWithoutCourseprogressInput
  }

  export type courseprogressUncheckedCreateWithoutCourseInput = {
    id?: number
    userId: number
    completedVideoCount: number
    completedQuizCount: number
    isCompleted: boolean
  }

  export type courseprogressCreateOrConnectWithoutCourseInput = {
    where: courseprogressWhereUniqueInput
    create: XOR<courseprogressCreateWithoutCourseInput, courseprogressUncheckedCreateWithoutCourseInput>
  }

  export type courseprogressCreateManyCourseInputEnvelope = {
    data: courseprogressCreateManyCourseInput | courseprogressCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type coursevideoCreateWithoutCourseInput = {
    title: string
    videoUrl: string
    isLocked: boolean
    order: number
    s3Key?: string | null
  }

  export type coursevideoUncheckedCreateWithoutCourseInput = {
    id?: number
    title: string
    videoUrl: string
    isLocked: boolean
    order: number
    s3Key?: string | null
  }

  export type coursevideoCreateOrConnectWithoutCourseInput = {
    where: coursevideoWhereUniqueInput
    create: XOR<coursevideoCreateWithoutCourseInput, coursevideoUncheckedCreateWithoutCourseInput>
  }

  export type coursevideoCreateManyCourseInputEnvelope = {
    data: coursevideoCreateManyCourseInput | coursevideoCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type enrollmentCreateWithoutCourseInput = {
    enrolledAt?: Date | string
    isPaid: boolean
    payment?: paymentCreateNestedOneWithoutEnrollmentInput
    users: UserCreateNestedOneWithoutEnrollmentInput
  }

  export type enrollmentUncheckedCreateWithoutCourseInput = {
    id?: number
    userId: number
    enrolledAt?: Date | string
    isPaid: boolean
    paymentId?: number | null
  }

  export type enrollmentCreateOrConnectWithoutCourseInput = {
    where: enrollmentWhereUniqueInput
    create: XOR<enrollmentCreateWithoutCourseInput, enrollmentUncheckedCreateWithoutCourseInput>
  }

  export type enrollmentCreateManyCourseInputEnvelope = {
    data: enrollmentCreateManyCourseInput | enrollmentCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type lessonCreateWithoutCourseInput = {
    title: string
    content: string
    order: number
    lessonprogress?: lessonprogressCreateNestedManyWithoutLessonInput
  }

  export type lessonUncheckedCreateWithoutCourseInput = {
    id?: number
    title: string
    content: string
    order: number
    lessonprogress?: lessonprogressUncheckedCreateNestedManyWithoutLessonInput
  }

  export type lessonCreateOrConnectWithoutCourseInput = {
    where: lessonWhereUniqueInput
    create: XOR<lessonCreateWithoutCourseInput, lessonUncheckedCreateWithoutCourseInput>
  }

  export type lessonCreateManyCourseInputEnvelope = {
    data: lessonCreateManyCourseInput | lessonCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type paymentCreateWithoutCourseInput = {
    amount: number
    paymentStatus: string
    status: string
    paidAt: Date | string
    createdAt?: Date | string
    orderId?: string | null
    snapToken?: string | null
    enrollment?: enrollmentCreateNestedManyWithoutPaymentInput
    roadmap?: roadmapCreateNestedOneWithoutPaymentInput
    users: UserCreateNestedOneWithoutPaymentInput
  }

  export type paymentUncheckedCreateWithoutCourseInput = {
    id?: number
    userId: number
    roadmapId?: number | null
    amount: number
    paymentStatus: string
    status: string
    paidAt: Date | string
    createdAt?: Date | string
    orderId?: string | null
    snapToken?: string | null
    enrollment?: enrollmentUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type paymentCreateOrConnectWithoutCourseInput = {
    where: paymentWhereUniqueInput
    create: XOR<paymentCreateWithoutCourseInput, paymentUncheckedCreateWithoutCourseInput>
  }

  export type paymentCreateManyCourseInputEnvelope = {
    data: paymentCreateManyCourseInput | paymentCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type quizCreateWithoutCourseInput = {
    question: string
    options: JsonNullValueInput | InputJsonValue
    correctAnswer: string
    isLocked: boolean
    quizsubmission?: quizsubmissionCreateNestedManyWithoutQuizInput
  }

  export type quizUncheckedCreateWithoutCourseInput = {
    id?: number
    question: string
    options: JsonNullValueInput | InputJsonValue
    correctAnswer: string
    isLocked: boolean
    quizsubmission?: quizsubmissionUncheckedCreateNestedManyWithoutQuizInput
  }

  export type quizCreateOrConnectWithoutCourseInput = {
    where: quizWhereUniqueInput
    create: XOR<quizCreateWithoutCourseInput, quizUncheckedCreateWithoutCourseInput>
  }

  export type quizCreateManyCourseInputEnvelope = {
    data: quizCreateManyCourseInput | quizCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type quizsubmissionCreateWithoutCourseInput = {
    answers: JsonNullValueInput | InputJsonValue
    score: number
    totalQuestions: number
    isPassed: boolean
    createdAt?: Date | string
    quiz: quizCreateNestedOneWithoutQuizsubmissionInput
    users: UserCreateNestedOneWithoutQuizsubmissionInput
  }

  export type quizsubmissionUncheckedCreateWithoutCourseInput = {
    id?: number
    userId: number
    quizId: number
    answers: JsonNullValueInput | InputJsonValue
    score: number
    totalQuestions: number
    isPassed: boolean
    createdAt?: Date | string
  }

  export type quizsubmissionCreateOrConnectWithoutCourseInput = {
    where: quizsubmissionWhereUniqueInput
    create: XOR<quizsubmissionCreateWithoutCourseInput, quizsubmissionUncheckedCreateWithoutCourseInput>
  }

  export type quizsubmissionCreateManyCourseInputEnvelope = {
    data: quizsubmissionCreateManyCourseInput | quizsubmissionCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type roadmapcourseCreateWithoutCourseInput = {
    order: number
    roadmap: roadmapCreateNestedOneWithoutRoadmapcourseInput
  }

  export type roadmapcourseUncheckedCreateWithoutCourseInput = {
    id?: number
    roadmapId: number
    order: number
  }

  export type roadmapcourseCreateOrConnectWithoutCourseInput = {
    where: roadmapcourseWhereUniqueInput
    create: XOR<roadmapcourseCreateWithoutCourseInput, roadmapcourseUncheckedCreateWithoutCourseInput>
  }

  export type roadmapcourseCreateManyCourseInputEnvelope = {
    data: roadmapcourseCreateManyCourseInput | roadmapcourseCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type certificateUpsertWithWhereUniqueWithoutCourseInput = {
    where: certificateWhereUniqueInput
    update: XOR<certificateUpdateWithoutCourseInput, certificateUncheckedUpdateWithoutCourseInput>
    create: XOR<certificateCreateWithoutCourseInput, certificateUncheckedCreateWithoutCourseInput>
  }

  export type certificateUpdateWithWhereUniqueWithoutCourseInput = {
    where: certificateWhereUniqueInput
    data: XOR<certificateUpdateWithoutCourseInput, certificateUncheckedUpdateWithoutCourseInput>
  }

  export type certificateUpdateManyWithWhereWithoutCourseInput = {
    where: certificateScalarWhereInput
    data: XOR<certificateUpdateManyMutationInput, certificateUncheckedUpdateManyWithoutCourseInput>
  }

  export type categoryUpsertWithoutCourseInput = {
    update: XOR<categoryUpdateWithoutCourseInput, categoryUncheckedUpdateWithoutCourseInput>
    create: XOR<categoryCreateWithoutCourseInput, categoryUncheckedCreateWithoutCourseInput>
    where?: categoryWhereInput
  }

  export type categoryUpdateToOneWithWhereWithoutCourseInput = {
    where?: categoryWhereInput
    data: XOR<categoryUpdateWithoutCourseInput, categoryUncheckedUpdateWithoutCourseInput>
  }

  export type categoryUpdateWithoutCourseInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type categoryUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type UserUpsertWithoutCourseInput = {
    update: XOR<UserUpdateWithoutCourseInput, UserUncheckedUpdateWithoutCourseInput>
    create: XOR<UserCreateWithoutCourseInput, UserUncheckedCreateWithoutCourseInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCourseInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCourseInput, UserUncheckedUpdateWithoutCourseInput>
  }

  export type UserUpdateWithoutCourseInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assessment?: assessmentUpdateManyWithoutUsersNestedInput
    certificate?: certificateUpdateManyWithoutUsersNestedInput
    chatmessage?: chatmessageUpdateManyWithoutUsersNestedInput
    counselingsession?: counselingsessionUpdateManyWithoutUsersNestedInput
    counselor?: counselorUpdateOneWithoutUsersNestedInput
    courseprogress?: courseprogressUpdateManyWithoutUsersNestedInput
    cvreview?: cvreviewUpdateManyWithoutUsersNestedInput
    enrollment?: enrollmentUpdateManyWithoutUsersNestedInput
    jobmatch?: jobmatchUpdateManyWithoutUsersNestedInput
    lessonprogress?: lessonprogressUpdateManyWithoutUsersNestedInput
    notification?: notificationUpdateManyWithoutUsersNestedInput
    payment?: paymentUpdateManyWithoutUsersNestedInput
    quizsubmission?: quizsubmissionUpdateManyWithoutUsersNestedInput
    userroadmap?: userroadmapUpdateManyWithoutUsersNestedInput
    voucher?: VoucherUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assessment?: assessmentUncheckedUpdateManyWithoutUsersNestedInput
    certificate?: certificateUncheckedUpdateManyWithoutUsersNestedInput
    chatmessage?: chatmessageUncheckedUpdateManyWithoutUsersNestedInput
    counselingsession?: counselingsessionUncheckedUpdateManyWithoutUsersNestedInput
    counselor?: counselorUncheckedUpdateOneWithoutUsersNestedInput
    courseprogress?: courseprogressUncheckedUpdateManyWithoutUsersNestedInput
    cvreview?: cvreviewUncheckedUpdateManyWithoutUsersNestedInput
    enrollment?: enrollmentUncheckedUpdateManyWithoutUsersNestedInput
    jobmatch?: jobmatchUncheckedUpdateManyWithoutUsersNestedInput
    lessonprogress?: lessonprogressUncheckedUpdateManyWithoutUsersNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUsersNestedInput
    payment?: paymentUncheckedUpdateManyWithoutUsersNestedInput
    quizsubmission?: quizsubmissionUncheckedUpdateManyWithoutUsersNestedInput
    userroadmap?: userroadmapUncheckedUpdateManyWithoutUsersNestedInput
    voucher?: VoucherUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type courseprogressUpsertWithWhereUniqueWithoutCourseInput = {
    where: courseprogressWhereUniqueInput
    update: XOR<courseprogressUpdateWithoutCourseInput, courseprogressUncheckedUpdateWithoutCourseInput>
    create: XOR<courseprogressCreateWithoutCourseInput, courseprogressUncheckedCreateWithoutCourseInput>
  }

  export type courseprogressUpdateWithWhereUniqueWithoutCourseInput = {
    where: courseprogressWhereUniqueInput
    data: XOR<courseprogressUpdateWithoutCourseInput, courseprogressUncheckedUpdateWithoutCourseInput>
  }

  export type courseprogressUpdateManyWithWhereWithoutCourseInput = {
    where: courseprogressScalarWhereInput
    data: XOR<courseprogressUpdateManyMutationInput, courseprogressUncheckedUpdateManyWithoutCourseInput>
  }

  export type coursevideoUpsertWithWhereUniqueWithoutCourseInput = {
    where: coursevideoWhereUniqueInput
    update: XOR<coursevideoUpdateWithoutCourseInput, coursevideoUncheckedUpdateWithoutCourseInput>
    create: XOR<coursevideoCreateWithoutCourseInput, coursevideoUncheckedCreateWithoutCourseInput>
  }

  export type coursevideoUpdateWithWhereUniqueWithoutCourseInput = {
    where: coursevideoWhereUniqueInput
    data: XOR<coursevideoUpdateWithoutCourseInput, coursevideoUncheckedUpdateWithoutCourseInput>
  }

  export type coursevideoUpdateManyWithWhereWithoutCourseInput = {
    where: coursevideoScalarWhereInput
    data: XOR<coursevideoUpdateManyMutationInput, coursevideoUncheckedUpdateManyWithoutCourseInput>
  }

  export type coursevideoScalarWhereInput = {
    AND?: coursevideoScalarWhereInput | coursevideoScalarWhereInput[]
    OR?: coursevideoScalarWhereInput[]
    NOT?: coursevideoScalarWhereInput | coursevideoScalarWhereInput[]
    id?: IntFilter<"coursevideo"> | number
    courseId?: IntFilter<"coursevideo"> | number
    title?: StringFilter<"coursevideo"> | string
    videoUrl?: StringFilter<"coursevideo"> | string
    isLocked?: BoolFilter<"coursevideo"> | boolean
    order?: IntFilter<"coursevideo"> | number
    s3Key?: StringNullableFilter<"coursevideo"> | string | null
  }

  export type enrollmentUpsertWithWhereUniqueWithoutCourseInput = {
    where: enrollmentWhereUniqueInput
    update: XOR<enrollmentUpdateWithoutCourseInput, enrollmentUncheckedUpdateWithoutCourseInput>
    create: XOR<enrollmentCreateWithoutCourseInput, enrollmentUncheckedCreateWithoutCourseInput>
  }

  export type enrollmentUpdateWithWhereUniqueWithoutCourseInput = {
    where: enrollmentWhereUniqueInput
    data: XOR<enrollmentUpdateWithoutCourseInput, enrollmentUncheckedUpdateWithoutCourseInput>
  }

  export type enrollmentUpdateManyWithWhereWithoutCourseInput = {
    where: enrollmentScalarWhereInput
    data: XOR<enrollmentUpdateManyMutationInput, enrollmentUncheckedUpdateManyWithoutCourseInput>
  }

  export type lessonUpsertWithWhereUniqueWithoutCourseInput = {
    where: lessonWhereUniqueInput
    update: XOR<lessonUpdateWithoutCourseInput, lessonUncheckedUpdateWithoutCourseInput>
    create: XOR<lessonCreateWithoutCourseInput, lessonUncheckedCreateWithoutCourseInput>
  }

  export type lessonUpdateWithWhereUniqueWithoutCourseInput = {
    where: lessonWhereUniqueInput
    data: XOR<lessonUpdateWithoutCourseInput, lessonUncheckedUpdateWithoutCourseInput>
  }

  export type lessonUpdateManyWithWhereWithoutCourseInput = {
    where: lessonScalarWhereInput
    data: XOR<lessonUpdateManyMutationInput, lessonUncheckedUpdateManyWithoutCourseInput>
  }

  export type lessonScalarWhereInput = {
    AND?: lessonScalarWhereInput | lessonScalarWhereInput[]
    OR?: lessonScalarWhereInput[]
    NOT?: lessonScalarWhereInput | lessonScalarWhereInput[]
    id?: IntFilter<"lesson"> | number
    title?: StringFilter<"lesson"> | string
    courseId?: IntFilter<"lesson"> | number
    content?: StringFilter<"lesson"> | string
    order?: IntFilter<"lesson"> | number
  }

  export type paymentUpsertWithWhereUniqueWithoutCourseInput = {
    where: paymentWhereUniqueInput
    update: XOR<paymentUpdateWithoutCourseInput, paymentUncheckedUpdateWithoutCourseInput>
    create: XOR<paymentCreateWithoutCourseInput, paymentUncheckedCreateWithoutCourseInput>
  }

  export type paymentUpdateWithWhereUniqueWithoutCourseInput = {
    where: paymentWhereUniqueInput
    data: XOR<paymentUpdateWithoutCourseInput, paymentUncheckedUpdateWithoutCourseInput>
  }

  export type paymentUpdateManyWithWhereWithoutCourseInput = {
    where: paymentScalarWhereInput
    data: XOR<paymentUpdateManyMutationInput, paymentUncheckedUpdateManyWithoutCourseInput>
  }

  export type quizUpsertWithWhereUniqueWithoutCourseInput = {
    where: quizWhereUniqueInput
    update: XOR<quizUpdateWithoutCourseInput, quizUncheckedUpdateWithoutCourseInput>
    create: XOR<quizCreateWithoutCourseInput, quizUncheckedCreateWithoutCourseInput>
  }

  export type quizUpdateWithWhereUniqueWithoutCourseInput = {
    where: quizWhereUniqueInput
    data: XOR<quizUpdateWithoutCourseInput, quizUncheckedUpdateWithoutCourseInput>
  }

  export type quizUpdateManyWithWhereWithoutCourseInput = {
    where: quizScalarWhereInput
    data: XOR<quizUpdateManyMutationInput, quizUncheckedUpdateManyWithoutCourseInput>
  }

  export type quizScalarWhereInput = {
    AND?: quizScalarWhereInput | quizScalarWhereInput[]
    OR?: quizScalarWhereInput[]
    NOT?: quizScalarWhereInput | quizScalarWhereInput[]
    id?: IntFilter<"quiz"> | number
    courseId?: IntFilter<"quiz"> | number
    question?: StringFilter<"quiz"> | string
    options?: JsonFilter<"quiz">
    correctAnswer?: StringFilter<"quiz"> | string
    isLocked?: BoolFilter<"quiz"> | boolean
  }

  export type quizsubmissionUpsertWithWhereUniqueWithoutCourseInput = {
    where: quizsubmissionWhereUniqueInput
    update: XOR<quizsubmissionUpdateWithoutCourseInput, quizsubmissionUncheckedUpdateWithoutCourseInput>
    create: XOR<quizsubmissionCreateWithoutCourseInput, quizsubmissionUncheckedCreateWithoutCourseInput>
  }

  export type quizsubmissionUpdateWithWhereUniqueWithoutCourseInput = {
    where: quizsubmissionWhereUniqueInput
    data: XOR<quizsubmissionUpdateWithoutCourseInput, quizsubmissionUncheckedUpdateWithoutCourseInput>
  }

  export type quizsubmissionUpdateManyWithWhereWithoutCourseInput = {
    where: quizsubmissionScalarWhereInput
    data: XOR<quizsubmissionUpdateManyMutationInput, quizsubmissionUncheckedUpdateManyWithoutCourseInput>
  }

  export type roadmapcourseUpsertWithWhereUniqueWithoutCourseInput = {
    where: roadmapcourseWhereUniqueInput
    update: XOR<roadmapcourseUpdateWithoutCourseInput, roadmapcourseUncheckedUpdateWithoutCourseInput>
    create: XOR<roadmapcourseCreateWithoutCourseInput, roadmapcourseUncheckedCreateWithoutCourseInput>
  }

  export type roadmapcourseUpdateWithWhereUniqueWithoutCourseInput = {
    where: roadmapcourseWhereUniqueInput
    data: XOR<roadmapcourseUpdateWithoutCourseInput, roadmapcourseUncheckedUpdateWithoutCourseInput>
  }

  export type roadmapcourseUpdateManyWithWhereWithoutCourseInput = {
    where: roadmapcourseScalarWhereInput
    data: XOR<roadmapcourseUpdateManyMutationInput, roadmapcourseUncheckedUpdateManyWithoutCourseInput>
  }

  export type roadmapcourseScalarWhereInput = {
    AND?: roadmapcourseScalarWhereInput | roadmapcourseScalarWhereInput[]
    OR?: roadmapcourseScalarWhereInput[]
    NOT?: roadmapcourseScalarWhereInput | roadmapcourseScalarWhereInput[]
    id?: IntFilter<"roadmapcourse"> | number
    roadmapId?: IntFilter<"roadmapcourse"> | number
    courseId?: IntFilter<"roadmapcourse"> | number
    order?: IntFilter<"roadmapcourse"> | number
  }

  export type courseCreateWithoutCourseprogressInput = {
    title: string
    description: string
    thumbnail: string
    isPaid: boolean
    price: number
    createdAt?: Date | string
    certificate?: certificateCreateNestedManyWithoutCourseInput
    category: categoryCreateNestedOneWithoutCourseInput
    users: UserCreateNestedOneWithoutCourseInput
    coursevideo?: coursevideoCreateNestedManyWithoutCourseInput
    enrollment?: enrollmentCreateNestedManyWithoutCourseInput
    lesson?: lessonCreateNestedManyWithoutCourseInput
    payment?: paymentCreateNestedManyWithoutCourseInput
    quiz?: quizCreateNestedManyWithoutCourseInput
    quizsubmission?: quizsubmissionCreateNestedManyWithoutCourseInput
    roadmapcourse?: roadmapcourseCreateNestedManyWithoutCourseInput
  }

  export type courseUncheckedCreateWithoutCourseprogressInput = {
    id?: number
    title: string
    description: string
    thumbnail: string
    categoryId: number
    isPaid: boolean
    price: number
    createdById: number
    createdAt?: Date | string
    certificate?: certificateUncheckedCreateNestedManyWithoutCourseInput
    coursevideo?: coursevideoUncheckedCreateNestedManyWithoutCourseInput
    enrollment?: enrollmentUncheckedCreateNestedManyWithoutCourseInput
    lesson?: lessonUncheckedCreateNestedManyWithoutCourseInput
    payment?: paymentUncheckedCreateNestedManyWithoutCourseInput
    quiz?: quizUncheckedCreateNestedManyWithoutCourseInput
    quizsubmission?: quizsubmissionUncheckedCreateNestedManyWithoutCourseInput
    roadmapcourse?: roadmapcourseUncheckedCreateNestedManyWithoutCourseInput
  }

  export type courseCreateOrConnectWithoutCourseprogressInput = {
    where: courseWhereUniqueInput
    create: XOR<courseCreateWithoutCourseprogressInput, courseUncheckedCreateWithoutCourseprogressInput>
  }

  export type UserCreateWithoutCourseprogressInput = {
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    address?: string | null
    gender?: string | null
    birthDate?: Date | string | null
    role?: $Enums.Role
    profilePicture?: string | null
    createdAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    assessment?: assessmentCreateNestedManyWithoutUsersInput
    certificate?: certificateCreateNestedManyWithoutUsersInput
    chatmessage?: chatmessageCreateNestedManyWithoutUsersInput
    counselingsession?: counselingsessionCreateNestedManyWithoutUsersInput
    counselor?: counselorCreateNestedOneWithoutUsersInput
    course?: courseCreateNestedManyWithoutUsersInput
    cvreview?: cvreviewCreateNestedManyWithoutUsersInput
    enrollment?: enrollmentCreateNestedManyWithoutUsersInput
    jobmatch?: jobmatchCreateNestedManyWithoutUsersInput
    lessonprogress?: lessonprogressCreateNestedManyWithoutUsersInput
    notification?: notificationCreateNestedManyWithoutUsersInput
    payment?: paymentCreateNestedManyWithoutUsersInput
    quizsubmission?: quizsubmissionCreateNestedManyWithoutUsersInput
    userroadmap?: userroadmapCreateNestedManyWithoutUsersInput
    voucher?: VoucherCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutCourseprogressInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    address?: string | null
    gender?: string | null
    birthDate?: Date | string | null
    role?: $Enums.Role
    profilePicture?: string | null
    createdAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    assessment?: assessmentUncheckedCreateNestedManyWithoutUsersInput
    certificate?: certificateUncheckedCreateNestedManyWithoutUsersInput
    chatmessage?: chatmessageUncheckedCreateNestedManyWithoutUsersInput
    counselingsession?: counselingsessionUncheckedCreateNestedManyWithoutUsersInput
    counselor?: counselorUncheckedCreateNestedOneWithoutUsersInput
    course?: courseUncheckedCreateNestedManyWithoutUsersInput
    cvreview?: cvreviewUncheckedCreateNestedManyWithoutUsersInput
    enrollment?: enrollmentUncheckedCreateNestedManyWithoutUsersInput
    jobmatch?: jobmatchUncheckedCreateNestedManyWithoutUsersInput
    lessonprogress?: lessonprogressUncheckedCreateNestedManyWithoutUsersInput
    notification?: notificationUncheckedCreateNestedManyWithoutUsersInput
    payment?: paymentUncheckedCreateNestedManyWithoutUsersInput
    quizsubmission?: quizsubmissionUncheckedCreateNestedManyWithoutUsersInput
    userroadmap?: userroadmapUncheckedCreateNestedManyWithoutUsersInput
    voucher?: VoucherUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutCourseprogressInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCourseprogressInput, UserUncheckedCreateWithoutCourseprogressInput>
  }

  export type courseUpsertWithoutCourseprogressInput = {
    update: XOR<courseUpdateWithoutCourseprogressInput, courseUncheckedUpdateWithoutCourseprogressInput>
    create: XOR<courseCreateWithoutCourseprogressInput, courseUncheckedCreateWithoutCourseprogressInput>
    where?: courseWhereInput
  }

  export type courseUpdateToOneWithWhereWithoutCourseprogressInput = {
    where?: courseWhereInput
    data: XOR<courseUpdateWithoutCourseprogressInput, courseUncheckedUpdateWithoutCourseprogressInput>
  }

  export type courseUpdateWithoutCourseprogressInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificate?: certificateUpdateManyWithoutCourseNestedInput
    category?: categoryUpdateOneRequiredWithoutCourseNestedInput
    users?: UserUpdateOneRequiredWithoutCourseNestedInput
    coursevideo?: coursevideoUpdateManyWithoutCourseNestedInput
    enrollment?: enrollmentUpdateManyWithoutCourseNestedInput
    lesson?: lessonUpdateManyWithoutCourseNestedInput
    payment?: paymentUpdateManyWithoutCourseNestedInput
    quiz?: quizUpdateManyWithoutCourseNestedInput
    quizsubmission?: quizsubmissionUpdateManyWithoutCourseNestedInput
    roadmapcourse?: roadmapcourseUpdateManyWithoutCourseNestedInput
  }

  export type courseUncheckedUpdateWithoutCourseprogressInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificate?: certificateUncheckedUpdateManyWithoutCourseNestedInput
    coursevideo?: coursevideoUncheckedUpdateManyWithoutCourseNestedInput
    enrollment?: enrollmentUncheckedUpdateManyWithoutCourseNestedInput
    lesson?: lessonUncheckedUpdateManyWithoutCourseNestedInput
    payment?: paymentUncheckedUpdateManyWithoutCourseNestedInput
    quiz?: quizUncheckedUpdateManyWithoutCourseNestedInput
    quizsubmission?: quizsubmissionUncheckedUpdateManyWithoutCourseNestedInput
    roadmapcourse?: roadmapcourseUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type UserUpsertWithoutCourseprogressInput = {
    update: XOR<UserUpdateWithoutCourseprogressInput, UserUncheckedUpdateWithoutCourseprogressInput>
    create: XOR<UserCreateWithoutCourseprogressInput, UserUncheckedCreateWithoutCourseprogressInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCourseprogressInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCourseprogressInput, UserUncheckedUpdateWithoutCourseprogressInput>
  }

  export type UserUpdateWithoutCourseprogressInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assessment?: assessmentUpdateManyWithoutUsersNestedInput
    certificate?: certificateUpdateManyWithoutUsersNestedInput
    chatmessage?: chatmessageUpdateManyWithoutUsersNestedInput
    counselingsession?: counselingsessionUpdateManyWithoutUsersNestedInput
    counselor?: counselorUpdateOneWithoutUsersNestedInput
    course?: courseUpdateManyWithoutUsersNestedInput
    cvreview?: cvreviewUpdateManyWithoutUsersNestedInput
    enrollment?: enrollmentUpdateManyWithoutUsersNestedInput
    jobmatch?: jobmatchUpdateManyWithoutUsersNestedInput
    lessonprogress?: lessonprogressUpdateManyWithoutUsersNestedInput
    notification?: notificationUpdateManyWithoutUsersNestedInput
    payment?: paymentUpdateManyWithoutUsersNestedInput
    quizsubmission?: quizsubmissionUpdateManyWithoutUsersNestedInput
    userroadmap?: userroadmapUpdateManyWithoutUsersNestedInput
    voucher?: VoucherUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutCourseprogressInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assessment?: assessmentUncheckedUpdateManyWithoutUsersNestedInput
    certificate?: certificateUncheckedUpdateManyWithoutUsersNestedInput
    chatmessage?: chatmessageUncheckedUpdateManyWithoutUsersNestedInput
    counselingsession?: counselingsessionUncheckedUpdateManyWithoutUsersNestedInput
    counselor?: counselorUncheckedUpdateOneWithoutUsersNestedInput
    course?: courseUncheckedUpdateManyWithoutUsersNestedInput
    cvreview?: cvreviewUncheckedUpdateManyWithoutUsersNestedInput
    enrollment?: enrollmentUncheckedUpdateManyWithoutUsersNestedInput
    jobmatch?: jobmatchUncheckedUpdateManyWithoutUsersNestedInput
    lessonprogress?: lessonprogressUncheckedUpdateManyWithoutUsersNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUsersNestedInput
    payment?: paymentUncheckedUpdateManyWithoutUsersNestedInput
    quizsubmission?: quizsubmissionUncheckedUpdateManyWithoutUsersNestedInput
    userroadmap?: userroadmapUncheckedUpdateManyWithoutUsersNestedInput
    voucher?: VoucherUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type courseCreateWithoutCoursevideoInput = {
    title: string
    description: string
    thumbnail: string
    isPaid: boolean
    price: number
    createdAt?: Date | string
    certificate?: certificateCreateNestedManyWithoutCourseInput
    category: categoryCreateNestedOneWithoutCourseInput
    users: UserCreateNestedOneWithoutCourseInput
    courseprogress?: courseprogressCreateNestedManyWithoutCourseInput
    enrollment?: enrollmentCreateNestedManyWithoutCourseInput
    lesson?: lessonCreateNestedManyWithoutCourseInput
    payment?: paymentCreateNestedManyWithoutCourseInput
    quiz?: quizCreateNestedManyWithoutCourseInput
    quizsubmission?: quizsubmissionCreateNestedManyWithoutCourseInput
    roadmapcourse?: roadmapcourseCreateNestedManyWithoutCourseInput
  }

  export type courseUncheckedCreateWithoutCoursevideoInput = {
    id?: number
    title: string
    description: string
    thumbnail: string
    categoryId: number
    isPaid: boolean
    price: number
    createdById: number
    createdAt?: Date | string
    certificate?: certificateUncheckedCreateNestedManyWithoutCourseInput
    courseprogress?: courseprogressUncheckedCreateNestedManyWithoutCourseInput
    enrollment?: enrollmentUncheckedCreateNestedManyWithoutCourseInput
    lesson?: lessonUncheckedCreateNestedManyWithoutCourseInput
    payment?: paymentUncheckedCreateNestedManyWithoutCourseInput
    quiz?: quizUncheckedCreateNestedManyWithoutCourseInput
    quizsubmission?: quizsubmissionUncheckedCreateNestedManyWithoutCourseInput
    roadmapcourse?: roadmapcourseUncheckedCreateNestedManyWithoutCourseInput
  }

  export type courseCreateOrConnectWithoutCoursevideoInput = {
    where: courseWhereUniqueInput
    create: XOR<courseCreateWithoutCoursevideoInput, courseUncheckedCreateWithoutCoursevideoInput>
  }

  export type courseUpsertWithoutCoursevideoInput = {
    update: XOR<courseUpdateWithoutCoursevideoInput, courseUncheckedUpdateWithoutCoursevideoInput>
    create: XOR<courseCreateWithoutCoursevideoInput, courseUncheckedCreateWithoutCoursevideoInput>
    where?: courseWhereInput
  }

  export type courseUpdateToOneWithWhereWithoutCoursevideoInput = {
    where?: courseWhereInput
    data: XOR<courseUpdateWithoutCoursevideoInput, courseUncheckedUpdateWithoutCoursevideoInput>
  }

  export type courseUpdateWithoutCoursevideoInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificate?: certificateUpdateManyWithoutCourseNestedInput
    category?: categoryUpdateOneRequiredWithoutCourseNestedInput
    users?: UserUpdateOneRequiredWithoutCourseNestedInput
    courseprogress?: courseprogressUpdateManyWithoutCourseNestedInput
    enrollment?: enrollmentUpdateManyWithoutCourseNestedInput
    lesson?: lessonUpdateManyWithoutCourseNestedInput
    payment?: paymentUpdateManyWithoutCourseNestedInput
    quiz?: quizUpdateManyWithoutCourseNestedInput
    quizsubmission?: quizsubmissionUpdateManyWithoutCourseNestedInput
    roadmapcourse?: roadmapcourseUpdateManyWithoutCourseNestedInput
  }

  export type courseUncheckedUpdateWithoutCoursevideoInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificate?: certificateUncheckedUpdateManyWithoutCourseNestedInput
    courseprogress?: courseprogressUncheckedUpdateManyWithoutCourseNestedInput
    enrollment?: enrollmentUncheckedUpdateManyWithoutCourseNestedInput
    lesson?: lessonUncheckedUpdateManyWithoutCourseNestedInput
    payment?: paymentUncheckedUpdateManyWithoutCourseNestedInput
    quiz?: quizUncheckedUpdateManyWithoutCourseNestedInput
    quizsubmission?: quizsubmissionUncheckedUpdateManyWithoutCourseNestedInput
    roadmapcourse?: roadmapcourseUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type UserCreateWithoutCvreviewInput = {
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    address?: string | null
    gender?: string | null
    birthDate?: Date | string | null
    role?: $Enums.Role
    profilePicture?: string | null
    createdAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    assessment?: assessmentCreateNestedManyWithoutUsersInput
    certificate?: certificateCreateNestedManyWithoutUsersInput
    chatmessage?: chatmessageCreateNestedManyWithoutUsersInput
    counselingsession?: counselingsessionCreateNestedManyWithoutUsersInput
    counselor?: counselorCreateNestedOneWithoutUsersInput
    course?: courseCreateNestedManyWithoutUsersInput
    courseprogress?: courseprogressCreateNestedManyWithoutUsersInput
    enrollment?: enrollmentCreateNestedManyWithoutUsersInput
    jobmatch?: jobmatchCreateNestedManyWithoutUsersInput
    lessonprogress?: lessonprogressCreateNestedManyWithoutUsersInput
    notification?: notificationCreateNestedManyWithoutUsersInput
    payment?: paymentCreateNestedManyWithoutUsersInput
    quizsubmission?: quizsubmissionCreateNestedManyWithoutUsersInput
    userroadmap?: userroadmapCreateNestedManyWithoutUsersInput
    voucher?: VoucherCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutCvreviewInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    address?: string | null
    gender?: string | null
    birthDate?: Date | string | null
    role?: $Enums.Role
    profilePicture?: string | null
    createdAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    assessment?: assessmentUncheckedCreateNestedManyWithoutUsersInput
    certificate?: certificateUncheckedCreateNestedManyWithoutUsersInput
    chatmessage?: chatmessageUncheckedCreateNestedManyWithoutUsersInput
    counselingsession?: counselingsessionUncheckedCreateNestedManyWithoutUsersInput
    counselor?: counselorUncheckedCreateNestedOneWithoutUsersInput
    course?: courseUncheckedCreateNestedManyWithoutUsersInput
    courseprogress?: courseprogressUncheckedCreateNestedManyWithoutUsersInput
    enrollment?: enrollmentUncheckedCreateNestedManyWithoutUsersInput
    jobmatch?: jobmatchUncheckedCreateNestedManyWithoutUsersInput
    lessonprogress?: lessonprogressUncheckedCreateNestedManyWithoutUsersInput
    notification?: notificationUncheckedCreateNestedManyWithoutUsersInput
    payment?: paymentUncheckedCreateNestedManyWithoutUsersInput
    quizsubmission?: quizsubmissionUncheckedCreateNestedManyWithoutUsersInput
    userroadmap?: userroadmapUncheckedCreateNestedManyWithoutUsersInput
    voucher?: VoucherUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutCvreviewInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCvreviewInput, UserUncheckedCreateWithoutCvreviewInput>
  }

  export type UserUpsertWithoutCvreviewInput = {
    update: XOR<UserUpdateWithoutCvreviewInput, UserUncheckedUpdateWithoutCvreviewInput>
    create: XOR<UserCreateWithoutCvreviewInput, UserUncheckedCreateWithoutCvreviewInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCvreviewInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCvreviewInput, UserUncheckedUpdateWithoutCvreviewInput>
  }

  export type UserUpdateWithoutCvreviewInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assessment?: assessmentUpdateManyWithoutUsersNestedInput
    certificate?: certificateUpdateManyWithoutUsersNestedInput
    chatmessage?: chatmessageUpdateManyWithoutUsersNestedInput
    counselingsession?: counselingsessionUpdateManyWithoutUsersNestedInput
    counselor?: counselorUpdateOneWithoutUsersNestedInput
    course?: courseUpdateManyWithoutUsersNestedInput
    courseprogress?: courseprogressUpdateManyWithoutUsersNestedInput
    enrollment?: enrollmentUpdateManyWithoutUsersNestedInput
    jobmatch?: jobmatchUpdateManyWithoutUsersNestedInput
    lessonprogress?: lessonprogressUpdateManyWithoutUsersNestedInput
    notification?: notificationUpdateManyWithoutUsersNestedInput
    payment?: paymentUpdateManyWithoutUsersNestedInput
    quizsubmission?: quizsubmissionUpdateManyWithoutUsersNestedInput
    userroadmap?: userroadmapUpdateManyWithoutUsersNestedInput
    voucher?: VoucherUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutCvreviewInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assessment?: assessmentUncheckedUpdateManyWithoutUsersNestedInput
    certificate?: certificateUncheckedUpdateManyWithoutUsersNestedInput
    chatmessage?: chatmessageUncheckedUpdateManyWithoutUsersNestedInput
    counselingsession?: counselingsessionUncheckedUpdateManyWithoutUsersNestedInput
    counselor?: counselorUncheckedUpdateOneWithoutUsersNestedInput
    course?: courseUncheckedUpdateManyWithoutUsersNestedInput
    courseprogress?: courseprogressUncheckedUpdateManyWithoutUsersNestedInput
    enrollment?: enrollmentUncheckedUpdateManyWithoutUsersNestedInput
    jobmatch?: jobmatchUncheckedUpdateManyWithoutUsersNestedInput
    lessonprogress?: lessonprogressUncheckedUpdateManyWithoutUsersNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUsersNestedInput
    payment?: paymentUncheckedUpdateManyWithoutUsersNestedInput
    quizsubmission?: quizsubmissionUncheckedUpdateManyWithoutUsersNestedInput
    userroadmap?: userroadmapUncheckedUpdateManyWithoutUsersNestedInput
    voucher?: VoucherUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type courseCreateWithoutEnrollmentInput = {
    title: string
    description: string
    thumbnail: string
    isPaid: boolean
    price: number
    createdAt?: Date | string
    certificate?: certificateCreateNestedManyWithoutCourseInput
    category: categoryCreateNestedOneWithoutCourseInput
    users: UserCreateNestedOneWithoutCourseInput
    courseprogress?: courseprogressCreateNestedManyWithoutCourseInput
    coursevideo?: coursevideoCreateNestedManyWithoutCourseInput
    lesson?: lessonCreateNestedManyWithoutCourseInput
    payment?: paymentCreateNestedManyWithoutCourseInput
    quiz?: quizCreateNestedManyWithoutCourseInput
    quizsubmission?: quizsubmissionCreateNestedManyWithoutCourseInput
    roadmapcourse?: roadmapcourseCreateNestedManyWithoutCourseInput
  }

  export type courseUncheckedCreateWithoutEnrollmentInput = {
    id?: number
    title: string
    description: string
    thumbnail: string
    categoryId: number
    isPaid: boolean
    price: number
    createdById: number
    createdAt?: Date | string
    certificate?: certificateUncheckedCreateNestedManyWithoutCourseInput
    courseprogress?: courseprogressUncheckedCreateNestedManyWithoutCourseInput
    coursevideo?: coursevideoUncheckedCreateNestedManyWithoutCourseInput
    lesson?: lessonUncheckedCreateNestedManyWithoutCourseInput
    payment?: paymentUncheckedCreateNestedManyWithoutCourseInput
    quiz?: quizUncheckedCreateNestedManyWithoutCourseInput
    quizsubmission?: quizsubmissionUncheckedCreateNestedManyWithoutCourseInput
    roadmapcourse?: roadmapcourseUncheckedCreateNestedManyWithoutCourseInput
  }

  export type courseCreateOrConnectWithoutEnrollmentInput = {
    where: courseWhereUniqueInput
    create: XOR<courseCreateWithoutEnrollmentInput, courseUncheckedCreateWithoutEnrollmentInput>
  }

  export type paymentCreateWithoutEnrollmentInput = {
    amount: number
    paymentStatus: string
    status: string
    paidAt: Date | string
    createdAt?: Date | string
    orderId?: string | null
    snapToken?: string | null
    course?: courseCreateNestedOneWithoutPaymentInput
    roadmap?: roadmapCreateNestedOneWithoutPaymentInput
    users: UserCreateNestedOneWithoutPaymentInput
  }

  export type paymentUncheckedCreateWithoutEnrollmentInput = {
    id?: number
    userId: number
    courseId?: number | null
    roadmapId?: number | null
    amount: number
    paymentStatus: string
    status: string
    paidAt: Date | string
    createdAt?: Date | string
    orderId?: string | null
    snapToken?: string | null
  }

  export type paymentCreateOrConnectWithoutEnrollmentInput = {
    where: paymentWhereUniqueInput
    create: XOR<paymentCreateWithoutEnrollmentInput, paymentUncheckedCreateWithoutEnrollmentInput>
  }

  export type UserCreateWithoutEnrollmentInput = {
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    address?: string | null
    gender?: string | null
    birthDate?: Date | string | null
    role?: $Enums.Role
    profilePicture?: string | null
    createdAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    assessment?: assessmentCreateNestedManyWithoutUsersInput
    certificate?: certificateCreateNestedManyWithoutUsersInput
    chatmessage?: chatmessageCreateNestedManyWithoutUsersInput
    counselingsession?: counselingsessionCreateNestedManyWithoutUsersInput
    counselor?: counselorCreateNestedOneWithoutUsersInput
    course?: courseCreateNestedManyWithoutUsersInput
    courseprogress?: courseprogressCreateNestedManyWithoutUsersInput
    cvreview?: cvreviewCreateNestedManyWithoutUsersInput
    jobmatch?: jobmatchCreateNestedManyWithoutUsersInput
    lessonprogress?: lessonprogressCreateNestedManyWithoutUsersInput
    notification?: notificationCreateNestedManyWithoutUsersInput
    payment?: paymentCreateNestedManyWithoutUsersInput
    quizsubmission?: quizsubmissionCreateNestedManyWithoutUsersInput
    userroadmap?: userroadmapCreateNestedManyWithoutUsersInput
    voucher?: VoucherCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutEnrollmentInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    address?: string | null
    gender?: string | null
    birthDate?: Date | string | null
    role?: $Enums.Role
    profilePicture?: string | null
    createdAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    assessment?: assessmentUncheckedCreateNestedManyWithoutUsersInput
    certificate?: certificateUncheckedCreateNestedManyWithoutUsersInput
    chatmessage?: chatmessageUncheckedCreateNestedManyWithoutUsersInput
    counselingsession?: counselingsessionUncheckedCreateNestedManyWithoutUsersInput
    counselor?: counselorUncheckedCreateNestedOneWithoutUsersInput
    course?: courseUncheckedCreateNestedManyWithoutUsersInput
    courseprogress?: courseprogressUncheckedCreateNestedManyWithoutUsersInput
    cvreview?: cvreviewUncheckedCreateNestedManyWithoutUsersInput
    jobmatch?: jobmatchUncheckedCreateNestedManyWithoutUsersInput
    lessonprogress?: lessonprogressUncheckedCreateNestedManyWithoutUsersInput
    notification?: notificationUncheckedCreateNestedManyWithoutUsersInput
    payment?: paymentUncheckedCreateNestedManyWithoutUsersInput
    quizsubmission?: quizsubmissionUncheckedCreateNestedManyWithoutUsersInput
    userroadmap?: userroadmapUncheckedCreateNestedManyWithoutUsersInput
    voucher?: VoucherUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutEnrollmentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEnrollmentInput, UserUncheckedCreateWithoutEnrollmentInput>
  }

  export type courseUpsertWithoutEnrollmentInput = {
    update: XOR<courseUpdateWithoutEnrollmentInput, courseUncheckedUpdateWithoutEnrollmentInput>
    create: XOR<courseCreateWithoutEnrollmentInput, courseUncheckedCreateWithoutEnrollmentInput>
    where?: courseWhereInput
  }

  export type courseUpdateToOneWithWhereWithoutEnrollmentInput = {
    where?: courseWhereInput
    data: XOR<courseUpdateWithoutEnrollmentInput, courseUncheckedUpdateWithoutEnrollmentInput>
  }

  export type courseUpdateWithoutEnrollmentInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificate?: certificateUpdateManyWithoutCourseNestedInput
    category?: categoryUpdateOneRequiredWithoutCourseNestedInput
    users?: UserUpdateOneRequiredWithoutCourseNestedInput
    courseprogress?: courseprogressUpdateManyWithoutCourseNestedInput
    coursevideo?: coursevideoUpdateManyWithoutCourseNestedInput
    lesson?: lessonUpdateManyWithoutCourseNestedInput
    payment?: paymentUpdateManyWithoutCourseNestedInput
    quiz?: quizUpdateManyWithoutCourseNestedInput
    quizsubmission?: quizsubmissionUpdateManyWithoutCourseNestedInput
    roadmapcourse?: roadmapcourseUpdateManyWithoutCourseNestedInput
  }

  export type courseUncheckedUpdateWithoutEnrollmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificate?: certificateUncheckedUpdateManyWithoutCourseNestedInput
    courseprogress?: courseprogressUncheckedUpdateManyWithoutCourseNestedInput
    coursevideo?: coursevideoUncheckedUpdateManyWithoutCourseNestedInput
    lesson?: lessonUncheckedUpdateManyWithoutCourseNestedInput
    payment?: paymentUncheckedUpdateManyWithoutCourseNestedInput
    quiz?: quizUncheckedUpdateManyWithoutCourseNestedInput
    quizsubmission?: quizsubmissionUncheckedUpdateManyWithoutCourseNestedInput
    roadmapcourse?: roadmapcourseUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type paymentUpsertWithoutEnrollmentInput = {
    update: XOR<paymentUpdateWithoutEnrollmentInput, paymentUncheckedUpdateWithoutEnrollmentInput>
    create: XOR<paymentCreateWithoutEnrollmentInput, paymentUncheckedCreateWithoutEnrollmentInput>
    where?: paymentWhereInput
  }

  export type paymentUpdateToOneWithWhereWithoutEnrollmentInput = {
    where?: paymentWhereInput
    data: XOR<paymentUpdateWithoutEnrollmentInput, paymentUncheckedUpdateWithoutEnrollmentInput>
  }

  export type paymentUpdateWithoutEnrollmentInput = {
    amount?: IntFieldUpdateOperationsInput | number
    paymentStatus?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    snapToken?: NullableStringFieldUpdateOperationsInput | string | null
    course?: courseUpdateOneWithoutPaymentNestedInput
    roadmap?: roadmapUpdateOneWithoutPaymentNestedInput
    users?: UserUpdateOneRequiredWithoutPaymentNestedInput
  }

  export type paymentUncheckedUpdateWithoutEnrollmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    roadmapId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: IntFieldUpdateOperationsInput | number
    paymentStatus?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    snapToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpsertWithoutEnrollmentInput = {
    update: XOR<UserUpdateWithoutEnrollmentInput, UserUncheckedUpdateWithoutEnrollmentInput>
    create: XOR<UserCreateWithoutEnrollmentInput, UserUncheckedCreateWithoutEnrollmentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEnrollmentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEnrollmentInput, UserUncheckedUpdateWithoutEnrollmentInput>
  }

  export type UserUpdateWithoutEnrollmentInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assessment?: assessmentUpdateManyWithoutUsersNestedInput
    certificate?: certificateUpdateManyWithoutUsersNestedInput
    chatmessage?: chatmessageUpdateManyWithoutUsersNestedInput
    counselingsession?: counselingsessionUpdateManyWithoutUsersNestedInput
    counselor?: counselorUpdateOneWithoutUsersNestedInput
    course?: courseUpdateManyWithoutUsersNestedInput
    courseprogress?: courseprogressUpdateManyWithoutUsersNestedInput
    cvreview?: cvreviewUpdateManyWithoutUsersNestedInput
    jobmatch?: jobmatchUpdateManyWithoutUsersNestedInput
    lessonprogress?: lessonprogressUpdateManyWithoutUsersNestedInput
    notification?: notificationUpdateManyWithoutUsersNestedInput
    payment?: paymentUpdateManyWithoutUsersNestedInput
    quizsubmission?: quizsubmissionUpdateManyWithoutUsersNestedInput
    userroadmap?: userroadmapUpdateManyWithoutUsersNestedInput
    voucher?: VoucherUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutEnrollmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assessment?: assessmentUncheckedUpdateManyWithoutUsersNestedInput
    certificate?: certificateUncheckedUpdateManyWithoutUsersNestedInput
    chatmessage?: chatmessageUncheckedUpdateManyWithoutUsersNestedInput
    counselingsession?: counselingsessionUncheckedUpdateManyWithoutUsersNestedInput
    counselor?: counselorUncheckedUpdateOneWithoutUsersNestedInput
    course?: courseUncheckedUpdateManyWithoutUsersNestedInput
    courseprogress?: courseprogressUncheckedUpdateManyWithoutUsersNestedInput
    cvreview?: cvreviewUncheckedUpdateManyWithoutUsersNestedInput
    jobmatch?: jobmatchUncheckedUpdateManyWithoutUsersNestedInput
    lessonprogress?: lessonprogressUncheckedUpdateManyWithoutUsersNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUsersNestedInput
    payment?: paymentUncheckedUpdateManyWithoutUsersNestedInput
    quizsubmission?: quizsubmissionUncheckedUpdateManyWithoutUsersNestedInput
    userroadmap?: userroadmapUncheckedUpdateManyWithoutUsersNestedInput
    voucher?: VoucherUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UserCreateWithoutJobmatchInput = {
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    address?: string | null
    gender?: string | null
    birthDate?: Date | string | null
    role?: $Enums.Role
    profilePicture?: string | null
    createdAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    assessment?: assessmentCreateNestedManyWithoutUsersInput
    certificate?: certificateCreateNestedManyWithoutUsersInput
    chatmessage?: chatmessageCreateNestedManyWithoutUsersInput
    counselingsession?: counselingsessionCreateNestedManyWithoutUsersInput
    counselor?: counselorCreateNestedOneWithoutUsersInput
    course?: courseCreateNestedManyWithoutUsersInput
    courseprogress?: courseprogressCreateNestedManyWithoutUsersInput
    cvreview?: cvreviewCreateNestedManyWithoutUsersInput
    enrollment?: enrollmentCreateNestedManyWithoutUsersInput
    lessonprogress?: lessonprogressCreateNestedManyWithoutUsersInput
    notification?: notificationCreateNestedManyWithoutUsersInput
    payment?: paymentCreateNestedManyWithoutUsersInput
    quizsubmission?: quizsubmissionCreateNestedManyWithoutUsersInput
    userroadmap?: userroadmapCreateNestedManyWithoutUsersInput
    voucher?: VoucherCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutJobmatchInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    address?: string | null
    gender?: string | null
    birthDate?: Date | string | null
    role?: $Enums.Role
    profilePicture?: string | null
    createdAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    assessment?: assessmentUncheckedCreateNestedManyWithoutUsersInput
    certificate?: certificateUncheckedCreateNestedManyWithoutUsersInput
    chatmessage?: chatmessageUncheckedCreateNestedManyWithoutUsersInput
    counselingsession?: counselingsessionUncheckedCreateNestedManyWithoutUsersInput
    counselor?: counselorUncheckedCreateNestedOneWithoutUsersInput
    course?: courseUncheckedCreateNestedManyWithoutUsersInput
    courseprogress?: courseprogressUncheckedCreateNestedManyWithoutUsersInput
    cvreview?: cvreviewUncheckedCreateNestedManyWithoutUsersInput
    enrollment?: enrollmentUncheckedCreateNestedManyWithoutUsersInput
    lessonprogress?: lessonprogressUncheckedCreateNestedManyWithoutUsersInput
    notification?: notificationUncheckedCreateNestedManyWithoutUsersInput
    payment?: paymentUncheckedCreateNestedManyWithoutUsersInput
    quizsubmission?: quizsubmissionUncheckedCreateNestedManyWithoutUsersInput
    userroadmap?: userroadmapUncheckedCreateNestedManyWithoutUsersInput
    voucher?: VoucherUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutJobmatchInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutJobmatchInput, UserUncheckedCreateWithoutJobmatchInput>
  }

  export type UserUpsertWithoutJobmatchInput = {
    update: XOR<UserUpdateWithoutJobmatchInput, UserUncheckedUpdateWithoutJobmatchInput>
    create: XOR<UserCreateWithoutJobmatchInput, UserUncheckedCreateWithoutJobmatchInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutJobmatchInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutJobmatchInput, UserUncheckedUpdateWithoutJobmatchInput>
  }

  export type UserUpdateWithoutJobmatchInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assessment?: assessmentUpdateManyWithoutUsersNestedInput
    certificate?: certificateUpdateManyWithoutUsersNestedInput
    chatmessage?: chatmessageUpdateManyWithoutUsersNestedInput
    counselingsession?: counselingsessionUpdateManyWithoutUsersNestedInput
    counselor?: counselorUpdateOneWithoutUsersNestedInput
    course?: courseUpdateManyWithoutUsersNestedInput
    courseprogress?: courseprogressUpdateManyWithoutUsersNestedInput
    cvreview?: cvreviewUpdateManyWithoutUsersNestedInput
    enrollment?: enrollmentUpdateManyWithoutUsersNestedInput
    lessonprogress?: lessonprogressUpdateManyWithoutUsersNestedInput
    notification?: notificationUpdateManyWithoutUsersNestedInput
    payment?: paymentUpdateManyWithoutUsersNestedInput
    quizsubmission?: quizsubmissionUpdateManyWithoutUsersNestedInput
    userroadmap?: userroadmapUpdateManyWithoutUsersNestedInput
    voucher?: VoucherUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutJobmatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assessment?: assessmentUncheckedUpdateManyWithoutUsersNestedInput
    certificate?: certificateUncheckedUpdateManyWithoutUsersNestedInput
    chatmessage?: chatmessageUncheckedUpdateManyWithoutUsersNestedInput
    counselingsession?: counselingsessionUncheckedUpdateManyWithoutUsersNestedInput
    counselor?: counselorUncheckedUpdateOneWithoutUsersNestedInput
    course?: courseUncheckedUpdateManyWithoutUsersNestedInput
    courseprogress?: courseprogressUncheckedUpdateManyWithoutUsersNestedInput
    cvreview?: cvreviewUncheckedUpdateManyWithoutUsersNestedInput
    enrollment?: enrollmentUncheckedUpdateManyWithoutUsersNestedInput
    lessonprogress?: lessonprogressUncheckedUpdateManyWithoutUsersNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUsersNestedInput
    payment?: paymentUncheckedUpdateManyWithoutUsersNestedInput
    quizsubmission?: quizsubmissionUncheckedUpdateManyWithoutUsersNestedInput
    userroadmap?: userroadmapUncheckedUpdateManyWithoutUsersNestedInput
    voucher?: VoucherUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type courseCreateWithoutLessonInput = {
    title: string
    description: string
    thumbnail: string
    isPaid: boolean
    price: number
    createdAt?: Date | string
    certificate?: certificateCreateNestedManyWithoutCourseInput
    category: categoryCreateNestedOneWithoutCourseInput
    users: UserCreateNestedOneWithoutCourseInput
    courseprogress?: courseprogressCreateNestedManyWithoutCourseInput
    coursevideo?: coursevideoCreateNestedManyWithoutCourseInput
    enrollment?: enrollmentCreateNestedManyWithoutCourseInput
    payment?: paymentCreateNestedManyWithoutCourseInput
    quiz?: quizCreateNestedManyWithoutCourseInput
    quizsubmission?: quizsubmissionCreateNestedManyWithoutCourseInput
    roadmapcourse?: roadmapcourseCreateNestedManyWithoutCourseInput
  }

  export type courseUncheckedCreateWithoutLessonInput = {
    id?: number
    title: string
    description: string
    thumbnail: string
    categoryId: number
    isPaid: boolean
    price: number
    createdById: number
    createdAt?: Date | string
    certificate?: certificateUncheckedCreateNestedManyWithoutCourseInput
    courseprogress?: courseprogressUncheckedCreateNestedManyWithoutCourseInput
    coursevideo?: coursevideoUncheckedCreateNestedManyWithoutCourseInput
    enrollment?: enrollmentUncheckedCreateNestedManyWithoutCourseInput
    payment?: paymentUncheckedCreateNestedManyWithoutCourseInput
    quiz?: quizUncheckedCreateNestedManyWithoutCourseInput
    quizsubmission?: quizsubmissionUncheckedCreateNestedManyWithoutCourseInput
    roadmapcourse?: roadmapcourseUncheckedCreateNestedManyWithoutCourseInput
  }

  export type courseCreateOrConnectWithoutLessonInput = {
    where: courseWhereUniqueInput
    create: XOR<courseCreateWithoutLessonInput, courseUncheckedCreateWithoutLessonInput>
  }

  export type lessonprogressCreateWithoutLessonInput = {
    isCompleted?: boolean
    updatedAt: Date | string
    users: UserCreateNestedOneWithoutLessonprogressInput
  }

  export type lessonprogressUncheckedCreateWithoutLessonInput = {
    id?: number
    userId: number
    isCompleted?: boolean
    updatedAt: Date | string
  }

  export type lessonprogressCreateOrConnectWithoutLessonInput = {
    where: lessonprogressWhereUniqueInput
    create: XOR<lessonprogressCreateWithoutLessonInput, lessonprogressUncheckedCreateWithoutLessonInput>
  }

  export type lessonprogressCreateManyLessonInputEnvelope = {
    data: lessonprogressCreateManyLessonInput | lessonprogressCreateManyLessonInput[]
    skipDuplicates?: boolean
  }

  export type courseUpsertWithoutLessonInput = {
    update: XOR<courseUpdateWithoutLessonInput, courseUncheckedUpdateWithoutLessonInput>
    create: XOR<courseCreateWithoutLessonInput, courseUncheckedCreateWithoutLessonInput>
    where?: courseWhereInput
  }

  export type courseUpdateToOneWithWhereWithoutLessonInput = {
    where?: courseWhereInput
    data: XOR<courseUpdateWithoutLessonInput, courseUncheckedUpdateWithoutLessonInput>
  }

  export type courseUpdateWithoutLessonInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificate?: certificateUpdateManyWithoutCourseNestedInput
    category?: categoryUpdateOneRequiredWithoutCourseNestedInput
    users?: UserUpdateOneRequiredWithoutCourseNestedInput
    courseprogress?: courseprogressUpdateManyWithoutCourseNestedInput
    coursevideo?: coursevideoUpdateManyWithoutCourseNestedInput
    enrollment?: enrollmentUpdateManyWithoutCourseNestedInput
    payment?: paymentUpdateManyWithoutCourseNestedInput
    quiz?: quizUpdateManyWithoutCourseNestedInput
    quizsubmission?: quizsubmissionUpdateManyWithoutCourseNestedInput
    roadmapcourse?: roadmapcourseUpdateManyWithoutCourseNestedInput
  }

  export type courseUncheckedUpdateWithoutLessonInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificate?: certificateUncheckedUpdateManyWithoutCourseNestedInput
    courseprogress?: courseprogressUncheckedUpdateManyWithoutCourseNestedInput
    coursevideo?: coursevideoUncheckedUpdateManyWithoutCourseNestedInput
    enrollment?: enrollmentUncheckedUpdateManyWithoutCourseNestedInput
    payment?: paymentUncheckedUpdateManyWithoutCourseNestedInput
    quiz?: quizUncheckedUpdateManyWithoutCourseNestedInput
    quizsubmission?: quizsubmissionUncheckedUpdateManyWithoutCourseNestedInput
    roadmapcourse?: roadmapcourseUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type lessonprogressUpsertWithWhereUniqueWithoutLessonInput = {
    where: lessonprogressWhereUniqueInput
    update: XOR<lessonprogressUpdateWithoutLessonInput, lessonprogressUncheckedUpdateWithoutLessonInput>
    create: XOR<lessonprogressCreateWithoutLessonInput, lessonprogressUncheckedCreateWithoutLessonInput>
  }

  export type lessonprogressUpdateWithWhereUniqueWithoutLessonInput = {
    where: lessonprogressWhereUniqueInput
    data: XOR<lessonprogressUpdateWithoutLessonInput, lessonprogressUncheckedUpdateWithoutLessonInput>
  }

  export type lessonprogressUpdateManyWithWhereWithoutLessonInput = {
    where: lessonprogressScalarWhereInput
    data: XOR<lessonprogressUpdateManyMutationInput, lessonprogressUncheckedUpdateManyWithoutLessonInput>
  }

  export type lessonCreateWithoutLessonprogressInput = {
    title: string
    content: string
    order: number
    course: courseCreateNestedOneWithoutLessonInput
  }

  export type lessonUncheckedCreateWithoutLessonprogressInput = {
    id?: number
    title: string
    courseId: number
    content: string
    order: number
  }

  export type lessonCreateOrConnectWithoutLessonprogressInput = {
    where: lessonWhereUniqueInput
    create: XOR<lessonCreateWithoutLessonprogressInput, lessonUncheckedCreateWithoutLessonprogressInput>
  }

  export type UserCreateWithoutLessonprogressInput = {
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    address?: string | null
    gender?: string | null
    birthDate?: Date | string | null
    role?: $Enums.Role
    profilePicture?: string | null
    createdAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    assessment?: assessmentCreateNestedManyWithoutUsersInput
    certificate?: certificateCreateNestedManyWithoutUsersInput
    chatmessage?: chatmessageCreateNestedManyWithoutUsersInput
    counselingsession?: counselingsessionCreateNestedManyWithoutUsersInput
    counselor?: counselorCreateNestedOneWithoutUsersInput
    course?: courseCreateNestedManyWithoutUsersInput
    courseprogress?: courseprogressCreateNestedManyWithoutUsersInput
    cvreview?: cvreviewCreateNestedManyWithoutUsersInput
    enrollment?: enrollmentCreateNestedManyWithoutUsersInput
    jobmatch?: jobmatchCreateNestedManyWithoutUsersInput
    notification?: notificationCreateNestedManyWithoutUsersInput
    payment?: paymentCreateNestedManyWithoutUsersInput
    quizsubmission?: quizsubmissionCreateNestedManyWithoutUsersInput
    userroadmap?: userroadmapCreateNestedManyWithoutUsersInput
    voucher?: VoucherCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutLessonprogressInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    address?: string | null
    gender?: string | null
    birthDate?: Date | string | null
    role?: $Enums.Role
    profilePicture?: string | null
    createdAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    assessment?: assessmentUncheckedCreateNestedManyWithoutUsersInput
    certificate?: certificateUncheckedCreateNestedManyWithoutUsersInput
    chatmessage?: chatmessageUncheckedCreateNestedManyWithoutUsersInput
    counselingsession?: counselingsessionUncheckedCreateNestedManyWithoutUsersInput
    counselor?: counselorUncheckedCreateNestedOneWithoutUsersInput
    course?: courseUncheckedCreateNestedManyWithoutUsersInput
    courseprogress?: courseprogressUncheckedCreateNestedManyWithoutUsersInput
    cvreview?: cvreviewUncheckedCreateNestedManyWithoutUsersInput
    enrollment?: enrollmentUncheckedCreateNestedManyWithoutUsersInput
    jobmatch?: jobmatchUncheckedCreateNestedManyWithoutUsersInput
    notification?: notificationUncheckedCreateNestedManyWithoutUsersInput
    payment?: paymentUncheckedCreateNestedManyWithoutUsersInput
    quizsubmission?: quizsubmissionUncheckedCreateNestedManyWithoutUsersInput
    userroadmap?: userroadmapUncheckedCreateNestedManyWithoutUsersInput
    voucher?: VoucherUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutLessonprogressInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLessonprogressInput, UserUncheckedCreateWithoutLessonprogressInput>
  }

  export type lessonUpsertWithoutLessonprogressInput = {
    update: XOR<lessonUpdateWithoutLessonprogressInput, lessonUncheckedUpdateWithoutLessonprogressInput>
    create: XOR<lessonCreateWithoutLessonprogressInput, lessonUncheckedCreateWithoutLessonprogressInput>
    where?: lessonWhereInput
  }

  export type lessonUpdateToOneWithWhereWithoutLessonprogressInput = {
    where?: lessonWhereInput
    data: XOR<lessonUpdateWithoutLessonprogressInput, lessonUncheckedUpdateWithoutLessonprogressInput>
  }

  export type lessonUpdateWithoutLessonprogressInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    course?: courseUpdateOneRequiredWithoutLessonNestedInput
  }

  export type lessonUncheckedUpdateWithoutLessonprogressInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    courseId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type UserUpsertWithoutLessonprogressInput = {
    update: XOR<UserUpdateWithoutLessonprogressInput, UserUncheckedUpdateWithoutLessonprogressInput>
    create: XOR<UserCreateWithoutLessonprogressInput, UserUncheckedCreateWithoutLessonprogressInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLessonprogressInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLessonprogressInput, UserUncheckedUpdateWithoutLessonprogressInput>
  }

  export type UserUpdateWithoutLessonprogressInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assessment?: assessmentUpdateManyWithoutUsersNestedInput
    certificate?: certificateUpdateManyWithoutUsersNestedInput
    chatmessage?: chatmessageUpdateManyWithoutUsersNestedInput
    counselingsession?: counselingsessionUpdateManyWithoutUsersNestedInput
    counselor?: counselorUpdateOneWithoutUsersNestedInput
    course?: courseUpdateManyWithoutUsersNestedInput
    courseprogress?: courseprogressUpdateManyWithoutUsersNestedInput
    cvreview?: cvreviewUpdateManyWithoutUsersNestedInput
    enrollment?: enrollmentUpdateManyWithoutUsersNestedInput
    jobmatch?: jobmatchUpdateManyWithoutUsersNestedInput
    notification?: notificationUpdateManyWithoutUsersNestedInput
    payment?: paymentUpdateManyWithoutUsersNestedInput
    quizsubmission?: quizsubmissionUpdateManyWithoutUsersNestedInput
    userroadmap?: userroadmapUpdateManyWithoutUsersNestedInput
    voucher?: VoucherUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutLessonprogressInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assessment?: assessmentUncheckedUpdateManyWithoutUsersNestedInput
    certificate?: certificateUncheckedUpdateManyWithoutUsersNestedInput
    chatmessage?: chatmessageUncheckedUpdateManyWithoutUsersNestedInput
    counselingsession?: counselingsessionUncheckedUpdateManyWithoutUsersNestedInput
    counselor?: counselorUncheckedUpdateOneWithoutUsersNestedInput
    course?: courseUncheckedUpdateManyWithoutUsersNestedInput
    courseprogress?: courseprogressUncheckedUpdateManyWithoutUsersNestedInput
    cvreview?: cvreviewUncheckedUpdateManyWithoutUsersNestedInput
    enrollment?: enrollmentUncheckedUpdateManyWithoutUsersNestedInput
    jobmatch?: jobmatchUncheckedUpdateManyWithoutUsersNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUsersNestedInput
    payment?: paymentUncheckedUpdateManyWithoutUsersNestedInput
    quizsubmission?: quizsubmissionUncheckedUpdateManyWithoutUsersNestedInput
    userroadmap?: userroadmapUncheckedUpdateManyWithoutUsersNestedInput
    voucher?: VoucherUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UserCreateWithoutNotificationInput = {
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    address?: string | null
    gender?: string | null
    birthDate?: Date | string | null
    role?: $Enums.Role
    profilePicture?: string | null
    createdAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    assessment?: assessmentCreateNestedManyWithoutUsersInput
    certificate?: certificateCreateNestedManyWithoutUsersInput
    chatmessage?: chatmessageCreateNestedManyWithoutUsersInput
    counselingsession?: counselingsessionCreateNestedManyWithoutUsersInput
    counselor?: counselorCreateNestedOneWithoutUsersInput
    course?: courseCreateNestedManyWithoutUsersInput
    courseprogress?: courseprogressCreateNestedManyWithoutUsersInput
    cvreview?: cvreviewCreateNestedManyWithoutUsersInput
    enrollment?: enrollmentCreateNestedManyWithoutUsersInput
    jobmatch?: jobmatchCreateNestedManyWithoutUsersInput
    lessonprogress?: lessonprogressCreateNestedManyWithoutUsersInput
    payment?: paymentCreateNestedManyWithoutUsersInput
    quizsubmission?: quizsubmissionCreateNestedManyWithoutUsersInput
    userroadmap?: userroadmapCreateNestedManyWithoutUsersInput
    voucher?: VoucherCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutNotificationInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    address?: string | null
    gender?: string | null
    birthDate?: Date | string | null
    role?: $Enums.Role
    profilePicture?: string | null
    createdAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    assessment?: assessmentUncheckedCreateNestedManyWithoutUsersInput
    certificate?: certificateUncheckedCreateNestedManyWithoutUsersInput
    chatmessage?: chatmessageUncheckedCreateNestedManyWithoutUsersInput
    counselingsession?: counselingsessionUncheckedCreateNestedManyWithoutUsersInput
    counselor?: counselorUncheckedCreateNestedOneWithoutUsersInput
    course?: courseUncheckedCreateNestedManyWithoutUsersInput
    courseprogress?: courseprogressUncheckedCreateNestedManyWithoutUsersInput
    cvreview?: cvreviewUncheckedCreateNestedManyWithoutUsersInput
    enrollment?: enrollmentUncheckedCreateNestedManyWithoutUsersInput
    jobmatch?: jobmatchUncheckedCreateNestedManyWithoutUsersInput
    lessonprogress?: lessonprogressUncheckedCreateNestedManyWithoutUsersInput
    payment?: paymentUncheckedCreateNestedManyWithoutUsersInput
    quizsubmission?: quizsubmissionUncheckedCreateNestedManyWithoutUsersInput
    userroadmap?: userroadmapUncheckedCreateNestedManyWithoutUsersInput
    voucher?: VoucherUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutNotificationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
  }

  export type UserUpsertWithoutNotificationInput = {
    update: XOR<UserUpdateWithoutNotificationInput, UserUncheckedUpdateWithoutNotificationInput>
    create: XOR<UserCreateWithoutNotificationInput, UserUncheckedCreateWithoutNotificationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationInput, UserUncheckedUpdateWithoutNotificationInput>
  }

  export type UserUpdateWithoutNotificationInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assessment?: assessmentUpdateManyWithoutUsersNestedInput
    certificate?: certificateUpdateManyWithoutUsersNestedInput
    chatmessage?: chatmessageUpdateManyWithoutUsersNestedInput
    counselingsession?: counselingsessionUpdateManyWithoutUsersNestedInput
    counselor?: counselorUpdateOneWithoutUsersNestedInput
    course?: courseUpdateManyWithoutUsersNestedInput
    courseprogress?: courseprogressUpdateManyWithoutUsersNestedInput
    cvreview?: cvreviewUpdateManyWithoutUsersNestedInput
    enrollment?: enrollmentUpdateManyWithoutUsersNestedInput
    jobmatch?: jobmatchUpdateManyWithoutUsersNestedInput
    lessonprogress?: lessonprogressUpdateManyWithoutUsersNestedInput
    payment?: paymentUpdateManyWithoutUsersNestedInput
    quizsubmission?: quizsubmissionUpdateManyWithoutUsersNestedInput
    userroadmap?: userroadmapUpdateManyWithoutUsersNestedInput
    voucher?: VoucherUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assessment?: assessmentUncheckedUpdateManyWithoutUsersNestedInput
    certificate?: certificateUncheckedUpdateManyWithoutUsersNestedInput
    chatmessage?: chatmessageUncheckedUpdateManyWithoutUsersNestedInput
    counselingsession?: counselingsessionUncheckedUpdateManyWithoutUsersNestedInput
    counselor?: counselorUncheckedUpdateOneWithoutUsersNestedInput
    course?: courseUncheckedUpdateManyWithoutUsersNestedInput
    courseprogress?: courseprogressUncheckedUpdateManyWithoutUsersNestedInput
    cvreview?: cvreviewUncheckedUpdateManyWithoutUsersNestedInput
    enrollment?: enrollmentUncheckedUpdateManyWithoutUsersNestedInput
    jobmatch?: jobmatchUncheckedUpdateManyWithoutUsersNestedInput
    lessonprogress?: lessonprogressUncheckedUpdateManyWithoutUsersNestedInput
    payment?: paymentUncheckedUpdateManyWithoutUsersNestedInput
    quizsubmission?: quizsubmissionUncheckedUpdateManyWithoutUsersNestedInput
    userroadmap?: userroadmapUncheckedUpdateManyWithoutUsersNestedInput
    voucher?: VoucherUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type enrollmentCreateWithoutPaymentInput = {
    enrolledAt?: Date | string
    isPaid: boolean
    course: courseCreateNestedOneWithoutEnrollmentInput
    users: UserCreateNestedOneWithoutEnrollmentInput
  }

  export type enrollmentUncheckedCreateWithoutPaymentInput = {
    id?: number
    userId: number
    courseId: number
    enrolledAt?: Date | string
    isPaid: boolean
  }

  export type enrollmentCreateOrConnectWithoutPaymentInput = {
    where: enrollmentWhereUniqueInput
    create: XOR<enrollmentCreateWithoutPaymentInput, enrollmentUncheckedCreateWithoutPaymentInput>
  }

  export type enrollmentCreateManyPaymentInputEnvelope = {
    data: enrollmentCreateManyPaymentInput | enrollmentCreateManyPaymentInput[]
    skipDuplicates?: boolean
  }

  export type courseCreateWithoutPaymentInput = {
    title: string
    description: string
    thumbnail: string
    isPaid: boolean
    price: number
    createdAt?: Date | string
    certificate?: certificateCreateNestedManyWithoutCourseInput
    category: categoryCreateNestedOneWithoutCourseInput
    users: UserCreateNestedOneWithoutCourseInput
    courseprogress?: courseprogressCreateNestedManyWithoutCourseInput
    coursevideo?: coursevideoCreateNestedManyWithoutCourseInput
    enrollment?: enrollmentCreateNestedManyWithoutCourseInput
    lesson?: lessonCreateNestedManyWithoutCourseInput
    quiz?: quizCreateNestedManyWithoutCourseInput
    quizsubmission?: quizsubmissionCreateNestedManyWithoutCourseInput
    roadmapcourse?: roadmapcourseCreateNestedManyWithoutCourseInput
  }

  export type courseUncheckedCreateWithoutPaymentInput = {
    id?: number
    title: string
    description: string
    thumbnail: string
    categoryId: number
    isPaid: boolean
    price: number
    createdById: number
    createdAt?: Date | string
    certificate?: certificateUncheckedCreateNestedManyWithoutCourseInput
    courseprogress?: courseprogressUncheckedCreateNestedManyWithoutCourseInput
    coursevideo?: coursevideoUncheckedCreateNestedManyWithoutCourseInput
    enrollment?: enrollmentUncheckedCreateNestedManyWithoutCourseInput
    lesson?: lessonUncheckedCreateNestedManyWithoutCourseInput
    quiz?: quizUncheckedCreateNestedManyWithoutCourseInput
    quizsubmission?: quizsubmissionUncheckedCreateNestedManyWithoutCourseInput
    roadmapcourse?: roadmapcourseUncheckedCreateNestedManyWithoutCourseInput
  }

  export type courseCreateOrConnectWithoutPaymentInput = {
    where: courseWhereUniqueInput
    create: XOR<courseCreateWithoutPaymentInput, courseUncheckedCreateWithoutPaymentInput>
  }

  export type roadmapCreateWithoutPaymentInput = {
    name: string
    description: string
    rewardVoucher: string
    roadmapcourse?: roadmapcourseCreateNestedManyWithoutRoadmapInput
    userroadmap?: userroadmapCreateNestedManyWithoutRoadmapInput
  }

  export type roadmapUncheckedCreateWithoutPaymentInput = {
    id?: number
    name: string
    description: string
    rewardVoucher: string
    roadmapcourse?: roadmapcourseUncheckedCreateNestedManyWithoutRoadmapInput
    userroadmap?: userroadmapUncheckedCreateNestedManyWithoutRoadmapInput
  }

  export type roadmapCreateOrConnectWithoutPaymentInput = {
    where: roadmapWhereUniqueInput
    create: XOR<roadmapCreateWithoutPaymentInput, roadmapUncheckedCreateWithoutPaymentInput>
  }

  export type UserCreateWithoutPaymentInput = {
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    address?: string | null
    gender?: string | null
    birthDate?: Date | string | null
    role?: $Enums.Role
    profilePicture?: string | null
    createdAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    assessment?: assessmentCreateNestedManyWithoutUsersInput
    certificate?: certificateCreateNestedManyWithoutUsersInput
    chatmessage?: chatmessageCreateNestedManyWithoutUsersInput
    counselingsession?: counselingsessionCreateNestedManyWithoutUsersInput
    counselor?: counselorCreateNestedOneWithoutUsersInput
    course?: courseCreateNestedManyWithoutUsersInput
    courseprogress?: courseprogressCreateNestedManyWithoutUsersInput
    cvreview?: cvreviewCreateNestedManyWithoutUsersInput
    enrollment?: enrollmentCreateNestedManyWithoutUsersInput
    jobmatch?: jobmatchCreateNestedManyWithoutUsersInput
    lessonprogress?: lessonprogressCreateNestedManyWithoutUsersInput
    notification?: notificationCreateNestedManyWithoutUsersInput
    quizsubmission?: quizsubmissionCreateNestedManyWithoutUsersInput
    userroadmap?: userroadmapCreateNestedManyWithoutUsersInput
    voucher?: VoucherCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutPaymentInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    address?: string | null
    gender?: string | null
    birthDate?: Date | string | null
    role?: $Enums.Role
    profilePicture?: string | null
    createdAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    assessment?: assessmentUncheckedCreateNestedManyWithoutUsersInput
    certificate?: certificateUncheckedCreateNestedManyWithoutUsersInput
    chatmessage?: chatmessageUncheckedCreateNestedManyWithoutUsersInput
    counselingsession?: counselingsessionUncheckedCreateNestedManyWithoutUsersInput
    counselor?: counselorUncheckedCreateNestedOneWithoutUsersInput
    course?: courseUncheckedCreateNestedManyWithoutUsersInput
    courseprogress?: courseprogressUncheckedCreateNestedManyWithoutUsersInput
    cvreview?: cvreviewUncheckedCreateNestedManyWithoutUsersInput
    enrollment?: enrollmentUncheckedCreateNestedManyWithoutUsersInput
    jobmatch?: jobmatchUncheckedCreateNestedManyWithoutUsersInput
    lessonprogress?: lessonprogressUncheckedCreateNestedManyWithoutUsersInput
    notification?: notificationUncheckedCreateNestedManyWithoutUsersInput
    quizsubmission?: quizsubmissionUncheckedCreateNestedManyWithoutUsersInput
    userroadmap?: userroadmapUncheckedCreateNestedManyWithoutUsersInput
    voucher?: VoucherUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutPaymentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPaymentInput, UserUncheckedCreateWithoutPaymentInput>
  }

  export type enrollmentUpsertWithWhereUniqueWithoutPaymentInput = {
    where: enrollmentWhereUniqueInput
    update: XOR<enrollmentUpdateWithoutPaymentInput, enrollmentUncheckedUpdateWithoutPaymentInput>
    create: XOR<enrollmentCreateWithoutPaymentInput, enrollmentUncheckedCreateWithoutPaymentInput>
  }

  export type enrollmentUpdateWithWhereUniqueWithoutPaymentInput = {
    where: enrollmentWhereUniqueInput
    data: XOR<enrollmentUpdateWithoutPaymentInput, enrollmentUncheckedUpdateWithoutPaymentInput>
  }

  export type enrollmentUpdateManyWithWhereWithoutPaymentInput = {
    where: enrollmentScalarWhereInput
    data: XOR<enrollmentUpdateManyMutationInput, enrollmentUncheckedUpdateManyWithoutPaymentInput>
  }

  export type courseUpsertWithoutPaymentInput = {
    update: XOR<courseUpdateWithoutPaymentInput, courseUncheckedUpdateWithoutPaymentInput>
    create: XOR<courseCreateWithoutPaymentInput, courseUncheckedCreateWithoutPaymentInput>
    where?: courseWhereInput
  }

  export type courseUpdateToOneWithWhereWithoutPaymentInput = {
    where?: courseWhereInput
    data: XOR<courseUpdateWithoutPaymentInput, courseUncheckedUpdateWithoutPaymentInput>
  }

  export type courseUpdateWithoutPaymentInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificate?: certificateUpdateManyWithoutCourseNestedInput
    category?: categoryUpdateOneRequiredWithoutCourseNestedInput
    users?: UserUpdateOneRequiredWithoutCourseNestedInput
    courseprogress?: courseprogressUpdateManyWithoutCourseNestedInput
    coursevideo?: coursevideoUpdateManyWithoutCourseNestedInput
    enrollment?: enrollmentUpdateManyWithoutCourseNestedInput
    lesson?: lessonUpdateManyWithoutCourseNestedInput
    quiz?: quizUpdateManyWithoutCourseNestedInput
    quizsubmission?: quizsubmissionUpdateManyWithoutCourseNestedInput
    roadmapcourse?: roadmapcourseUpdateManyWithoutCourseNestedInput
  }

  export type courseUncheckedUpdateWithoutPaymentInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificate?: certificateUncheckedUpdateManyWithoutCourseNestedInput
    courseprogress?: courseprogressUncheckedUpdateManyWithoutCourseNestedInput
    coursevideo?: coursevideoUncheckedUpdateManyWithoutCourseNestedInput
    enrollment?: enrollmentUncheckedUpdateManyWithoutCourseNestedInput
    lesson?: lessonUncheckedUpdateManyWithoutCourseNestedInput
    quiz?: quizUncheckedUpdateManyWithoutCourseNestedInput
    quizsubmission?: quizsubmissionUncheckedUpdateManyWithoutCourseNestedInput
    roadmapcourse?: roadmapcourseUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type roadmapUpsertWithoutPaymentInput = {
    update: XOR<roadmapUpdateWithoutPaymentInput, roadmapUncheckedUpdateWithoutPaymentInput>
    create: XOR<roadmapCreateWithoutPaymentInput, roadmapUncheckedCreateWithoutPaymentInput>
    where?: roadmapWhereInput
  }

  export type roadmapUpdateToOneWithWhereWithoutPaymentInput = {
    where?: roadmapWhereInput
    data: XOR<roadmapUpdateWithoutPaymentInput, roadmapUncheckedUpdateWithoutPaymentInput>
  }

  export type roadmapUpdateWithoutPaymentInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rewardVoucher?: StringFieldUpdateOperationsInput | string
    roadmapcourse?: roadmapcourseUpdateManyWithoutRoadmapNestedInput
    userroadmap?: userroadmapUpdateManyWithoutRoadmapNestedInput
  }

  export type roadmapUncheckedUpdateWithoutPaymentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rewardVoucher?: StringFieldUpdateOperationsInput | string
    roadmapcourse?: roadmapcourseUncheckedUpdateManyWithoutRoadmapNestedInput
    userroadmap?: userroadmapUncheckedUpdateManyWithoutRoadmapNestedInput
  }

  export type UserUpsertWithoutPaymentInput = {
    update: XOR<UserUpdateWithoutPaymentInput, UserUncheckedUpdateWithoutPaymentInput>
    create: XOR<UserCreateWithoutPaymentInput, UserUncheckedCreateWithoutPaymentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPaymentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPaymentInput, UserUncheckedUpdateWithoutPaymentInput>
  }

  export type UserUpdateWithoutPaymentInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assessment?: assessmentUpdateManyWithoutUsersNestedInput
    certificate?: certificateUpdateManyWithoutUsersNestedInput
    chatmessage?: chatmessageUpdateManyWithoutUsersNestedInput
    counselingsession?: counselingsessionUpdateManyWithoutUsersNestedInput
    counselor?: counselorUpdateOneWithoutUsersNestedInput
    course?: courseUpdateManyWithoutUsersNestedInput
    courseprogress?: courseprogressUpdateManyWithoutUsersNestedInput
    cvreview?: cvreviewUpdateManyWithoutUsersNestedInput
    enrollment?: enrollmentUpdateManyWithoutUsersNestedInput
    jobmatch?: jobmatchUpdateManyWithoutUsersNestedInput
    lessonprogress?: lessonprogressUpdateManyWithoutUsersNestedInput
    notification?: notificationUpdateManyWithoutUsersNestedInput
    quizsubmission?: quizsubmissionUpdateManyWithoutUsersNestedInput
    userroadmap?: userroadmapUpdateManyWithoutUsersNestedInput
    voucher?: VoucherUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutPaymentInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assessment?: assessmentUncheckedUpdateManyWithoutUsersNestedInput
    certificate?: certificateUncheckedUpdateManyWithoutUsersNestedInput
    chatmessage?: chatmessageUncheckedUpdateManyWithoutUsersNestedInput
    counselingsession?: counselingsessionUncheckedUpdateManyWithoutUsersNestedInput
    counselor?: counselorUncheckedUpdateOneWithoutUsersNestedInput
    course?: courseUncheckedUpdateManyWithoutUsersNestedInput
    courseprogress?: courseprogressUncheckedUpdateManyWithoutUsersNestedInput
    cvreview?: cvreviewUncheckedUpdateManyWithoutUsersNestedInput
    enrollment?: enrollmentUncheckedUpdateManyWithoutUsersNestedInput
    jobmatch?: jobmatchUncheckedUpdateManyWithoutUsersNestedInput
    lessonprogress?: lessonprogressUncheckedUpdateManyWithoutUsersNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUsersNestedInput
    quizsubmission?: quizsubmissionUncheckedUpdateManyWithoutUsersNestedInput
    userroadmap?: userroadmapUncheckedUpdateManyWithoutUsersNestedInput
    voucher?: VoucherUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type courseCreateWithoutQuizInput = {
    title: string
    description: string
    thumbnail: string
    isPaid: boolean
    price: number
    createdAt?: Date | string
    certificate?: certificateCreateNestedManyWithoutCourseInput
    category: categoryCreateNestedOneWithoutCourseInput
    users: UserCreateNestedOneWithoutCourseInput
    courseprogress?: courseprogressCreateNestedManyWithoutCourseInput
    coursevideo?: coursevideoCreateNestedManyWithoutCourseInput
    enrollment?: enrollmentCreateNestedManyWithoutCourseInput
    lesson?: lessonCreateNestedManyWithoutCourseInput
    payment?: paymentCreateNestedManyWithoutCourseInput
    quizsubmission?: quizsubmissionCreateNestedManyWithoutCourseInput
    roadmapcourse?: roadmapcourseCreateNestedManyWithoutCourseInput
  }

  export type courseUncheckedCreateWithoutQuizInput = {
    id?: number
    title: string
    description: string
    thumbnail: string
    categoryId: number
    isPaid: boolean
    price: number
    createdById: number
    createdAt?: Date | string
    certificate?: certificateUncheckedCreateNestedManyWithoutCourseInput
    courseprogress?: courseprogressUncheckedCreateNestedManyWithoutCourseInput
    coursevideo?: coursevideoUncheckedCreateNestedManyWithoutCourseInput
    enrollment?: enrollmentUncheckedCreateNestedManyWithoutCourseInput
    lesson?: lessonUncheckedCreateNestedManyWithoutCourseInput
    payment?: paymentUncheckedCreateNestedManyWithoutCourseInput
    quizsubmission?: quizsubmissionUncheckedCreateNestedManyWithoutCourseInput
    roadmapcourse?: roadmapcourseUncheckedCreateNestedManyWithoutCourseInput
  }

  export type courseCreateOrConnectWithoutQuizInput = {
    where: courseWhereUniqueInput
    create: XOR<courseCreateWithoutQuizInput, courseUncheckedCreateWithoutQuizInput>
  }

  export type quizsubmissionCreateWithoutQuizInput = {
    answers: JsonNullValueInput | InputJsonValue
    score: number
    totalQuestions: number
    isPassed: boolean
    createdAt?: Date | string
    course: courseCreateNestedOneWithoutQuizsubmissionInput
    users: UserCreateNestedOneWithoutQuizsubmissionInput
  }

  export type quizsubmissionUncheckedCreateWithoutQuizInput = {
    id?: number
    userId: number
    courseId: number
    answers: JsonNullValueInput | InputJsonValue
    score: number
    totalQuestions: number
    isPassed: boolean
    createdAt?: Date | string
  }

  export type quizsubmissionCreateOrConnectWithoutQuizInput = {
    where: quizsubmissionWhereUniqueInput
    create: XOR<quizsubmissionCreateWithoutQuizInput, quizsubmissionUncheckedCreateWithoutQuizInput>
  }

  export type quizsubmissionCreateManyQuizInputEnvelope = {
    data: quizsubmissionCreateManyQuizInput | quizsubmissionCreateManyQuizInput[]
    skipDuplicates?: boolean
  }

  export type courseUpsertWithoutQuizInput = {
    update: XOR<courseUpdateWithoutQuizInput, courseUncheckedUpdateWithoutQuizInput>
    create: XOR<courseCreateWithoutQuizInput, courseUncheckedCreateWithoutQuizInput>
    where?: courseWhereInput
  }

  export type courseUpdateToOneWithWhereWithoutQuizInput = {
    where?: courseWhereInput
    data: XOR<courseUpdateWithoutQuizInput, courseUncheckedUpdateWithoutQuizInput>
  }

  export type courseUpdateWithoutQuizInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificate?: certificateUpdateManyWithoutCourseNestedInput
    category?: categoryUpdateOneRequiredWithoutCourseNestedInput
    users?: UserUpdateOneRequiredWithoutCourseNestedInput
    courseprogress?: courseprogressUpdateManyWithoutCourseNestedInput
    coursevideo?: coursevideoUpdateManyWithoutCourseNestedInput
    enrollment?: enrollmentUpdateManyWithoutCourseNestedInput
    lesson?: lessonUpdateManyWithoutCourseNestedInput
    payment?: paymentUpdateManyWithoutCourseNestedInput
    quizsubmission?: quizsubmissionUpdateManyWithoutCourseNestedInput
    roadmapcourse?: roadmapcourseUpdateManyWithoutCourseNestedInput
  }

  export type courseUncheckedUpdateWithoutQuizInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificate?: certificateUncheckedUpdateManyWithoutCourseNestedInput
    courseprogress?: courseprogressUncheckedUpdateManyWithoutCourseNestedInput
    coursevideo?: coursevideoUncheckedUpdateManyWithoutCourseNestedInput
    enrollment?: enrollmentUncheckedUpdateManyWithoutCourseNestedInput
    lesson?: lessonUncheckedUpdateManyWithoutCourseNestedInput
    payment?: paymentUncheckedUpdateManyWithoutCourseNestedInput
    quizsubmission?: quizsubmissionUncheckedUpdateManyWithoutCourseNestedInput
    roadmapcourse?: roadmapcourseUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type quizsubmissionUpsertWithWhereUniqueWithoutQuizInput = {
    where: quizsubmissionWhereUniqueInput
    update: XOR<quizsubmissionUpdateWithoutQuizInput, quizsubmissionUncheckedUpdateWithoutQuizInput>
    create: XOR<quizsubmissionCreateWithoutQuizInput, quizsubmissionUncheckedCreateWithoutQuizInput>
  }

  export type quizsubmissionUpdateWithWhereUniqueWithoutQuizInput = {
    where: quizsubmissionWhereUniqueInput
    data: XOR<quizsubmissionUpdateWithoutQuizInput, quizsubmissionUncheckedUpdateWithoutQuizInput>
  }

  export type quizsubmissionUpdateManyWithWhereWithoutQuizInput = {
    where: quizsubmissionScalarWhereInput
    data: XOR<quizsubmissionUpdateManyMutationInput, quizsubmissionUncheckedUpdateManyWithoutQuizInput>
  }

  export type courseCreateWithoutQuizsubmissionInput = {
    title: string
    description: string
    thumbnail: string
    isPaid: boolean
    price: number
    createdAt?: Date | string
    certificate?: certificateCreateNestedManyWithoutCourseInput
    category: categoryCreateNestedOneWithoutCourseInput
    users: UserCreateNestedOneWithoutCourseInput
    courseprogress?: courseprogressCreateNestedManyWithoutCourseInput
    coursevideo?: coursevideoCreateNestedManyWithoutCourseInput
    enrollment?: enrollmentCreateNestedManyWithoutCourseInput
    lesson?: lessonCreateNestedManyWithoutCourseInput
    payment?: paymentCreateNestedManyWithoutCourseInput
    quiz?: quizCreateNestedManyWithoutCourseInput
    roadmapcourse?: roadmapcourseCreateNestedManyWithoutCourseInput
  }

  export type courseUncheckedCreateWithoutQuizsubmissionInput = {
    id?: number
    title: string
    description: string
    thumbnail: string
    categoryId: number
    isPaid: boolean
    price: number
    createdById: number
    createdAt?: Date | string
    certificate?: certificateUncheckedCreateNestedManyWithoutCourseInput
    courseprogress?: courseprogressUncheckedCreateNestedManyWithoutCourseInput
    coursevideo?: coursevideoUncheckedCreateNestedManyWithoutCourseInput
    enrollment?: enrollmentUncheckedCreateNestedManyWithoutCourseInput
    lesson?: lessonUncheckedCreateNestedManyWithoutCourseInput
    payment?: paymentUncheckedCreateNestedManyWithoutCourseInput
    quiz?: quizUncheckedCreateNestedManyWithoutCourseInput
    roadmapcourse?: roadmapcourseUncheckedCreateNestedManyWithoutCourseInput
  }

  export type courseCreateOrConnectWithoutQuizsubmissionInput = {
    where: courseWhereUniqueInput
    create: XOR<courseCreateWithoutQuizsubmissionInput, courseUncheckedCreateWithoutQuizsubmissionInput>
  }

  export type quizCreateWithoutQuizsubmissionInput = {
    question: string
    options: JsonNullValueInput | InputJsonValue
    correctAnswer: string
    isLocked: boolean
    course: courseCreateNestedOneWithoutQuizInput
  }

  export type quizUncheckedCreateWithoutQuizsubmissionInput = {
    id?: number
    courseId: number
    question: string
    options: JsonNullValueInput | InputJsonValue
    correctAnswer: string
    isLocked: boolean
  }

  export type quizCreateOrConnectWithoutQuizsubmissionInput = {
    where: quizWhereUniqueInput
    create: XOR<quizCreateWithoutQuizsubmissionInput, quizUncheckedCreateWithoutQuizsubmissionInput>
  }

  export type UserCreateWithoutQuizsubmissionInput = {
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    address?: string | null
    gender?: string | null
    birthDate?: Date | string | null
    role?: $Enums.Role
    profilePicture?: string | null
    createdAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    assessment?: assessmentCreateNestedManyWithoutUsersInput
    certificate?: certificateCreateNestedManyWithoutUsersInput
    chatmessage?: chatmessageCreateNestedManyWithoutUsersInput
    counselingsession?: counselingsessionCreateNestedManyWithoutUsersInput
    counselor?: counselorCreateNestedOneWithoutUsersInput
    course?: courseCreateNestedManyWithoutUsersInput
    courseprogress?: courseprogressCreateNestedManyWithoutUsersInput
    cvreview?: cvreviewCreateNestedManyWithoutUsersInput
    enrollment?: enrollmentCreateNestedManyWithoutUsersInput
    jobmatch?: jobmatchCreateNestedManyWithoutUsersInput
    lessonprogress?: lessonprogressCreateNestedManyWithoutUsersInput
    notification?: notificationCreateNestedManyWithoutUsersInput
    payment?: paymentCreateNestedManyWithoutUsersInput
    userroadmap?: userroadmapCreateNestedManyWithoutUsersInput
    voucher?: VoucherCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutQuizsubmissionInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    address?: string | null
    gender?: string | null
    birthDate?: Date | string | null
    role?: $Enums.Role
    profilePicture?: string | null
    createdAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    assessment?: assessmentUncheckedCreateNestedManyWithoutUsersInput
    certificate?: certificateUncheckedCreateNestedManyWithoutUsersInput
    chatmessage?: chatmessageUncheckedCreateNestedManyWithoutUsersInput
    counselingsession?: counselingsessionUncheckedCreateNestedManyWithoutUsersInput
    counselor?: counselorUncheckedCreateNestedOneWithoutUsersInput
    course?: courseUncheckedCreateNestedManyWithoutUsersInput
    courseprogress?: courseprogressUncheckedCreateNestedManyWithoutUsersInput
    cvreview?: cvreviewUncheckedCreateNestedManyWithoutUsersInput
    enrollment?: enrollmentUncheckedCreateNestedManyWithoutUsersInput
    jobmatch?: jobmatchUncheckedCreateNestedManyWithoutUsersInput
    lessonprogress?: lessonprogressUncheckedCreateNestedManyWithoutUsersInput
    notification?: notificationUncheckedCreateNestedManyWithoutUsersInput
    payment?: paymentUncheckedCreateNestedManyWithoutUsersInput
    userroadmap?: userroadmapUncheckedCreateNestedManyWithoutUsersInput
    voucher?: VoucherUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutQuizsubmissionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutQuizsubmissionInput, UserUncheckedCreateWithoutQuizsubmissionInput>
  }

  export type courseUpsertWithoutQuizsubmissionInput = {
    update: XOR<courseUpdateWithoutQuizsubmissionInput, courseUncheckedUpdateWithoutQuizsubmissionInput>
    create: XOR<courseCreateWithoutQuizsubmissionInput, courseUncheckedCreateWithoutQuizsubmissionInput>
    where?: courseWhereInput
  }

  export type courseUpdateToOneWithWhereWithoutQuizsubmissionInput = {
    where?: courseWhereInput
    data: XOR<courseUpdateWithoutQuizsubmissionInput, courseUncheckedUpdateWithoutQuizsubmissionInput>
  }

  export type courseUpdateWithoutQuizsubmissionInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificate?: certificateUpdateManyWithoutCourseNestedInput
    category?: categoryUpdateOneRequiredWithoutCourseNestedInput
    users?: UserUpdateOneRequiredWithoutCourseNestedInput
    courseprogress?: courseprogressUpdateManyWithoutCourseNestedInput
    coursevideo?: coursevideoUpdateManyWithoutCourseNestedInput
    enrollment?: enrollmentUpdateManyWithoutCourseNestedInput
    lesson?: lessonUpdateManyWithoutCourseNestedInput
    payment?: paymentUpdateManyWithoutCourseNestedInput
    quiz?: quizUpdateManyWithoutCourseNestedInput
    roadmapcourse?: roadmapcourseUpdateManyWithoutCourseNestedInput
  }

  export type courseUncheckedUpdateWithoutQuizsubmissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificate?: certificateUncheckedUpdateManyWithoutCourseNestedInput
    courseprogress?: courseprogressUncheckedUpdateManyWithoutCourseNestedInput
    coursevideo?: coursevideoUncheckedUpdateManyWithoutCourseNestedInput
    enrollment?: enrollmentUncheckedUpdateManyWithoutCourseNestedInput
    lesson?: lessonUncheckedUpdateManyWithoutCourseNestedInput
    payment?: paymentUncheckedUpdateManyWithoutCourseNestedInput
    quiz?: quizUncheckedUpdateManyWithoutCourseNestedInput
    roadmapcourse?: roadmapcourseUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type quizUpsertWithoutQuizsubmissionInput = {
    update: XOR<quizUpdateWithoutQuizsubmissionInput, quizUncheckedUpdateWithoutQuizsubmissionInput>
    create: XOR<quizCreateWithoutQuizsubmissionInput, quizUncheckedCreateWithoutQuizsubmissionInput>
    where?: quizWhereInput
  }

  export type quizUpdateToOneWithWhereWithoutQuizsubmissionInput = {
    where?: quizWhereInput
    data: XOR<quizUpdateWithoutQuizsubmissionInput, quizUncheckedUpdateWithoutQuizsubmissionInput>
  }

  export type quizUpdateWithoutQuizsubmissionInput = {
    question?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    correctAnswer?: StringFieldUpdateOperationsInput | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    course?: courseUpdateOneRequiredWithoutQuizNestedInput
  }

  export type quizUncheckedUpdateWithoutQuizsubmissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    correctAnswer?: StringFieldUpdateOperationsInput | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUpsertWithoutQuizsubmissionInput = {
    update: XOR<UserUpdateWithoutQuizsubmissionInput, UserUncheckedUpdateWithoutQuizsubmissionInput>
    create: XOR<UserCreateWithoutQuizsubmissionInput, UserUncheckedCreateWithoutQuizsubmissionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutQuizsubmissionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutQuizsubmissionInput, UserUncheckedUpdateWithoutQuizsubmissionInput>
  }

  export type UserUpdateWithoutQuizsubmissionInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assessment?: assessmentUpdateManyWithoutUsersNestedInput
    certificate?: certificateUpdateManyWithoutUsersNestedInput
    chatmessage?: chatmessageUpdateManyWithoutUsersNestedInput
    counselingsession?: counselingsessionUpdateManyWithoutUsersNestedInput
    counselor?: counselorUpdateOneWithoutUsersNestedInput
    course?: courseUpdateManyWithoutUsersNestedInput
    courseprogress?: courseprogressUpdateManyWithoutUsersNestedInput
    cvreview?: cvreviewUpdateManyWithoutUsersNestedInput
    enrollment?: enrollmentUpdateManyWithoutUsersNestedInput
    jobmatch?: jobmatchUpdateManyWithoutUsersNestedInput
    lessonprogress?: lessonprogressUpdateManyWithoutUsersNestedInput
    notification?: notificationUpdateManyWithoutUsersNestedInput
    payment?: paymentUpdateManyWithoutUsersNestedInput
    userroadmap?: userroadmapUpdateManyWithoutUsersNestedInput
    voucher?: VoucherUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutQuizsubmissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assessment?: assessmentUncheckedUpdateManyWithoutUsersNestedInput
    certificate?: certificateUncheckedUpdateManyWithoutUsersNestedInput
    chatmessage?: chatmessageUncheckedUpdateManyWithoutUsersNestedInput
    counselingsession?: counselingsessionUncheckedUpdateManyWithoutUsersNestedInput
    counselor?: counselorUncheckedUpdateOneWithoutUsersNestedInput
    course?: courseUncheckedUpdateManyWithoutUsersNestedInput
    courseprogress?: courseprogressUncheckedUpdateManyWithoutUsersNestedInput
    cvreview?: cvreviewUncheckedUpdateManyWithoutUsersNestedInput
    enrollment?: enrollmentUncheckedUpdateManyWithoutUsersNestedInput
    jobmatch?: jobmatchUncheckedUpdateManyWithoutUsersNestedInput
    lessonprogress?: lessonprogressUncheckedUpdateManyWithoutUsersNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUsersNestedInput
    payment?: paymentUncheckedUpdateManyWithoutUsersNestedInput
    userroadmap?: userroadmapUncheckedUpdateManyWithoutUsersNestedInput
    voucher?: VoucherUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type paymentCreateWithoutRoadmapInput = {
    amount: number
    paymentStatus: string
    status: string
    paidAt: Date | string
    createdAt?: Date | string
    orderId?: string | null
    snapToken?: string | null
    enrollment?: enrollmentCreateNestedManyWithoutPaymentInput
    course?: courseCreateNestedOneWithoutPaymentInput
    users: UserCreateNestedOneWithoutPaymentInput
  }

  export type paymentUncheckedCreateWithoutRoadmapInput = {
    id?: number
    userId: number
    courseId?: number | null
    amount: number
    paymentStatus: string
    status: string
    paidAt: Date | string
    createdAt?: Date | string
    orderId?: string | null
    snapToken?: string | null
    enrollment?: enrollmentUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type paymentCreateOrConnectWithoutRoadmapInput = {
    where: paymentWhereUniqueInput
    create: XOR<paymentCreateWithoutRoadmapInput, paymentUncheckedCreateWithoutRoadmapInput>
  }

  export type paymentCreateManyRoadmapInputEnvelope = {
    data: paymentCreateManyRoadmapInput | paymentCreateManyRoadmapInput[]
    skipDuplicates?: boolean
  }

  export type roadmapcourseCreateWithoutRoadmapInput = {
    order: number
    course: courseCreateNestedOneWithoutRoadmapcourseInput
  }

  export type roadmapcourseUncheckedCreateWithoutRoadmapInput = {
    id?: number
    courseId: number
    order: number
  }

  export type roadmapcourseCreateOrConnectWithoutRoadmapInput = {
    where: roadmapcourseWhereUniqueInput
    create: XOR<roadmapcourseCreateWithoutRoadmapInput, roadmapcourseUncheckedCreateWithoutRoadmapInput>
  }

  export type roadmapcourseCreateManyRoadmapInputEnvelope = {
    data: roadmapcourseCreateManyRoadmapInput | roadmapcourseCreateManyRoadmapInput[]
    skipDuplicates?: boolean
  }

  export type userroadmapCreateWithoutRoadmapInput = {
    isUnlocked: boolean
    unlockedAt?: Date | string | null
    users: UserCreateNestedOneWithoutUserroadmapInput
  }

  export type userroadmapUncheckedCreateWithoutRoadmapInput = {
    id?: number
    userId: number
    isUnlocked: boolean
    unlockedAt?: Date | string | null
  }

  export type userroadmapCreateOrConnectWithoutRoadmapInput = {
    where: userroadmapWhereUniqueInput
    create: XOR<userroadmapCreateWithoutRoadmapInput, userroadmapUncheckedCreateWithoutRoadmapInput>
  }

  export type userroadmapCreateManyRoadmapInputEnvelope = {
    data: userroadmapCreateManyRoadmapInput | userroadmapCreateManyRoadmapInput[]
    skipDuplicates?: boolean
  }

  export type paymentUpsertWithWhereUniqueWithoutRoadmapInput = {
    where: paymentWhereUniqueInput
    update: XOR<paymentUpdateWithoutRoadmapInput, paymentUncheckedUpdateWithoutRoadmapInput>
    create: XOR<paymentCreateWithoutRoadmapInput, paymentUncheckedCreateWithoutRoadmapInput>
  }

  export type paymentUpdateWithWhereUniqueWithoutRoadmapInput = {
    where: paymentWhereUniqueInput
    data: XOR<paymentUpdateWithoutRoadmapInput, paymentUncheckedUpdateWithoutRoadmapInput>
  }

  export type paymentUpdateManyWithWhereWithoutRoadmapInput = {
    where: paymentScalarWhereInput
    data: XOR<paymentUpdateManyMutationInput, paymentUncheckedUpdateManyWithoutRoadmapInput>
  }

  export type roadmapcourseUpsertWithWhereUniqueWithoutRoadmapInput = {
    where: roadmapcourseWhereUniqueInput
    update: XOR<roadmapcourseUpdateWithoutRoadmapInput, roadmapcourseUncheckedUpdateWithoutRoadmapInput>
    create: XOR<roadmapcourseCreateWithoutRoadmapInput, roadmapcourseUncheckedCreateWithoutRoadmapInput>
  }

  export type roadmapcourseUpdateWithWhereUniqueWithoutRoadmapInput = {
    where: roadmapcourseWhereUniqueInput
    data: XOR<roadmapcourseUpdateWithoutRoadmapInput, roadmapcourseUncheckedUpdateWithoutRoadmapInput>
  }

  export type roadmapcourseUpdateManyWithWhereWithoutRoadmapInput = {
    where: roadmapcourseScalarWhereInput
    data: XOR<roadmapcourseUpdateManyMutationInput, roadmapcourseUncheckedUpdateManyWithoutRoadmapInput>
  }

  export type userroadmapUpsertWithWhereUniqueWithoutRoadmapInput = {
    where: userroadmapWhereUniqueInput
    update: XOR<userroadmapUpdateWithoutRoadmapInput, userroadmapUncheckedUpdateWithoutRoadmapInput>
    create: XOR<userroadmapCreateWithoutRoadmapInput, userroadmapUncheckedCreateWithoutRoadmapInput>
  }

  export type userroadmapUpdateWithWhereUniqueWithoutRoadmapInput = {
    where: userroadmapWhereUniqueInput
    data: XOR<userroadmapUpdateWithoutRoadmapInput, userroadmapUncheckedUpdateWithoutRoadmapInput>
  }

  export type userroadmapUpdateManyWithWhereWithoutRoadmapInput = {
    where: userroadmapScalarWhereInput
    data: XOR<userroadmapUpdateManyMutationInput, userroadmapUncheckedUpdateManyWithoutRoadmapInput>
  }

  export type courseCreateWithoutRoadmapcourseInput = {
    title: string
    description: string
    thumbnail: string
    isPaid: boolean
    price: number
    createdAt?: Date | string
    certificate?: certificateCreateNestedManyWithoutCourseInput
    category: categoryCreateNestedOneWithoutCourseInput
    users: UserCreateNestedOneWithoutCourseInput
    courseprogress?: courseprogressCreateNestedManyWithoutCourseInput
    coursevideo?: coursevideoCreateNestedManyWithoutCourseInput
    enrollment?: enrollmentCreateNestedManyWithoutCourseInput
    lesson?: lessonCreateNestedManyWithoutCourseInput
    payment?: paymentCreateNestedManyWithoutCourseInput
    quiz?: quizCreateNestedManyWithoutCourseInput
    quizsubmission?: quizsubmissionCreateNestedManyWithoutCourseInput
  }

  export type courseUncheckedCreateWithoutRoadmapcourseInput = {
    id?: number
    title: string
    description: string
    thumbnail: string
    categoryId: number
    isPaid: boolean
    price: number
    createdById: number
    createdAt?: Date | string
    certificate?: certificateUncheckedCreateNestedManyWithoutCourseInput
    courseprogress?: courseprogressUncheckedCreateNestedManyWithoutCourseInput
    coursevideo?: coursevideoUncheckedCreateNestedManyWithoutCourseInput
    enrollment?: enrollmentUncheckedCreateNestedManyWithoutCourseInput
    lesson?: lessonUncheckedCreateNestedManyWithoutCourseInput
    payment?: paymentUncheckedCreateNestedManyWithoutCourseInput
    quiz?: quizUncheckedCreateNestedManyWithoutCourseInput
    quizsubmission?: quizsubmissionUncheckedCreateNestedManyWithoutCourseInput
  }

  export type courseCreateOrConnectWithoutRoadmapcourseInput = {
    where: courseWhereUniqueInput
    create: XOR<courseCreateWithoutRoadmapcourseInput, courseUncheckedCreateWithoutRoadmapcourseInput>
  }

  export type roadmapCreateWithoutRoadmapcourseInput = {
    name: string
    description: string
    rewardVoucher: string
    payment?: paymentCreateNestedManyWithoutRoadmapInput
    userroadmap?: userroadmapCreateNestedManyWithoutRoadmapInput
  }

  export type roadmapUncheckedCreateWithoutRoadmapcourseInput = {
    id?: number
    name: string
    description: string
    rewardVoucher: string
    payment?: paymentUncheckedCreateNestedManyWithoutRoadmapInput
    userroadmap?: userroadmapUncheckedCreateNestedManyWithoutRoadmapInput
  }

  export type roadmapCreateOrConnectWithoutRoadmapcourseInput = {
    where: roadmapWhereUniqueInput
    create: XOR<roadmapCreateWithoutRoadmapcourseInput, roadmapUncheckedCreateWithoutRoadmapcourseInput>
  }

  export type courseUpsertWithoutRoadmapcourseInput = {
    update: XOR<courseUpdateWithoutRoadmapcourseInput, courseUncheckedUpdateWithoutRoadmapcourseInput>
    create: XOR<courseCreateWithoutRoadmapcourseInput, courseUncheckedCreateWithoutRoadmapcourseInput>
    where?: courseWhereInput
  }

  export type courseUpdateToOneWithWhereWithoutRoadmapcourseInput = {
    where?: courseWhereInput
    data: XOR<courseUpdateWithoutRoadmapcourseInput, courseUncheckedUpdateWithoutRoadmapcourseInput>
  }

  export type courseUpdateWithoutRoadmapcourseInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificate?: certificateUpdateManyWithoutCourseNestedInput
    category?: categoryUpdateOneRequiredWithoutCourseNestedInput
    users?: UserUpdateOneRequiredWithoutCourseNestedInput
    courseprogress?: courseprogressUpdateManyWithoutCourseNestedInput
    coursevideo?: coursevideoUpdateManyWithoutCourseNestedInput
    enrollment?: enrollmentUpdateManyWithoutCourseNestedInput
    lesson?: lessonUpdateManyWithoutCourseNestedInput
    payment?: paymentUpdateManyWithoutCourseNestedInput
    quiz?: quizUpdateManyWithoutCourseNestedInput
    quizsubmission?: quizsubmissionUpdateManyWithoutCourseNestedInput
  }

  export type courseUncheckedUpdateWithoutRoadmapcourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificate?: certificateUncheckedUpdateManyWithoutCourseNestedInput
    courseprogress?: courseprogressUncheckedUpdateManyWithoutCourseNestedInput
    coursevideo?: coursevideoUncheckedUpdateManyWithoutCourseNestedInput
    enrollment?: enrollmentUncheckedUpdateManyWithoutCourseNestedInput
    lesson?: lessonUncheckedUpdateManyWithoutCourseNestedInput
    payment?: paymentUncheckedUpdateManyWithoutCourseNestedInput
    quiz?: quizUncheckedUpdateManyWithoutCourseNestedInput
    quizsubmission?: quizsubmissionUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type roadmapUpsertWithoutRoadmapcourseInput = {
    update: XOR<roadmapUpdateWithoutRoadmapcourseInput, roadmapUncheckedUpdateWithoutRoadmapcourseInput>
    create: XOR<roadmapCreateWithoutRoadmapcourseInput, roadmapUncheckedCreateWithoutRoadmapcourseInput>
    where?: roadmapWhereInput
  }

  export type roadmapUpdateToOneWithWhereWithoutRoadmapcourseInput = {
    where?: roadmapWhereInput
    data: XOR<roadmapUpdateWithoutRoadmapcourseInput, roadmapUncheckedUpdateWithoutRoadmapcourseInput>
  }

  export type roadmapUpdateWithoutRoadmapcourseInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rewardVoucher?: StringFieldUpdateOperationsInput | string
    payment?: paymentUpdateManyWithoutRoadmapNestedInput
    userroadmap?: userroadmapUpdateManyWithoutRoadmapNestedInput
  }

  export type roadmapUncheckedUpdateWithoutRoadmapcourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rewardVoucher?: StringFieldUpdateOperationsInput | string
    payment?: paymentUncheckedUpdateManyWithoutRoadmapNestedInput
    userroadmap?: userroadmapUncheckedUpdateManyWithoutRoadmapNestedInput
  }

  export type roadmapCreateWithoutUserroadmapInput = {
    name: string
    description: string
    rewardVoucher: string
    payment?: paymentCreateNestedManyWithoutRoadmapInput
    roadmapcourse?: roadmapcourseCreateNestedManyWithoutRoadmapInput
  }

  export type roadmapUncheckedCreateWithoutUserroadmapInput = {
    id?: number
    name: string
    description: string
    rewardVoucher: string
    payment?: paymentUncheckedCreateNestedManyWithoutRoadmapInput
    roadmapcourse?: roadmapcourseUncheckedCreateNestedManyWithoutRoadmapInput
  }

  export type roadmapCreateOrConnectWithoutUserroadmapInput = {
    where: roadmapWhereUniqueInput
    create: XOR<roadmapCreateWithoutUserroadmapInput, roadmapUncheckedCreateWithoutUserroadmapInput>
  }

  export type UserCreateWithoutUserroadmapInput = {
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    address?: string | null
    gender?: string | null
    birthDate?: Date | string | null
    role?: $Enums.Role
    profilePicture?: string | null
    createdAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    assessment?: assessmentCreateNestedManyWithoutUsersInput
    certificate?: certificateCreateNestedManyWithoutUsersInput
    chatmessage?: chatmessageCreateNestedManyWithoutUsersInput
    counselingsession?: counselingsessionCreateNestedManyWithoutUsersInput
    counselor?: counselorCreateNestedOneWithoutUsersInput
    course?: courseCreateNestedManyWithoutUsersInput
    courseprogress?: courseprogressCreateNestedManyWithoutUsersInput
    cvreview?: cvreviewCreateNestedManyWithoutUsersInput
    enrollment?: enrollmentCreateNestedManyWithoutUsersInput
    jobmatch?: jobmatchCreateNestedManyWithoutUsersInput
    lessonprogress?: lessonprogressCreateNestedManyWithoutUsersInput
    notification?: notificationCreateNestedManyWithoutUsersInput
    payment?: paymentCreateNestedManyWithoutUsersInput
    quizsubmission?: quizsubmissionCreateNestedManyWithoutUsersInput
    voucher?: VoucherCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutUserroadmapInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    address?: string | null
    gender?: string | null
    birthDate?: Date | string | null
    role?: $Enums.Role
    profilePicture?: string | null
    createdAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    assessment?: assessmentUncheckedCreateNestedManyWithoutUsersInput
    certificate?: certificateUncheckedCreateNestedManyWithoutUsersInput
    chatmessage?: chatmessageUncheckedCreateNestedManyWithoutUsersInput
    counselingsession?: counselingsessionUncheckedCreateNestedManyWithoutUsersInput
    counselor?: counselorUncheckedCreateNestedOneWithoutUsersInput
    course?: courseUncheckedCreateNestedManyWithoutUsersInput
    courseprogress?: courseprogressUncheckedCreateNestedManyWithoutUsersInput
    cvreview?: cvreviewUncheckedCreateNestedManyWithoutUsersInput
    enrollment?: enrollmentUncheckedCreateNestedManyWithoutUsersInput
    jobmatch?: jobmatchUncheckedCreateNestedManyWithoutUsersInput
    lessonprogress?: lessonprogressUncheckedCreateNestedManyWithoutUsersInput
    notification?: notificationUncheckedCreateNestedManyWithoutUsersInput
    payment?: paymentUncheckedCreateNestedManyWithoutUsersInput
    quizsubmission?: quizsubmissionUncheckedCreateNestedManyWithoutUsersInput
    voucher?: VoucherUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutUserroadmapInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserroadmapInput, UserUncheckedCreateWithoutUserroadmapInput>
  }

  export type roadmapUpsertWithoutUserroadmapInput = {
    update: XOR<roadmapUpdateWithoutUserroadmapInput, roadmapUncheckedUpdateWithoutUserroadmapInput>
    create: XOR<roadmapCreateWithoutUserroadmapInput, roadmapUncheckedCreateWithoutUserroadmapInput>
    where?: roadmapWhereInput
  }

  export type roadmapUpdateToOneWithWhereWithoutUserroadmapInput = {
    where?: roadmapWhereInput
    data: XOR<roadmapUpdateWithoutUserroadmapInput, roadmapUncheckedUpdateWithoutUserroadmapInput>
  }

  export type roadmapUpdateWithoutUserroadmapInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rewardVoucher?: StringFieldUpdateOperationsInput | string
    payment?: paymentUpdateManyWithoutRoadmapNestedInput
    roadmapcourse?: roadmapcourseUpdateManyWithoutRoadmapNestedInput
  }

  export type roadmapUncheckedUpdateWithoutUserroadmapInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rewardVoucher?: StringFieldUpdateOperationsInput | string
    payment?: paymentUncheckedUpdateManyWithoutRoadmapNestedInput
    roadmapcourse?: roadmapcourseUncheckedUpdateManyWithoutRoadmapNestedInput
  }

  export type UserUpsertWithoutUserroadmapInput = {
    update: XOR<UserUpdateWithoutUserroadmapInput, UserUncheckedUpdateWithoutUserroadmapInput>
    create: XOR<UserCreateWithoutUserroadmapInput, UserUncheckedCreateWithoutUserroadmapInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserroadmapInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserroadmapInput, UserUncheckedUpdateWithoutUserroadmapInput>
  }

  export type UserUpdateWithoutUserroadmapInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assessment?: assessmentUpdateManyWithoutUsersNestedInput
    certificate?: certificateUpdateManyWithoutUsersNestedInput
    chatmessage?: chatmessageUpdateManyWithoutUsersNestedInput
    counselingsession?: counselingsessionUpdateManyWithoutUsersNestedInput
    counselor?: counselorUpdateOneWithoutUsersNestedInput
    course?: courseUpdateManyWithoutUsersNestedInput
    courseprogress?: courseprogressUpdateManyWithoutUsersNestedInput
    cvreview?: cvreviewUpdateManyWithoutUsersNestedInput
    enrollment?: enrollmentUpdateManyWithoutUsersNestedInput
    jobmatch?: jobmatchUpdateManyWithoutUsersNestedInput
    lessonprogress?: lessonprogressUpdateManyWithoutUsersNestedInput
    notification?: notificationUpdateManyWithoutUsersNestedInput
    payment?: paymentUpdateManyWithoutUsersNestedInput
    quizsubmission?: quizsubmissionUpdateManyWithoutUsersNestedInput
    voucher?: VoucherUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutUserroadmapInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assessment?: assessmentUncheckedUpdateManyWithoutUsersNestedInput
    certificate?: certificateUncheckedUpdateManyWithoutUsersNestedInput
    chatmessage?: chatmessageUncheckedUpdateManyWithoutUsersNestedInput
    counselingsession?: counselingsessionUncheckedUpdateManyWithoutUsersNestedInput
    counselor?: counselorUncheckedUpdateOneWithoutUsersNestedInput
    course?: courseUncheckedUpdateManyWithoutUsersNestedInput
    courseprogress?: courseprogressUncheckedUpdateManyWithoutUsersNestedInput
    cvreview?: cvreviewUncheckedUpdateManyWithoutUsersNestedInput
    enrollment?: enrollmentUncheckedUpdateManyWithoutUsersNestedInput
    jobmatch?: jobmatchUncheckedUpdateManyWithoutUsersNestedInput
    lessonprogress?: lessonprogressUncheckedUpdateManyWithoutUsersNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUsersNestedInput
    payment?: paymentUncheckedUpdateManyWithoutUsersNestedInput
    quizsubmission?: quizsubmissionUncheckedUpdateManyWithoutUsersNestedInput
    voucher?: VoucherUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UserCreateWithoutVoucherInput = {
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    address?: string | null
    gender?: string | null
    birthDate?: Date | string | null
    role?: $Enums.Role
    profilePicture?: string | null
    createdAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    assessment?: assessmentCreateNestedManyWithoutUsersInput
    certificate?: certificateCreateNestedManyWithoutUsersInput
    chatmessage?: chatmessageCreateNestedManyWithoutUsersInput
    counselingsession?: counselingsessionCreateNestedManyWithoutUsersInput
    counselor?: counselorCreateNestedOneWithoutUsersInput
    course?: courseCreateNestedManyWithoutUsersInput
    courseprogress?: courseprogressCreateNestedManyWithoutUsersInput
    cvreview?: cvreviewCreateNestedManyWithoutUsersInput
    enrollment?: enrollmentCreateNestedManyWithoutUsersInput
    jobmatch?: jobmatchCreateNestedManyWithoutUsersInput
    lessonprogress?: lessonprogressCreateNestedManyWithoutUsersInput
    notification?: notificationCreateNestedManyWithoutUsersInput
    payment?: paymentCreateNestedManyWithoutUsersInput
    quizsubmission?: quizsubmissionCreateNestedManyWithoutUsersInput
    userroadmap?: userroadmapCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutVoucherInput = {
    id?: number
    firstName?: string | null
    lastName?: string | null
    email: string
    password: string
    address?: string | null
    gender?: string | null
    birthDate?: Date | string | null
    role?: $Enums.Role
    profilePicture?: string | null
    createdAt?: Date | string
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    assessment?: assessmentUncheckedCreateNestedManyWithoutUsersInput
    certificate?: certificateUncheckedCreateNestedManyWithoutUsersInput
    chatmessage?: chatmessageUncheckedCreateNestedManyWithoutUsersInput
    counselingsession?: counselingsessionUncheckedCreateNestedManyWithoutUsersInput
    counselor?: counselorUncheckedCreateNestedOneWithoutUsersInput
    course?: courseUncheckedCreateNestedManyWithoutUsersInput
    courseprogress?: courseprogressUncheckedCreateNestedManyWithoutUsersInput
    cvreview?: cvreviewUncheckedCreateNestedManyWithoutUsersInput
    enrollment?: enrollmentUncheckedCreateNestedManyWithoutUsersInput
    jobmatch?: jobmatchUncheckedCreateNestedManyWithoutUsersInput
    lessonprogress?: lessonprogressUncheckedCreateNestedManyWithoutUsersInput
    notification?: notificationUncheckedCreateNestedManyWithoutUsersInput
    payment?: paymentUncheckedCreateNestedManyWithoutUsersInput
    quizsubmission?: quizsubmissionUncheckedCreateNestedManyWithoutUsersInput
    userroadmap?: userroadmapUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutVoucherInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVoucherInput, UserUncheckedCreateWithoutVoucherInput>
  }

  export type UserUpsertWithoutVoucherInput = {
    update: XOR<UserUpdateWithoutVoucherInput, UserUncheckedUpdateWithoutVoucherInput>
    create: XOR<UserCreateWithoutVoucherInput, UserUncheckedCreateWithoutVoucherInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVoucherInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVoucherInput, UserUncheckedUpdateWithoutVoucherInput>
  }

  export type UserUpdateWithoutVoucherInput = {
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assessment?: assessmentUpdateManyWithoutUsersNestedInput
    certificate?: certificateUpdateManyWithoutUsersNestedInput
    chatmessage?: chatmessageUpdateManyWithoutUsersNestedInput
    counselingsession?: counselingsessionUpdateManyWithoutUsersNestedInput
    counselor?: counselorUpdateOneWithoutUsersNestedInput
    course?: courseUpdateManyWithoutUsersNestedInput
    courseprogress?: courseprogressUpdateManyWithoutUsersNestedInput
    cvreview?: cvreviewUpdateManyWithoutUsersNestedInput
    enrollment?: enrollmentUpdateManyWithoutUsersNestedInput
    jobmatch?: jobmatchUpdateManyWithoutUsersNestedInput
    lessonprogress?: lessonprogressUpdateManyWithoutUsersNestedInput
    notification?: notificationUpdateManyWithoutUsersNestedInput
    payment?: paymentUpdateManyWithoutUsersNestedInput
    quizsubmission?: quizsubmissionUpdateManyWithoutUsersNestedInput
    userroadmap?: userroadmapUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutVoucherInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assessment?: assessmentUncheckedUpdateManyWithoutUsersNestedInput
    certificate?: certificateUncheckedUpdateManyWithoutUsersNestedInput
    chatmessage?: chatmessageUncheckedUpdateManyWithoutUsersNestedInput
    counselingsession?: counselingsessionUncheckedUpdateManyWithoutUsersNestedInput
    counselor?: counselorUncheckedUpdateOneWithoutUsersNestedInput
    course?: courseUncheckedUpdateManyWithoutUsersNestedInput
    courseprogress?: courseprogressUncheckedUpdateManyWithoutUsersNestedInput
    cvreview?: cvreviewUncheckedUpdateManyWithoutUsersNestedInput
    enrollment?: enrollmentUncheckedUpdateManyWithoutUsersNestedInput
    jobmatch?: jobmatchUncheckedUpdateManyWithoutUsersNestedInput
    lessonprogress?: lessonprogressUncheckedUpdateManyWithoutUsersNestedInput
    notification?: notificationUncheckedUpdateManyWithoutUsersNestedInput
    payment?: paymentUncheckedUpdateManyWithoutUsersNestedInput
    quizsubmission?: quizsubmissionUncheckedUpdateManyWithoutUsersNestedInput
    userroadmap?: userroadmapUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type assessmentCreateManyUsersInput = {
    id?: number
    studentStatus: string
    majorStudy: string
    currentSemester: string
    createdAt?: Date | string
    currentField: string
    dreamJob: string
    interestedField: string
    mainGoal: string
  }

  export type certificateCreateManyUsersInput = {
    id?: number
    courseId: number
    filePath: string
    issuedAt: Date | string
  }

  export type chatmessageCreateManyUsersInput = {
    id?: number
    sessionId: number
    message: string
    sentAt?: Date | string
  }

  export type counselingsessionCreateManyUsersInput = {
    id?: number
    counselorId: number
    topic: string
    question: string
    response?: string | null
    status: string
    createdAt?: Date | string
    rating?: number | null
    feedback?: string | null
  }

  export type courseCreateManyUsersInput = {
    id?: number
    title: string
    description: string
    thumbnail: string
    categoryId: number
    isPaid: boolean
    price: number
    createdAt?: Date | string
  }

  export type courseprogressCreateManyUsersInput = {
    id?: number
    courseId: number
    completedVideoCount: number
    completedQuizCount: number
    isCompleted: boolean
  }

  export type cvreviewCreateManyUsersInput = {
    id?: number
    cvFilePath: string
    cvVersion: number
    reviewResult: string
    relevanceScore: number
    feedback: string
    createdAt?: Date | string
  }

  export type enrollmentCreateManyUsersInput = {
    id?: number
    courseId: number
    enrolledAt?: Date | string
    isPaid: boolean
    paymentId?: number | null
  }

  export type jobmatchCreateManyUsersInput = {
    id?: number
    cvFilePath: string
    matchedJobs: JsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
  }

  export type lessonprogressCreateManyUsersInput = {
    id?: number
    lessonId: number
    isCompleted?: boolean
    updatedAt: Date | string
  }

  export type notificationCreateManyUsersInput = {
    id?: number
    message: string
    isRead?: boolean
    createdAt?: Date | string
    type: string
  }

  export type paymentCreateManyUsersInput = {
    id?: number
    courseId?: number | null
    roadmapId?: number | null
    amount: number
    paymentStatus: string
    status: string
    paidAt: Date | string
    createdAt?: Date | string
    orderId?: string | null
    snapToken?: string | null
  }

  export type quizsubmissionCreateManyUsersInput = {
    id?: number
    courseId: number
    quizId: number
    answers: JsonNullValueInput | InputJsonValue
    score: number
    totalQuestions: number
    isPassed: boolean
    createdAt?: Date | string
  }

  export type userroadmapCreateManyUsersInput = {
    id?: number
    roadmapId: number
    isUnlocked: boolean
    unlockedAt?: Date | string | null
  }

  export type VoucherCreateManyUsersInput = {
    id?: number
    code: string
    discount: number
    expiresAt: Date | string
    isUsed?: boolean
  }

  export type assessmentUpdateWithoutUsersInput = {
    studentStatus?: StringFieldUpdateOperationsInput | string
    majorStudy?: StringFieldUpdateOperationsInput | string
    currentSemester?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentField?: StringFieldUpdateOperationsInput | string
    dreamJob?: StringFieldUpdateOperationsInput | string
    interestedField?: StringFieldUpdateOperationsInput | string
    mainGoal?: StringFieldUpdateOperationsInput | string
  }

  export type assessmentUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentStatus?: StringFieldUpdateOperationsInput | string
    majorStudy?: StringFieldUpdateOperationsInput | string
    currentSemester?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentField?: StringFieldUpdateOperationsInput | string
    dreamJob?: StringFieldUpdateOperationsInput | string
    interestedField?: StringFieldUpdateOperationsInput | string
    mainGoal?: StringFieldUpdateOperationsInput | string
  }

  export type assessmentUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentStatus?: StringFieldUpdateOperationsInput | string
    majorStudy?: StringFieldUpdateOperationsInput | string
    currentSemester?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentField?: StringFieldUpdateOperationsInput | string
    dreamJob?: StringFieldUpdateOperationsInput | string
    interestedField?: StringFieldUpdateOperationsInput | string
    mainGoal?: StringFieldUpdateOperationsInput | string
  }

  export type certificateUpdateWithoutUsersInput = {
    filePath?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: courseUpdateOneRequiredWithoutCertificateNestedInput
  }

  export type certificateUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    filePath?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type certificateUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    filePath?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type chatmessageUpdateWithoutUsersInput = {
    message?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    counselingsession?: counselingsessionUpdateOneRequiredWithoutChatmessageNestedInput
  }

  export type chatmessageUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type chatmessageUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type counselingsessionUpdateWithoutUsersInput = {
    topic?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    chatmessage?: chatmessageUpdateManyWithoutCounselingsessionNestedInput
    counselor?: counselorUpdateOneRequiredWithoutCounselingsessionNestedInput
  }

  export type counselingsessionUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    counselorId?: IntFieldUpdateOperationsInput | number
    topic?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    chatmessage?: chatmessageUncheckedUpdateManyWithoutCounselingsessionNestedInput
  }

  export type counselingsessionUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    counselorId?: IntFieldUpdateOperationsInput | number
    topic?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type courseUpdateWithoutUsersInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificate?: certificateUpdateManyWithoutCourseNestedInput
    category?: categoryUpdateOneRequiredWithoutCourseNestedInput
    courseprogress?: courseprogressUpdateManyWithoutCourseNestedInput
    coursevideo?: coursevideoUpdateManyWithoutCourseNestedInput
    enrollment?: enrollmentUpdateManyWithoutCourseNestedInput
    lesson?: lessonUpdateManyWithoutCourseNestedInput
    payment?: paymentUpdateManyWithoutCourseNestedInput
    quiz?: quizUpdateManyWithoutCourseNestedInput
    quizsubmission?: quizsubmissionUpdateManyWithoutCourseNestedInput
    roadmapcourse?: roadmapcourseUpdateManyWithoutCourseNestedInput
  }

  export type courseUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificate?: certificateUncheckedUpdateManyWithoutCourseNestedInput
    courseprogress?: courseprogressUncheckedUpdateManyWithoutCourseNestedInput
    coursevideo?: coursevideoUncheckedUpdateManyWithoutCourseNestedInput
    enrollment?: enrollmentUncheckedUpdateManyWithoutCourseNestedInput
    lesson?: lessonUncheckedUpdateManyWithoutCourseNestedInput
    payment?: paymentUncheckedUpdateManyWithoutCourseNestedInput
    quiz?: quizUncheckedUpdateManyWithoutCourseNestedInput
    quizsubmission?: quizsubmissionUncheckedUpdateManyWithoutCourseNestedInput
    roadmapcourse?: roadmapcourseUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type courseUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type courseprogressUpdateWithoutUsersInput = {
    completedVideoCount?: IntFieldUpdateOperationsInput | number
    completedQuizCount?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    course?: courseUpdateOneRequiredWithoutCourseprogressNestedInput
  }

  export type courseprogressUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    completedVideoCount?: IntFieldUpdateOperationsInput | number
    completedQuizCount?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type courseprogressUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    completedVideoCount?: IntFieldUpdateOperationsInput | number
    completedQuizCount?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type cvreviewUpdateWithoutUsersInput = {
    cvFilePath?: StringFieldUpdateOperationsInput | string
    cvVersion?: IntFieldUpdateOperationsInput | number
    reviewResult?: StringFieldUpdateOperationsInput | string
    relevanceScore?: IntFieldUpdateOperationsInput | number
    feedback?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cvreviewUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    cvFilePath?: StringFieldUpdateOperationsInput | string
    cvVersion?: IntFieldUpdateOperationsInput | number
    reviewResult?: StringFieldUpdateOperationsInput | string
    relevanceScore?: IntFieldUpdateOperationsInput | number
    feedback?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type cvreviewUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    cvFilePath?: StringFieldUpdateOperationsInput | string
    cvVersion?: IntFieldUpdateOperationsInput | number
    reviewResult?: StringFieldUpdateOperationsInput | string
    relevanceScore?: IntFieldUpdateOperationsInput | number
    feedback?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type enrollmentUpdateWithoutUsersInput = {
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    course?: courseUpdateOneRequiredWithoutEnrollmentNestedInput
    payment?: paymentUpdateOneWithoutEnrollmentNestedInput
  }

  export type enrollmentUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paymentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type enrollmentUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paymentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type jobmatchUpdateWithoutUsersInput = {
    cvFilePath?: StringFieldUpdateOperationsInput | string
    matchedJobs?: JsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type jobmatchUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    cvFilePath?: StringFieldUpdateOperationsInput | string
    matchedJobs?: JsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type jobmatchUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    cvFilePath?: StringFieldUpdateOperationsInput | string
    matchedJobs?: JsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type lessonprogressUpdateWithoutUsersInput = {
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lesson?: lessonUpdateOneRequiredWithoutLessonprogressNestedInput
  }

  export type lessonprogressUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    lessonId?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type lessonprogressUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    lessonId?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationUpdateWithoutUsersInput = {
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type notificationUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type notificationUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type paymentUpdateWithoutUsersInput = {
    amount?: IntFieldUpdateOperationsInput | number
    paymentStatus?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    snapToken?: NullableStringFieldUpdateOperationsInput | string | null
    enrollment?: enrollmentUpdateManyWithoutPaymentNestedInput
    course?: courseUpdateOneWithoutPaymentNestedInput
    roadmap?: roadmapUpdateOneWithoutPaymentNestedInput
  }

  export type paymentUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    roadmapId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: IntFieldUpdateOperationsInput | number
    paymentStatus?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    snapToken?: NullableStringFieldUpdateOperationsInput | string | null
    enrollment?: enrollmentUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type paymentUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    roadmapId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: IntFieldUpdateOperationsInput | number
    paymentStatus?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    snapToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type quizsubmissionUpdateWithoutUsersInput = {
    answers?: JsonNullValueInput | InputJsonValue
    score?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    isPassed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: courseUpdateOneRequiredWithoutQuizsubmissionNestedInput
    quiz?: quizUpdateOneRequiredWithoutQuizsubmissionNestedInput
  }

  export type quizsubmissionUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    quizId?: IntFieldUpdateOperationsInput | number
    answers?: JsonNullValueInput | InputJsonValue
    score?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    isPassed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type quizsubmissionUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    quizId?: IntFieldUpdateOperationsInput | number
    answers?: JsonNullValueInput | InputJsonValue
    score?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    isPassed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userroadmapUpdateWithoutUsersInput = {
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roadmap?: roadmapUpdateOneRequiredWithoutUserroadmapNestedInput
  }

  export type userroadmapUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    roadmapId?: IntFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userroadmapUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    roadmapId?: IntFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VoucherUpdateWithoutUsersInput = {
    code?: StringFieldUpdateOperationsInput | string
    discount?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VoucherUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    discount?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VoucherUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    discount?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type courseCreateManyCategoryInput = {
    id?: number
    title: string
    description: string
    thumbnail: string
    isPaid: boolean
    price: number
    createdById: number
    createdAt?: Date | string
  }

  export type courseUpdateWithoutCategoryInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificate?: certificateUpdateManyWithoutCourseNestedInput
    users?: UserUpdateOneRequiredWithoutCourseNestedInput
    courseprogress?: courseprogressUpdateManyWithoutCourseNestedInput
    coursevideo?: coursevideoUpdateManyWithoutCourseNestedInput
    enrollment?: enrollmentUpdateManyWithoutCourseNestedInput
    lesson?: lessonUpdateManyWithoutCourseNestedInput
    payment?: paymentUpdateManyWithoutCourseNestedInput
    quiz?: quizUpdateManyWithoutCourseNestedInput
    quizsubmission?: quizsubmissionUpdateManyWithoutCourseNestedInput
    roadmapcourse?: roadmapcourseUpdateManyWithoutCourseNestedInput
  }

  export type courseUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificate?: certificateUncheckedUpdateManyWithoutCourseNestedInput
    courseprogress?: courseprogressUncheckedUpdateManyWithoutCourseNestedInput
    coursevideo?: coursevideoUncheckedUpdateManyWithoutCourseNestedInput
    enrollment?: enrollmentUncheckedUpdateManyWithoutCourseNestedInput
    lesson?: lessonUncheckedUpdateManyWithoutCourseNestedInput
    payment?: paymentUncheckedUpdateManyWithoutCourseNestedInput
    quiz?: quizUncheckedUpdateManyWithoutCourseNestedInput
    quizsubmission?: quizsubmissionUncheckedUpdateManyWithoutCourseNestedInput
    roadmapcourse?: roadmapcourseUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type courseUncheckedUpdateManyWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    thumbnail?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    price?: IntFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type chatmessageCreateManyCounselingsessionInput = {
    id?: number
    senderId: number
    message: string
    sentAt?: Date | string
  }

  export type chatmessageUpdateWithoutCounselingsessionInput = {
    message?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateOneRequiredWithoutChatmessageNestedInput
  }

  export type chatmessageUncheckedUpdateWithoutCounselingsessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type chatmessageUncheckedUpdateManyWithoutCounselingsessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type counselingsessionCreateManyCounselorInput = {
    id?: number
    userId: number
    topic: string
    question: string
    response?: string | null
    status: string
    createdAt?: Date | string
    rating?: number | null
    feedback?: string | null
  }

  export type counselingsessionUpdateWithoutCounselorInput = {
    topic?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    chatmessage?: chatmessageUpdateManyWithoutCounselingsessionNestedInput
    users?: UserUpdateOneRequiredWithoutCounselingsessionNestedInput
  }

  export type counselingsessionUncheckedUpdateWithoutCounselorInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    topic?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    chatmessage?: chatmessageUncheckedUpdateManyWithoutCounselingsessionNestedInput
  }

  export type counselingsessionUncheckedUpdateManyWithoutCounselorInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    topic?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type certificateCreateManyCourseInput = {
    id?: number
    userId: number
    filePath: string
    issuedAt: Date | string
  }

  export type courseprogressCreateManyCourseInput = {
    id?: number
    userId: number
    completedVideoCount: number
    completedQuizCount: number
    isCompleted: boolean
  }

  export type coursevideoCreateManyCourseInput = {
    id?: number
    title: string
    videoUrl: string
    isLocked: boolean
    order: number
    s3Key?: string | null
  }

  export type enrollmentCreateManyCourseInput = {
    id?: number
    userId: number
    enrolledAt?: Date | string
    isPaid: boolean
    paymentId?: number | null
  }

  export type lessonCreateManyCourseInput = {
    id?: number
    title: string
    content: string
    order: number
  }

  export type paymentCreateManyCourseInput = {
    id?: number
    userId: number
    roadmapId?: number | null
    amount: number
    paymentStatus: string
    status: string
    paidAt: Date | string
    createdAt?: Date | string
    orderId?: string | null
    snapToken?: string | null
  }

  export type quizCreateManyCourseInput = {
    id?: number
    question: string
    options: JsonNullValueInput | InputJsonValue
    correctAnswer: string
    isLocked: boolean
  }

  export type quizsubmissionCreateManyCourseInput = {
    id?: number
    userId: number
    quizId: number
    answers: JsonNullValueInput | InputJsonValue
    score: number
    totalQuestions: number
    isPassed: boolean
    createdAt?: Date | string
  }

  export type roadmapcourseCreateManyCourseInput = {
    id?: number
    roadmapId: number
    order: number
  }

  export type certificateUpdateWithoutCourseInput = {
    filePath?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateOneRequiredWithoutCertificateNestedInput
  }

  export type certificateUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    filePath?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type certificateUncheckedUpdateManyWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    filePath?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type courseprogressUpdateWithoutCourseInput = {
    completedVideoCount?: IntFieldUpdateOperationsInput | number
    completedQuizCount?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    users?: UserUpdateOneRequiredWithoutCourseprogressNestedInput
  }

  export type courseprogressUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    completedVideoCount?: IntFieldUpdateOperationsInput | number
    completedQuizCount?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type courseprogressUncheckedUpdateManyWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    completedVideoCount?: IntFieldUpdateOperationsInput | number
    completedQuizCount?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type coursevideoUpdateWithoutCourseInput = {
    title?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    s3Key?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type coursevideoUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    s3Key?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type coursevideoUncheckedUpdateManyWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    videoUrl?: StringFieldUpdateOperationsInput | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    s3Key?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type enrollmentUpdateWithoutCourseInput = {
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    payment?: paymentUpdateOneWithoutEnrollmentNestedInput
    users?: UserUpdateOneRequiredWithoutEnrollmentNestedInput
  }

  export type enrollmentUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paymentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type enrollmentUncheckedUpdateManyWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    paymentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type lessonUpdateWithoutCourseInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    lessonprogress?: lessonprogressUpdateManyWithoutLessonNestedInput
  }

  export type lessonUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    lessonprogress?: lessonprogressUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type lessonUncheckedUpdateManyWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type paymentUpdateWithoutCourseInput = {
    amount?: IntFieldUpdateOperationsInput | number
    paymentStatus?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    snapToken?: NullableStringFieldUpdateOperationsInput | string | null
    enrollment?: enrollmentUpdateManyWithoutPaymentNestedInput
    roadmap?: roadmapUpdateOneWithoutPaymentNestedInput
    users?: UserUpdateOneRequiredWithoutPaymentNestedInput
  }

  export type paymentUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    roadmapId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: IntFieldUpdateOperationsInput | number
    paymentStatus?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    snapToken?: NullableStringFieldUpdateOperationsInput | string | null
    enrollment?: enrollmentUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type paymentUncheckedUpdateManyWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    roadmapId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: IntFieldUpdateOperationsInput | number
    paymentStatus?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    snapToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type quizUpdateWithoutCourseInput = {
    question?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    correctAnswer?: StringFieldUpdateOperationsInput | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    quizsubmission?: quizsubmissionUpdateManyWithoutQuizNestedInput
  }

  export type quizUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    correctAnswer?: StringFieldUpdateOperationsInput | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    quizsubmission?: quizsubmissionUncheckedUpdateManyWithoutQuizNestedInput
  }

  export type quizUncheckedUpdateManyWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    correctAnswer?: StringFieldUpdateOperationsInput | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type quizsubmissionUpdateWithoutCourseInput = {
    answers?: JsonNullValueInput | InputJsonValue
    score?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    isPassed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quiz?: quizUpdateOneRequiredWithoutQuizsubmissionNestedInput
    users?: UserUpdateOneRequiredWithoutQuizsubmissionNestedInput
  }

  export type quizsubmissionUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    quizId?: IntFieldUpdateOperationsInput | number
    answers?: JsonNullValueInput | InputJsonValue
    score?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    isPassed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type quizsubmissionUncheckedUpdateManyWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    quizId?: IntFieldUpdateOperationsInput | number
    answers?: JsonNullValueInput | InputJsonValue
    score?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    isPassed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type roadmapcourseUpdateWithoutCourseInput = {
    order?: IntFieldUpdateOperationsInput | number
    roadmap?: roadmapUpdateOneRequiredWithoutRoadmapcourseNestedInput
  }

  export type roadmapcourseUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    roadmapId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
  }

  export type roadmapcourseUncheckedUpdateManyWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    roadmapId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
  }

  export type lessonprogressCreateManyLessonInput = {
    id?: number
    userId: number
    isCompleted?: boolean
    updatedAt: Date | string
  }

  export type lessonprogressUpdateWithoutLessonInput = {
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateOneRequiredWithoutLessonprogressNestedInput
  }

  export type lessonprogressUncheckedUpdateWithoutLessonInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type lessonprogressUncheckedUpdateManyWithoutLessonInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type enrollmentCreateManyPaymentInput = {
    id?: number
    userId: number
    courseId: number
    enrolledAt?: Date | string
    isPaid: boolean
  }

  export type enrollmentUpdateWithoutPaymentInput = {
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    course?: courseUpdateOneRequiredWithoutEnrollmentNestedInput
    users?: UserUpdateOneRequiredWithoutEnrollmentNestedInput
  }

  export type enrollmentUncheckedUpdateWithoutPaymentInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
  }

  export type enrollmentUncheckedUpdateManyWithoutPaymentInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
  }

  export type quizsubmissionCreateManyQuizInput = {
    id?: number
    userId: number
    courseId: number
    answers: JsonNullValueInput | InputJsonValue
    score: number
    totalQuestions: number
    isPassed: boolean
    createdAt?: Date | string
  }

  export type quizsubmissionUpdateWithoutQuizInput = {
    answers?: JsonNullValueInput | InputJsonValue
    score?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    isPassed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: courseUpdateOneRequiredWithoutQuizsubmissionNestedInput
    users?: UserUpdateOneRequiredWithoutQuizsubmissionNestedInput
  }

  export type quizsubmissionUncheckedUpdateWithoutQuizInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    answers?: JsonNullValueInput | InputJsonValue
    score?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    isPassed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type quizsubmissionUncheckedUpdateManyWithoutQuizInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    answers?: JsonNullValueInput | InputJsonValue
    score?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    isPassed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type paymentCreateManyRoadmapInput = {
    id?: number
    userId: number
    courseId?: number | null
    amount: number
    paymentStatus: string
    status: string
    paidAt: Date | string
    createdAt?: Date | string
    orderId?: string | null
    snapToken?: string | null
  }

  export type roadmapcourseCreateManyRoadmapInput = {
    id?: number
    courseId: number
    order: number
  }

  export type userroadmapCreateManyRoadmapInput = {
    id?: number
    userId: number
    isUnlocked: boolean
    unlockedAt?: Date | string | null
  }

  export type paymentUpdateWithoutRoadmapInput = {
    amount?: IntFieldUpdateOperationsInput | number
    paymentStatus?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    snapToken?: NullableStringFieldUpdateOperationsInput | string | null
    enrollment?: enrollmentUpdateManyWithoutPaymentNestedInput
    course?: courseUpdateOneWithoutPaymentNestedInput
    users?: UserUpdateOneRequiredWithoutPaymentNestedInput
  }

  export type paymentUncheckedUpdateWithoutRoadmapInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: IntFieldUpdateOperationsInput | number
    paymentStatus?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    snapToken?: NullableStringFieldUpdateOperationsInput | string | null
    enrollment?: enrollmentUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type paymentUncheckedUpdateManyWithoutRoadmapInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: IntFieldUpdateOperationsInput | number
    paymentStatus?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    snapToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type roadmapcourseUpdateWithoutRoadmapInput = {
    order?: IntFieldUpdateOperationsInput | number
    course?: courseUpdateOneRequiredWithoutRoadmapcourseNestedInput
  }

  export type roadmapcourseUncheckedUpdateWithoutRoadmapInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
  }

  export type roadmapcourseUncheckedUpdateManyWithoutRoadmapInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
  }

  export type userroadmapUpdateWithoutRoadmapInput = {
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUpdateOneRequiredWithoutUserroadmapNestedInput
  }

  export type userroadmapUncheckedUpdateWithoutRoadmapInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userroadmapUncheckedUpdateManyWithoutRoadmapInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    isUnlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}